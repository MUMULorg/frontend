{"ast":null,"code":"import { useNavigation, useRoute } from '@react-navigation/core';\nimport * as React from 'react';\nfunction getScrollableNode(ref) {\n  if (ref.current == null) {\n    return null;\n  }\n  if ('scrollToTop' in ref.current || 'scrollTo' in ref.current || 'scrollToOffset' in ref.current || 'scrollResponderScrollTo' in ref.current) {\n    // This is already a scrollable node.\n    return ref.current;\n  } else if ('getScrollResponder' in ref.current) {\n    // If the view is a wrapper like FlatList, SectionList etc.\n    // We need to use `getScrollResponder` to get access to the scroll responder\n    return ref.current.getScrollResponder();\n  } else if ('getNode' in ref.current) {\n    // When a `ScrollView` is wraped in `Animated.createAnimatedComponent`\n    // we need to use `getNode` to get the ref to the actual scrollview.\n    // Note that `getNode` is deprecated in newer versions of react-native\n    // this is why we check if we already have a scrollable node above.\n    return ref.current.getNode();\n  } else {\n    return ref.current;\n  }\n}\nexport default function useScrollToTop(ref) {\n  const navigation = useNavigation();\n  const route = useRoute();\n  React.useEffect(() => {\n    let tabNavigations = [];\n    let currentNavigation = navigation;\n\n    // If the screen is nested inside multiple tab navigators, we should scroll to top for any of them\n    // So we need to find all the parent tab navigators and add the listeners there\n    while (currentNavigation) {\n      if (currentNavigation.getState().type === 'tab') {\n        tabNavigations.push(currentNavigation);\n      }\n      currentNavigation = currentNavigation.getParent();\n    }\n    if (tabNavigations.length === 0) {\n      return;\n    }\n    const unsubscribers = tabNavigations.map(tab => {\n      return tab.addListener(\n      // We don't wanna import tab types here to avoid extra deps\n      // in addition, there are multiple tab implementations\n      // @ts-expect-error\n      'tabPress', e => {\n        // We should scroll to top only when the screen is focused\n        const isFocused = navigation.isFocused();\n\n        // In a nested stack navigator, tab press resets the stack to first screen\n        // So we should scroll to top only when we are on first screen\n        const isFirst = tabNavigations.includes(navigation) || navigation.getState().routes[0].key === route.key;\n\n        // Run the operation in the next frame so we're sure all listeners have been run\n        // This is necessary to know if preventDefault() has been called\n        requestAnimationFrame(() => {\n          const scrollable = getScrollableNode(ref);\n          if (isFocused && isFirst && scrollable && !e.defaultPrevented) {\n            if ('scrollToTop' in scrollable) {\n              scrollable.scrollToTop();\n            } else if ('scrollTo' in scrollable) {\n              scrollable.scrollTo({\n                y: 0,\n                animated: true\n              });\n            } else if ('scrollToOffset' in scrollable) {\n              scrollable.scrollToOffset({\n                offset: 0,\n                animated: true\n              });\n            } else if ('scrollResponderScrollTo' in scrollable) {\n              scrollable.scrollResponderScrollTo({\n                y: 0,\n                animated: true\n              });\n            }\n          }\n        });\n      });\n    });\n    return () => {\n      unsubscribers.forEach(unsubscribe => unsubscribe());\n    };\n  }, [navigation, ref, route.key]);\n}","map":null,"metadata":{},"sourceType":"module"}