{"ast":null,"code":"//! @version js-joda - 1.11.0\n//! @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors\n//! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n//! @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nfunction createErrorType(name, init) {\n  var superErrorClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Error;\n  function E(message) {\n    if (!Error.captureStackTrace) {\n      this.stack = new Error().stack;\n    } else {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    this.message = message;\n    init && init.apply(this, arguments);\n    this.toString = function () {\n      return this.name + ': ' + this.message;\n    };\n  }\n  E.prototype = new superErrorClass();\n  E.prototype.name = name;\n  E.prototype.constructor = E;\n  return E;\n}\nvar DateTimeException = createErrorType('DateTimeException', messageWithCause);\nvar DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);\nvar UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);\nvar ArithmeticException = createErrorType('ArithmeticException');\nvar IllegalArgumentException = createErrorType('IllegalArgumentException');\nvar IllegalStateException = createErrorType('IllegalStateException');\nvar NullPointerException = createErrorType('NullPointerException');\nfunction messageWithCause(message) {\n  var cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var msg = message || this.name;\n  if (cause !== null && cause instanceof Error) {\n    msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n  }\n  this.message = msg;\n}\nfunction messageForDateTimeParseException(message) {\n  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var msg = message || this.name;\n  msg += ': ' + text + ', at index: ' + index;\n  if (cause !== null && cause instanceof Error) {\n    msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n  }\n  this.message = msg;\n  this.parsedString = function () {\n    return text;\n  };\n  this.errorIndex = function () {\n    return index;\n  };\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nfunction assert(assertion, msg, error) {\n  if (!assertion) {\n    if (error) {\n      throw new error(msg);\n    } else {\n      throw new Error(msg);\n    }\n  }\n}\nfunction requireNonNull(value, parameterName) {\n  if (value == null) {\n    throw new NullPointerException(parameterName + ' must not be null');\n  }\n  return value;\n}\nfunction requireInstance(value, _class, parameterName) {\n  if (!(value instanceof _class)) {\n    throw new IllegalArgumentException(parameterName + ' must be an instance of ' + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ', but is ' + value.constructor.name : ''));\n  }\n  return value;\n}\nfunction abstractMethodFail(methodName) {\n  throw new TypeError('abstract method \"' + methodName + '\" is not implemented');\n}\nvar assert$1 = /*#__PURE__*/Object.freeze({\n  assert: assert,\n  requireNonNull: requireNonNull,\n  requireInstance: requireInstance,\n  abstractMethodFail: abstractMethodFail\n});\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar MIN_SAFE_INTEGER = -9007199254740991;\nvar MathUtil = function () {\n  function MathUtil() {\n    _classCallCheck(this, MathUtil);\n  }\n  MathUtil.intDiv = function intDiv(x, y) {\n    var r = x / y;\n    r = MathUtil.roundDown(r);\n    return MathUtil.safeZero(r);\n  };\n  MathUtil.intMod = function intMod(x, y) {\n    var r = x - MathUtil.intDiv(x, y) * y;\n    r = MathUtil.roundDown(r);\n    return MathUtil.safeZero(r);\n  };\n  MathUtil.roundDown = function roundDown(r) {\n    if (r < 0) {\n      return Math.ceil(r);\n    } else {\n      return Math.floor(r);\n    }\n  };\n  MathUtil.floorDiv = function floorDiv(x, y) {\n    var r = Math.floor(x / y);\n    return MathUtil.safeZero(r);\n  };\n  MathUtil.floorMod = function floorMod(x, y) {\n    var r = x - MathUtil.floorDiv(x, y) * y;\n    return MathUtil.safeZero(r);\n  };\n  MathUtil.safeAdd = function safeAdd(x, y) {\n    MathUtil.verifyInt(x);\n    MathUtil.verifyInt(y);\n    if (x === 0) {\n      return MathUtil.safeZero(y);\n    }\n    if (y === 0) {\n      return MathUtil.safeZero(x);\n    }\n    var r = MathUtil.safeToInt(x + y);\n    if (r === x || r === y) {\n      throw new ArithmeticException('Invalid addition beyond MAX_SAFE_INTEGER!');\n    }\n    return r;\n  };\n  MathUtil.safeSubtract = function safeSubtract(x, y) {\n    MathUtil.verifyInt(x);\n    MathUtil.verifyInt(y);\n    if (x === 0 && y === 0) {\n      return 0;\n    } else if (x === 0) {\n      return MathUtil.safeZero(-1 * y);\n    } else if (y === 0) {\n      return MathUtil.safeZero(x);\n    }\n    return MathUtil.safeToInt(x - y);\n  };\n  MathUtil.safeMultiply = function safeMultiply(x, y) {\n    MathUtil.verifyInt(x);\n    MathUtil.verifyInt(y);\n    if (x === 1) {\n      return MathUtil.safeZero(y);\n    }\n    if (y === 1) {\n      return MathUtil.safeZero(x);\n    }\n    if (x === 0 || y === 0) {\n      return 0;\n    }\n    var r = MathUtil.safeToInt(x * y);\n    if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {\n      throw new ArithmeticException('Multiplication overflows: ' + x + ' * ' + y);\n    }\n    return r;\n  };\n  MathUtil.parseInt = function (_parseInt) {\n    function parseInt(_x) {\n      return _parseInt.apply(this, arguments);\n    }\n    parseInt.toString = function () {\n      return _parseInt.toString();\n    };\n    return parseInt;\n  }(function (value) {\n    var r = parseInt(value);\n    return MathUtil.safeToInt(r);\n  });\n  MathUtil.safeToInt = function safeToInt(value) {\n    MathUtil.verifyInt(value);\n    return MathUtil.safeZero(value);\n  };\n  MathUtil.verifyInt = function verifyInt(value) {\n    if (value == null) {\n      throw new ArithmeticException('Invalid value: \\'' + value + '\\', using null or undefined as argument');\n    }\n    if (isNaN(value)) {\n      throw new ArithmeticException('Invalid int value, using NaN as argument');\n    }\n    if (value % 1 !== 0) {\n      throw new ArithmeticException('Invalid value: \\'' + value + '\\' is a float');\n    }\n    if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {\n      throw new ArithmeticException('Calculation overflows an int: ' + value);\n    }\n  };\n  MathUtil.safeZero = function safeZero(value) {\n    return value === 0 ? 0 : +value;\n  };\n  MathUtil.compareNumbers = function compareNumbers(a, b) {\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  };\n  MathUtil.smi = function smi(int) {\n    return int >>> 1 & 0x40000000 | int & 0xBFFFFFFF;\n  };\n  MathUtil.hash = function hash(number) {\n    if (number !== number || number === Infinity) {\n      return 0;\n    }\n    var result = number;\n    while (number > 0xFFFFFFFF) {\n      number /= 0xFFFFFFFF;\n      result ^= number;\n    }\n    return MathUtil.smi(result);\n  };\n  MathUtil.hashCode = function hashCode() {\n    var result = 17;\n    for (var _len = arguments.length, numbers = Array(_len), _key = 0; _key < _len; _key++) {\n      numbers[_key] = arguments[_key];\n    }\n    for (var _iterator = numbers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n      var n = _ref;\n      result = (result << 5) - result + MathUtil.hash(n);\n    }\n    return MathUtil.hash(result);\n  };\n  return MathUtil;\n}();\nMathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nMathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;\nfunction _classCallCheck$1(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar Enum = function () {\n  function Enum(name) {\n    _classCallCheck$1(this, Enum);\n    this._name = name;\n  }\n  Enum.prototype.equals = function equals(other) {\n    return this === other;\n  };\n  Enum.prototype.toString = function toString() {\n    return this._name;\n  };\n  Enum.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  return Enum;\n}();\nfunction _classCallCheck$2(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar TemporalAmount = function () {\n  function TemporalAmount() {\n    _classCallCheck$2(this, TemporalAmount);\n  }\n  TemporalAmount.prototype.get = function get(unit) {\n    abstractMethodFail('get');\n  };\n  TemporalAmount.prototype.units = function units() {\n    abstractMethodFail('units');\n  };\n  TemporalAmount.prototype.addTo = function addTo(temporal) {\n    abstractMethodFail('addTo');\n  };\n  TemporalAmount.prototype.subtractFrom = function subtractFrom(temporal) {\n    abstractMethodFail('subtractFrom');\n  };\n  return TemporalAmount;\n}();\nfunction _classCallCheck$3(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar TemporalUnit = function () {\n  function TemporalUnit() {\n    _classCallCheck$3(this, TemporalUnit);\n  }\n  TemporalUnit.prototype.duration = function duration() {\n    abstractMethodFail('duration');\n  };\n  TemporalUnit.prototype.isDurationEstimated = function isDurationEstimated() {\n    abstractMethodFail('isDurationEstimated');\n  };\n  TemporalUnit.prototype.isDateBased = function isDateBased() {\n    abstractMethodFail('isDateBased');\n  };\n  TemporalUnit.prototype.isTimeBased = function isTimeBased() {\n    abstractMethodFail('isTimeBased');\n  };\n  TemporalUnit.prototype.isSupportedBy = function isSupportedBy(temporal) {\n    abstractMethodFail('isSupportedBy');\n  };\n  TemporalUnit.prototype.addTo = function addTo(dateTime, periodToAdd) {\n    abstractMethodFail('addTo');\n  };\n  TemporalUnit.prototype.between = function between(temporal1, temporal2) {\n    abstractMethodFail('between');\n  };\n  return TemporalUnit;\n}();\nfunction _classCallCheck$4(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar Duration = function (_TemporalAmount) {\n  _inherits(Duration, _TemporalAmount);\n  function Duration(seconds, nanos) {\n    _classCallCheck$4(this, Duration);\n    var _this = _possibleConstructorReturn(this, _TemporalAmount.call(this));\n    _this._seconds = MathUtil.safeToInt(seconds);\n    _this._nanos = MathUtil.safeToInt(nanos);\n    return _this;\n  }\n  Duration.ofDays = function ofDays(days) {\n    return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);\n  };\n  Duration.ofHours = function ofHours(hours) {\n    return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);\n  };\n  Duration.ofMinutes = function ofMinutes(minutes) {\n    return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);\n  };\n  Duration.ofSeconds = function ofSeconds(seconds) {\n    var nanoAdjustment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));\n    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n    return Duration._create(secs, nos);\n  };\n  Duration.ofMillis = function ofMillis(millis) {\n    var secs = MathUtil.intDiv(millis, 1000);\n    var mos = MathUtil.intMod(millis, 1000);\n    if (mos < 0) {\n      mos += 1000;\n      secs--;\n    }\n    return Duration._create(secs, mos * 1000000);\n  };\n  Duration.ofNanos = function ofNanos(nanos) {\n    var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);\n    var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);\n    if (nos < 0) {\n      nos += LocalTime.NANOS_PER_SECOND;\n      secs--;\n    }\n    return this._create(secs, nos);\n  };\n  Duration.of = function of(amount, unit) {\n    return Duration.ZERO.plus(amount, unit);\n  };\n  Duration.from = function from(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount);\n    var duration = Duration.ZERO;\n    amount.units().forEach(function (unit) {\n      duration = duration.plus(amount.get(unit), unit);\n    });\n    return duration;\n  };\n  Duration.between = function between(startInclusive, endExclusive) {\n    requireNonNull(startInclusive, 'startInclusive');\n    requireNonNull(endExclusive, 'endExclusive');\n    var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);\n    var nanos = 0;\n    if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {\n      try {\n        var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);\n        nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;\n        if (secs > 0 && nanos < 0) {\n          nanos += LocalTime.NANOS_PER_SECOND;\n        } else if (secs < 0 && nanos > 0) {\n          nanos -= LocalTime.NANOS_PER_SECOND;\n        } else if (secs === 0 && nanos !== 0) {\n          var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);\n          secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);\n        }\n      } catch (e) {}\n    }\n    return this.ofSeconds(secs, nanos);\n  };\n  Duration.parse = function parse(text) {\n    requireNonNull(text, 'text');\n    var PATTERN = new RegExp('([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?', 'i');\n    var matches = PATTERN.exec(text);\n    if (matches !== null) {\n      if ('T' === matches[3] === false) {\n        var negate = '-' === matches[1];\n        var dayMatch = matches[2];\n        var hourMatch = matches[4];\n        var minuteMatch = matches[5];\n        var secondMatch = matches[6];\n        var fractionMatch = matches[7];\n        if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {\n          var daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, 'days');\n          var hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, 'hours');\n          var minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, 'minutes');\n          var seconds = Duration._parseNumber(text, secondMatch, 1, 'seconds');\n          var negativeSecs = secondMatch != null && secondMatch.charAt(0) === '-';\n          var nanos = Duration._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);\n          try {\n            return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);\n          } catch (ex) {\n            throw new DateTimeParseException('Text cannot be parsed to a Duration: overflow', text, 0, ex);\n          }\n        }\n      }\n    }\n    throw new DateTimeParseException('Text cannot be parsed to a Duration', text, 0);\n  };\n  Duration._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {\n    if (parsed == null) {\n      return 0;\n    }\n    try {\n      if (parsed[0] === '+') {\n        parsed = parsed.substring(1);\n      }\n      return MathUtil.safeMultiply(parseFloat(parsed), multiplier);\n    } catch (ex) {\n      throw new DateTimeParseException('Text cannot be parsed to a Duration: ' + errorText, text, 0, ex);\n    }\n  };\n  Duration._parseFraction = function _parseFraction(text, parsed, negate) {\n    if (parsed == null || parsed.length === 0) {\n      return 0;\n    }\n    parsed = (parsed + '000000000').substring(0, 9);\n    return parseFloat(parsed) * negate;\n  };\n  Duration._create = function _create() {\n    if (arguments.length <= 2) {\n      return Duration._createSecondsNanos(arguments[0], arguments[1]);\n    } else {\n      return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n    }\n  };\n  Duration._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {\n    var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));\n    if (negate) {\n      return Duration.ofSeconds(seconds, nanos).negated();\n    }\n    return Duration.ofSeconds(seconds, nanos);\n  };\n  Duration._createSecondsNanos = function _createSecondsNanos() {\n    var seconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var nanoAdjustment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if ((seconds | nanoAdjustment) === 0) {\n      return Duration.ZERO;\n    }\n    return new Duration(seconds, nanoAdjustment);\n  };\n  Duration.prototype.get = function get(unit) {\n    if (unit === ChronoUnit.SECONDS) {\n      return this._seconds;\n    } else if (unit === ChronoUnit.NANOS) {\n      return this._nanos;\n    } else {\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n  };\n  Duration.prototype.units = function units() {\n    return [ChronoUnit.SECONDS, ChronoUnit.NANOS];\n  };\n  Duration.prototype.isZero = function isZero() {\n    return (this._seconds | this._nanos) === 0;\n  };\n  Duration.prototype.isNegative = function isNegative() {\n    return this._seconds < 0;\n  };\n  Duration.prototype.seconds = function seconds() {\n    return this._seconds;\n  };\n  Duration.prototype.nano = function nano() {\n    return this._nanos;\n  };\n  Duration.prototype.withSeconds = function withSeconds(seconds) {\n    return Duration._create(seconds, this._nanos);\n  };\n  Duration.prototype.withNanos = function withNanos(nanoOfSecond) {\n    ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);\n    return Duration._create(this._seconds, nanoOfSecond);\n  };\n  Duration.prototype.plusDuration = function plusDuration(duration) {\n    requireNonNull(duration, 'duration');\n    return this.plus(duration.seconds(), duration.nano());\n  };\n  Duration.prototype.plus = function plus(durationOrNumber, unitOrNumber) {\n    if (arguments.length === 1) {\n      return this.plusDuration(durationOrNumber);\n    } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {\n      return this.plusAmountUnit(durationOrNumber, unitOrNumber);\n    } else {\n      return this.plusSecondsNanos(durationOrNumber, unitOrNumber);\n    }\n  };\n  Duration.prototype.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(amountToAdd, 'amountToAdd');\n    requireNonNull(unit, 'unit');\n    if (unit === ChronoUnit.DAYS) {\n      return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);\n    }\n    if (unit.isDurationEstimated()) {\n      throw new UnsupportedTemporalTypeException('Unit must not have an estimated duration');\n    }\n    if (amountToAdd === 0) {\n      return this;\n    }\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this.plusNanos(amountToAdd);\n        case ChronoUnit.MICROS:\n          return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1000000 * 1000) * 1000, MathUtil.intMod(amountToAdd, 1000000 * 1000) * 1000);\n        case ChronoUnit.MILLIS:\n          return this.plusMillis(amountToAdd);\n        case ChronoUnit.SECONDS:\n          return this.plusSeconds(amountToAdd);\n      }\n      return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);\n    }\n    var duration = unit.duration().multipliedBy(amountToAdd);\n    return this.plusSecondsNanos(duration.seconds(), duration.nano());\n  };\n  Duration.prototype.plusDays = function plusDays(daysToAdd) {\n    return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);\n  };\n  Duration.prototype.plusHours = function plusHours(hoursToAdd) {\n    return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);\n  };\n  Duration.prototype.plusMinutes = function plusMinutes(minutesToAdd) {\n    return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);\n  };\n  Duration.prototype.plusSeconds = function plusSeconds(secondsToAdd) {\n    return this.plusSecondsNanos(secondsToAdd, 0);\n  };\n  Duration.prototype.plusMillis = function plusMillis(millisToAdd) {\n    return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);\n  };\n  Duration.prototype.plusNanos = function plusNanos(nanosToAdd) {\n    return this.plusSecondsNanos(0, nanosToAdd);\n  };\n  Duration.prototype.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {\n    requireNonNull(secondsToAdd, 'secondsToAdd');\n    requireNonNull(nanosToAdd, 'nanosToAdd');\n    if ((secondsToAdd | nanosToAdd) === 0) {\n      return this;\n    }\n    var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);\n    epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));\n    nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n    var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);\n    return Duration.ofSeconds(epochSec, nanoAdjustment);\n  };\n  Duration.prototype.minus = function minus(durationOrNumber, unit) {\n    if (arguments.length === 1) {\n      return this.minusDuration(durationOrNumber);\n    } else {\n      return this.minusAmountUnit(durationOrNumber, unit);\n    }\n  };\n  Duration.prototype.minusDuration = function minusDuration(duration) {\n    requireNonNull(duration, 'duration');\n    var secsToSubtract = duration.seconds();\n    var nanosToSubtract = duration.nano();\n    if (secsToSubtract === MIN_SAFE_INTEGER) {\n      return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);\n    }\n    return this.plus(-secsToSubtract, -nanosToSubtract);\n  };\n  Duration.prototype.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(amountToSubtract, 'amountToSubtract');\n    requireNonNull(unit, 'unit');\n    return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);\n  };\n  Duration.prototype.minusDays = function minusDays(daysToSubtract) {\n    return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);\n  };\n  Duration.prototype.minusHours = function minusHours(hoursToSubtract) {\n    return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);\n  };\n  Duration.prototype.minusMinutes = function minusMinutes(minutesToSubtract) {\n    return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);\n  };\n  Duration.prototype.minusSeconds = function minusSeconds(secondsToSubtract) {\n    return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);\n  };\n  Duration.prototype.minusMillis = function minusMillis(millisToSubtract) {\n    return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);\n  };\n  Duration.prototype.minusNanos = function minusNanos(nanosToSubtract) {\n    return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);\n  };\n  Duration.prototype.multipliedBy = function multipliedBy(multiplicand) {\n    if (multiplicand === 0) {\n      return Duration.ZERO;\n    }\n    if (multiplicand === 1) {\n      return this;\n    }\n    var secs = MathUtil.safeMultiply(this._seconds, multiplicand);\n    var nos = MathUtil.safeMultiply(this._nanos, multiplicand);\n    secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);\n    nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);\n    return Duration.ofSeconds(secs, nos);\n  };\n  Duration.prototype.dividedBy = function dividedBy(divisor) {\n    if (divisor === 0) {\n      throw new ArithmeticException('Cannot divide by zero');\n    }\n    if (divisor === 1) {\n      return this;\n    }\n    var secs = MathUtil.intDiv(this._seconds, divisor);\n    var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);\n    var nos = MathUtil.intDiv(this._nanos, divisor);\n    nos = secsMod + nos;\n    return Duration.ofSeconds(secs, nos);\n  };\n  Duration.prototype.negated = function negated() {\n    return this.multipliedBy(-1);\n  };\n  Duration.prototype.abs = function abs() {\n    return this.isNegative() ? this.negated() : this;\n  };\n  Duration.prototype.addTo = function addTo(temporal) {\n    requireNonNull(temporal, 'temporal');\n    if (this._seconds !== 0) {\n      temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);\n    }\n    if (this._nanos !== 0) {\n      temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);\n    }\n    return temporal;\n  };\n  Duration.prototype.subtractFrom = function subtractFrom(temporal) {\n    requireNonNull(temporal, 'temporal');\n    if (this._seconds !== 0) {\n      temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);\n    }\n    if (this._nanos !== 0) {\n      temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);\n    }\n    return temporal;\n  };\n  Duration.prototype.toDays = function toDays() {\n    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);\n  };\n  Duration.prototype.toHours = function toHours() {\n    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n  };\n  Duration.prototype.toMinutes = function toMinutes() {\n    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n  };\n  Duration.prototype.toMillis = function toMillis() {\n    var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));\n    millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));\n    return millis;\n  };\n  Duration.prototype.toNanos = function toNanos() {\n    var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);\n    totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);\n    return totalNanos;\n  };\n  Duration.prototype.compareTo = function compareTo(otherDuration) {\n    requireNonNull(otherDuration, 'otherDuration');\n    requireInstance(otherDuration, Duration, 'otherDuration');\n    var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());\n    if (cmp !== 0) {\n      return cmp;\n    }\n    return this._nanos - otherDuration.nano();\n  };\n  Duration.prototype.equals = function equals(otherDuration) {\n    if (this === otherDuration) {\n      return true;\n    }\n    if (otherDuration instanceof Duration) {\n      return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();\n    }\n    return false;\n  };\n  Duration.prototype.toString = function toString() {\n    if (this === Duration.ZERO) {\n      return 'PT0S';\n    }\n    var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n    var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);\n    var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n    var rval = 'PT';\n    if (hours !== 0) {\n      rval += hours + 'H';\n    }\n    if (minutes !== 0) {\n      rval += minutes + 'M';\n    }\n    if (secs === 0 && this._nanos === 0 && rval.length > 2) {\n      return rval;\n    }\n    if (secs < 0 && this._nanos > 0) {\n      if (secs === -1) {\n        rval += '-0';\n      } else {\n        rval += secs + 1;\n      }\n    } else {\n      rval += secs;\n    }\n    if (this._nanos > 0) {\n      rval += '.';\n      var nanoString = void 0;\n      if (secs < 0) {\n        nanoString = '' + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);\n      } else {\n        nanoString = '' + (LocalTime.NANOS_PER_SECOND + this._nanos);\n      }\n      nanoString = nanoString.slice(1, nanoString.length);\n      rval += nanoString;\n      while (rval.charAt(rval.length - 1) === '0') {\n        rval = rval.slice(0, rval.length - 1);\n      }\n    }\n    rval += 'S';\n    return rval;\n  };\n  Duration.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  return Duration;\n}(TemporalAmount);\nfunction _init() {\n  Duration.ZERO = new Duration(0, 0);\n}\nfunction _classCallCheck$5(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\n\nvar YearConstants = function YearConstants() {\n  _classCallCheck$5(this, YearConstants);\n};\nfunction _init$1() {\n  YearConstants.MIN_VALUE = -999999;\n  YearConstants.MAX_VALUE = 999999;\n}\nfunction _classCallCheck$6(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$1(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$1(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar ChronoUnit = function (_TemporalUnit) {\n  _inherits$1(ChronoUnit, _TemporalUnit);\n  function ChronoUnit(name, estimatedDuration) {\n    _classCallCheck$6(this, ChronoUnit);\n    var _this = _possibleConstructorReturn$1(this, _TemporalUnit.call(this));\n    _this._name = name;\n    _this._duration = estimatedDuration;\n    return _this;\n  }\n  ChronoUnit.prototype.duration = function duration() {\n    return this._duration;\n  };\n  ChronoUnit.prototype.isDurationEstimated = function isDurationEstimated() {\n    return this.isDateBased() || this === ChronoUnit.FOREVER;\n  };\n  ChronoUnit.prototype.isDateBased = function isDateBased() {\n    return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;\n  };\n  ChronoUnit.prototype.isTimeBased = function isTimeBased() {\n    return this.compareTo(ChronoUnit.DAYS) < 0;\n  };\n  ChronoUnit.prototype.isSupportedBy = function isSupportedBy(temporal) {\n    if (this === ChronoUnit.FOREVER) {\n      return false;\n    }\n    try {\n      temporal.plus(1, this);\n      return true;\n    } catch (e) {\n      try {\n        temporal.plus(-1, this);\n        return true;\n      } catch (e2) {\n        return false;\n      }\n    }\n  };\n  ChronoUnit.prototype.addTo = function addTo(temporal, amount) {\n    return temporal.plus(amount, this);\n  };\n  ChronoUnit.prototype.between = function between(temporal1, temporal2) {\n    return temporal1.until(temporal2, this);\n  };\n  ChronoUnit.prototype.toString = function toString() {\n    return this._name;\n  };\n  ChronoUnit.prototype.compareTo = function compareTo(other) {\n    return this.duration().compareTo(other.duration());\n  };\n  return ChronoUnit;\n}(TemporalUnit);\nfunction _init$2() {\n  ChronoUnit.NANOS = new ChronoUnit('Nanos', Duration.ofNanos(1));\n  ChronoUnit.MICROS = new ChronoUnit('Micros', Duration.ofNanos(1000));\n  ChronoUnit.MILLIS = new ChronoUnit('Millis', Duration.ofNanos(1000000));\n  ChronoUnit.SECONDS = new ChronoUnit('Seconds', Duration.ofSeconds(1));\n  ChronoUnit.MINUTES = new ChronoUnit('Minutes', Duration.ofSeconds(60));\n  ChronoUnit.HOURS = new ChronoUnit('Hours', Duration.ofSeconds(3600));\n  ChronoUnit.HALF_DAYS = new ChronoUnit('HalfDays', Duration.ofSeconds(43200));\n  ChronoUnit.DAYS = new ChronoUnit('Days', Duration.ofSeconds(86400));\n  ChronoUnit.WEEKS = new ChronoUnit('Weeks', Duration.ofSeconds(7 * 86400));\n  ChronoUnit.MONTHS = new ChronoUnit('Months', Duration.ofSeconds(31556952 / 12));\n  ChronoUnit.YEARS = new ChronoUnit('Years', Duration.ofSeconds(31556952));\n  ChronoUnit.DECADES = new ChronoUnit('Decades', Duration.ofSeconds(31556952 * 10));\n  ChronoUnit.CENTURIES = new ChronoUnit('Centuries', Duration.ofSeconds(31556952 * 100));\n  ChronoUnit.MILLENNIA = new ChronoUnit('Millennia', Duration.ofSeconds(31556952 * 1000));\n  ChronoUnit.ERAS = new ChronoUnit('Eras', Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));\n  ChronoUnit.FOREVER = new ChronoUnit('Forever', Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));\n}\nfunction _classCallCheck$7(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar TemporalField = function TemporalField() {\n  _classCallCheck$7(this, TemporalField);\n};\nfunction _classCallCheck$8(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar ValueRange = function () {\n  function ValueRange(minSmallest, minLargest, maxSmallest, maxLargest) {\n    _classCallCheck$8(this, ValueRange);\n    assert(!(minSmallest > minLargest), 'Smallest minimum value \\'' + minSmallest + '\\' must be less than largest minimum value \\'' + minLargest + '\\'', IllegalArgumentException);\n    assert(!(maxSmallest > maxLargest), 'Smallest maximum value \\'' + maxSmallest + '\\' must be less than largest maximum value \\'' + maxLargest + '\\'', IllegalArgumentException);\n    assert(!(minLargest > maxLargest), 'Minimum value \\'' + minLargest + '\\' must be less than maximum value \\'' + maxLargest + '\\'', IllegalArgumentException);\n    this._minSmallest = minSmallest;\n    this._minLargest = minLargest;\n    this._maxLargest = maxLargest;\n    this._maxSmallest = maxSmallest;\n  }\n  ValueRange.prototype.isFixed = function isFixed() {\n    return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;\n  };\n  ValueRange.prototype.minimum = function minimum() {\n    return this._minSmallest;\n  };\n  ValueRange.prototype.largestMinimum = function largestMinimum() {\n    return this._minLargest;\n  };\n  ValueRange.prototype.maximum = function maximum() {\n    return this._maxLargest;\n  };\n  ValueRange.prototype.smallestMaximum = function smallestMaximum() {\n    return this._maxSmallest;\n  };\n  ValueRange.prototype.isValidValue = function isValidValue(value) {\n    return this.minimum() <= value && value <= this.maximum();\n  };\n  ValueRange.prototype.checkValidValue = function checkValidValue(value, field) {\n    var msg = void 0;\n    if (!this.isValidValue(value)) {\n      if (field != null) {\n        msg = 'Invalid value for ' + field + ' (valid values ' + this.toString() + '): ' + value;\n      } else {\n        msg = 'Invalid value (valid values ' + this.toString() + '): ' + value;\n      }\n      return assert(false, msg, DateTimeException);\n    }\n  };\n  ValueRange.prototype.checkValidIntValue = function checkValidIntValue(value, field) {\n    if (this.isValidIntValue(value) === false) {\n      throw new DateTimeException('Invalid int value for ' + field + ': ' + value);\n    }\n    return value;\n  };\n  ValueRange.prototype.isValidIntValue = function isValidIntValue(value) {\n    return this.isIntValue() && this.isValidValue(value);\n  };\n  ValueRange.prototype.isIntValue = function isIntValue() {\n    return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;\n  };\n  ValueRange.prototype.equals = function equals(other) {\n    if (other === this) {\n      return true;\n    }\n    if (other instanceof ValueRange) {\n      return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;\n    }\n    return false;\n  };\n  ValueRange.prototype.hashCode = function hashCode() {\n    return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);\n  };\n  ValueRange.prototype.toString = function toString() {\n    var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? '/' + this.largestMinimum() : '');\n    str += ' - ';\n    str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? '/' + this.maximum() : '');\n    return str;\n  };\n  ValueRange.of = function of() {\n    if (arguments.length === 2) {\n      return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[1]);\n    } else if (arguments.length === 3) {\n      return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[2]);\n    } else if (arguments.length === 4) {\n      return new ValueRange(arguments[0], arguments[1], arguments[2], arguments[3]);\n    } else {\n      return assert(false, 'Invalid number of arguments ' + arguments.length, IllegalArgumentException);\n    }\n  };\n  return ValueRange;\n}();\nfunction _classCallCheck$9(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$2(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$2(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar ChronoField = function (_TemporalField) {\n  _inherits$2(ChronoField, _TemporalField);\n  ChronoField.byName = function byName(fieldName) {\n    for (var prop in ChronoField) {\n      if (ChronoField.hasOwnProperty(prop)) {\n        if (ChronoField[prop] instanceof ChronoField && ChronoField[prop].name() === fieldName) {\n          return ChronoField[prop];\n        }\n      }\n    }\n  };\n  function ChronoField(name, baseUnit, rangeUnit, range) {\n    _classCallCheck$9(this, ChronoField);\n    var _this = _possibleConstructorReturn$2(this, _TemporalField.call(this));\n    _this._name = name;\n    _this._baseUnit = baseUnit;\n    _this._rangeUnit = rangeUnit;\n    _this._range = range;\n    return _this;\n  }\n  ChronoField.prototype.name = function name() {\n    return this._name;\n  };\n  ChronoField.prototype.baseUnit = function baseUnit() {\n    return this._baseUnit;\n  };\n  ChronoField.prototype.rangeUnit = function rangeUnit() {\n    return this._rangeUnit;\n  };\n  ChronoField.prototype.range = function range() {\n    return this._range;\n  };\n  ChronoField.prototype.displayName = function displayName() {\n    return this.toString();\n  };\n  ChronoField.prototype.checkValidValue = function checkValidValue(value) {\n    return this.range().checkValidValue(value, this.name());\n  };\n  ChronoField.prototype.isDateBased = function isDateBased() {\n    var dateBased = this === ChronoField.DAY_OF_WEEK || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField.DAY_OF_MONTH || this === ChronoField.DAY_OF_YEAR || this === ChronoField.EPOCH_DAY || this === ChronoField.ALIGNED_WEEK_OF_MONTH || this === ChronoField.ALIGNED_WEEK_OF_YEAR || this === ChronoField.MONTH_OF_YEAR || this === ChronoField.YEAR_OF_ERA || this === ChronoField.YEAR || this === ChronoField.ERA;\n    return dateBased;\n  };\n  ChronoField.prototype.isTimeBased = function isTimeBased() {\n    var timeBased = this === ChronoField.NANO_OF_SECOND || this === ChronoField.NANO_OF_DAY || this === ChronoField.MICRO_OF_SECOND || this === ChronoField.MICRO_OF_DAY || this === ChronoField.MILLI_OF_SECOND || this === ChronoField.MILLI_OF_DAY || this === ChronoField.SECOND_OF_MINUTE || this === ChronoField.SECOND_OF_DAY || this === ChronoField.MINUTE_OF_HOUR || this === ChronoField.MINUTE_OF_DAY || this === ChronoField.HOUR_OF_AMPM || this === ChronoField.CLOCK_HOUR_OF_AMPM || this === ChronoField.HOUR_OF_DAY || this === ChronoField.CLOCK_HOUR_OF_DAY || this === ChronoField.AMPM_OF_DAY;\n    return timeBased;\n  };\n  ChronoField.prototype.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    return temporal.range(this);\n  };\n  ChronoField.prototype.checkValidIntValue = function checkValidIntValue(value) {\n    return this.range().checkValidIntValue(value, this);\n  };\n  ChronoField.prototype.getFrom = function getFrom(temporal) {\n    return temporal.getLong(this);\n  };\n  ChronoField.prototype.toString = function toString() {\n    return this.name();\n  };\n  ChronoField.prototype.equals = function equals(other) {\n    return this === other;\n  };\n  return ChronoField;\n}(TemporalField);\nfunction _init$3() {\n  ChronoField.NANO_OF_SECOND = new ChronoField('NanoOfSecond', ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));\n  ChronoField.NANO_OF_DAY = new ChronoField('NanoOfDay', ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000000 - 1));\n  ChronoField.MICRO_OF_SECOND = new ChronoField('MicroOfSecond', ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));\n  ChronoField.MICRO_OF_DAY = new ChronoField('MicroOfDay', ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000 - 1));\n  ChronoField.MILLI_OF_SECOND = new ChronoField('MilliOfSecond', ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));\n  ChronoField.MILLI_OF_DAY = new ChronoField('MilliOfDay', ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000 - 1));\n  ChronoField.SECOND_OF_MINUTE = new ChronoField('SecondOfMinute', ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));\n  ChronoField.SECOND_OF_DAY = new ChronoField('SecondOfDay', ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));\n  ChronoField.MINUTE_OF_HOUR = new ChronoField('MinuteOfHour', ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));\n  ChronoField.MINUTE_OF_DAY = new ChronoField('MinuteOfDay', ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));\n  ChronoField.HOUR_OF_AMPM = new ChronoField('HourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));\n  ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField('ClockHourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));\n  ChronoField.HOUR_OF_DAY = new ChronoField('HourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));\n  ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField('ClockHourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));\n  ChronoField.AMPM_OF_DAY = new ChronoField('AmPmOfDay', ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));\n  ChronoField.DAY_OF_WEEK = new ChronoField('DayOfWeek', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n  ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField('AlignedDayOfWeekInMonth', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n  ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField('AlignedDayOfWeekInYear', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n  ChronoField.DAY_OF_MONTH = new ChronoField('DayOfMonth', ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), 'day');\n  ChronoField.DAY_OF_YEAR = new ChronoField('DayOfYear', ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));\n  ChronoField.EPOCH_DAY = new ChronoField('EpochDay', ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(Math.floor(YearConstants.MIN_VALUE * 365.25), Math.floor(YearConstants.MAX_VALUE * 365.25)));\n  ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField('AlignedWeekOfMonth', ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));\n  ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField('AlignedWeekOfYear', ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));\n  ChronoField.MONTH_OF_YEAR = new ChronoField('MonthOfYear', ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), 'month');\n  ChronoField.PROLEPTIC_MONTH = new ChronoField('ProlepticMonth', ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));\n  ChronoField.YEAR_OF_ERA = new ChronoField('YearOfEra', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));\n  ChronoField.YEAR = new ChronoField('Year', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), 'year');\n  ChronoField.ERA = new ChronoField('Era', ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));\n  ChronoField.INSTANT_SECONDS = new ChronoField('InstantSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));\n  ChronoField.OFFSET_SECONDS = new ChronoField('OffsetSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));\n}\nfunction _classCallCheck$a(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar TemporalQueries = function () {\n  function TemporalQueries() {\n    _classCallCheck$a(this, TemporalQueries);\n  }\n  TemporalQueries.zoneId = function zoneId() {\n    return TemporalQueries.ZONE_ID;\n  };\n  TemporalQueries.chronology = function chronology() {\n    return TemporalQueries.CHRONO;\n  };\n  TemporalQueries.precision = function precision() {\n    return TemporalQueries.PRECISION;\n  };\n  TemporalQueries.zone = function zone() {\n    return TemporalQueries.ZONE;\n  };\n  TemporalQueries.offset = function offset() {\n    return TemporalQueries.OFFSET;\n  };\n  TemporalQueries.localDate = function localDate() {\n    return TemporalQueries.LOCAL_DATE;\n  };\n  TemporalQueries.localTime = function localTime() {\n    return TemporalQueries.LOCAL_TIME;\n  };\n  return TemporalQueries;\n}();\nfunction _classCallCheck$b(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar TemporalAccessor = function () {\n  function TemporalAccessor() {\n    _classCallCheck$b(this, TemporalAccessor);\n  }\n  TemporalAccessor.prototype.query = function query(_query) {\n    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {\n      return null;\n    }\n    return _query.queryFrom(this);\n  };\n  TemporalAccessor.prototype.get = function get(field) {\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n  TemporalAccessor.prototype.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (this.isSupported(field)) {\n        return field.range();\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.rangeRefinedBy(this);\n  };\n  return TemporalAccessor;\n}();\nfunction _classCallCheck$c(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$3(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$3(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar Temporal = function (_TemporalAccessor) {\n  _inherits$3(Temporal, _TemporalAccessor);\n  function Temporal() {\n    _classCallCheck$c(this, Temporal);\n    return _possibleConstructorReturn$3(this, _TemporalAccessor.apply(this, arguments));\n  }\n  return Temporal;\n}(TemporalAccessor);\nfunction _classCallCheck$d(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$4(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$4(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar TemporalQuery = function (_Enum) {\n  _inherits$4(TemporalQuery, _Enum);\n  function TemporalQuery() {\n    _classCallCheck$d(this, TemporalQuery);\n    return _possibleConstructorReturn$4(this, _Enum.apply(this, arguments));\n  }\n  TemporalQuery.prototype.queryFrom = function queryFrom(temporal) {\n    abstractMethodFail('queryFrom');\n  };\n  return TemporalQuery;\n}(Enum);\nfunction createTemporalQuery(name, queryFromFunction) {\n  var ExtendedTemporalQuery = function (_TemporalQuery) {\n    _inherits$4(ExtendedTemporalQuery, _TemporalQuery);\n    function ExtendedTemporalQuery() {\n      _classCallCheck$d(this, ExtendedTemporalQuery);\n      return _possibleConstructorReturn$4(this, _TemporalQuery.apply(this, arguments));\n    }\n    return ExtendedTemporalQuery;\n  }(TemporalQuery);\n  ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;\n  return new ExtendedTemporalQuery(name);\n}\nfunction _classCallCheck$e(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$5(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$5(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar DayOfWeek = function (_Temporal) {\n  _inherits$5(DayOfWeek, _Temporal);\n  function DayOfWeek(ordinal, name) {\n    _classCallCheck$e(this, DayOfWeek);\n    var _this = _possibleConstructorReturn$5(this, _Temporal.call(this));\n    _this._ordinal = ordinal;\n    _this._name = name;\n    return _this;\n  }\n  DayOfWeek.prototype.ordinal = function ordinal() {\n    return this._ordinal;\n  };\n  DayOfWeek.prototype.name = function name() {\n    return this._name;\n  };\n  DayOfWeek.values = function values() {\n    return ENUMS.slice();\n  };\n  DayOfWeek.valueOf = function valueOf(name) {\n    var ordinal = 0;\n    for (ordinal; ordinal < ENUMS.length; ordinal++) {\n      if (ENUMS[ordinal].name() === name) {\n        break;\n      }\n    }\n    return DayOfWeek.of(ordinal + 1);\n  };\n  DayOfWeek.of = function of(dayOfWeek) {\n    if (dayOfWeek < 1 || dayOfWeek > 7) {\n      throw new DateTimeException('Invalid value for DayOfWeek: ' + dayOfWeek);\n    }\n    return ENUMS[dayOfWeek - 1];\n  };\n  DayOfWeek.from = function from(temporal) {\n    assert(temporal != null, 'temporal', NullPointerException);\n    if (temporal instanceof DayOfWeek) {\n      return temporal;\n    }\n    try {\n      return DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));\n    } catch (ex) {\n      if (ex instanceof DateTimeException) {\n        throw new DateTimeException('Unable to obtain DayOfWeek from TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''), ex);\n      } else {\n        throw ex;\n      }\n    }\n  };\n  DayOfWeek.prototype.value = function value() {\n    return this._ordinal + 1;\n  };\n  DayOfWeek.prototype.getDisplayName = function getDisplayName(style, locale) {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n  };\n  DayOfWeek.prototype.isSupported = function isSupported(field) {\n    if (field instanceof ChronoField) {\n      return field === ChronoField.DAY_OF_WEEK;\n    }\n    return field != null && field.isSupportedBy(this);\n  };\n  DayOfWeek.prototype.range = function range(field) {\n    if (field === ChronoField.DAY_OF_WEEK) {\n      return field.range();\n    } else if (field instanceof ChronoField) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.rangeRefinedBy(this);\n  };\n  DayOfWeek.prototype.get = function get(field) {\n    if (field === ChronoField.DAY_OF_WEEK) {\n      return this.value();\n    }\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n  DayOfWeek.prototype.getLong = function getLong(field) {\n    if (field === ChronoField.DAY_OF_WEEK) {\n      return this.value();\n    } else if (field instanceof ChronoField) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.getFrom(this);\n  };\n  DayOfWeek.prototype.plus = function plus(days) {\n    var amount = MathUtil.floorMod(days, 7);\n    return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];\n  };\n  DayOfWeek.prototype.minus = function minus(days) {\n    return this.plus(-1 * MathUtil.floorMod(days, 7));\n  };\n  DayOfWeek.prototype.query = function query(_query) {\n    if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.DAYS;\n    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n    assert(_query != null, 'query', NullPointerException);\n    return _query.queryFrom(this);\n  };\n  DayOfWeek.prototype.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    return temporal.with(ChronoField.DAY_OF_WEEK, this.value());\n  };\n  DayOfWeek.prototype.equals = function equals(other) {\n    return this === other;\n  };\n  DayOfWeek.prototype.toString = function toString() {\n    return this._name;\n  };\n  DayOfWeek.prototype.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, DayOfWeek, 'other');\n    return this._ordinal - other._ordinal;\n  };\n  DayOfWeek.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  return DayOfWeek;\n}(Temporal);\nvar ENUMS = void 0;\nfunction _init$4() {\n  DayOfWeek.MONDAY = new DayOfWeek(0, 'MONDAY');\n  DayOfWeek.TUESDAY = new DayOfWeek(1, 'TUESDAY');\n  DayOfWeek.WEDNESDAY = new DayOfWeek(2, 'WEDNESDAY');\n  DayOfWeek.THURSDAY = new DayOfWeek(3, 'THURSDAY');\n  DayOfWeek.FRIDAY = new DayOfWeek(4, 'FRIDAY');\n  DayOfWeek.SATURDAY = new DayOfWeek(5, 'SATURDAY');\n  DayOfWeek.SUNDAY = new DayOfWeek(6, 'SUNDAY');\n  DayOfWeek.FROM = createTemporalQuery('DayOfWeek.FROM', function (temporal) {\n    return DayOfWeek.from(temporal);\n  });\n  ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];\n}\nfunction _classCallCheck$f(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$6(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$6(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar Month = function (_Temporal) {\n  _inherits$6(Month, _Temporal);\n  function Month(value, name) {\n    _classCallCheck$f(this, Month);\n    var _this = _possibleConstructorReturn$6(this, _Temporal.call(this));\n    _this._value = MathUtil.safeToInt(value);\n    _this._name = name;\n    return _this;\n  }\n  Month.prototype.value = function value() {\n    return this._value;\n  };\n  Month.prototype.ordinal = function ordinal() {\n    return this._value - 1;\n  };\n  Month.prototype.name = function name() {\n    return this._name;\n  };\n  Month.prototype.getDisplayName = function getDisplayName(style, locale) {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n  };\n  Month.prototype.isSupported = function isSupported(field) {\n    if (null === field) {\n      return false;\n    }\n    if (field instanceof ChronoField) {\n      return field === ChronoField.MONTH_OF_YEAR;\n    }\n    return field != null && field.isSupportedBy(this);\n  };\n  Month.prototype.get = function get(field) {\n    if (field === ChronoField.MONTH_OF_YEAR) {\n      return this.value();\n    }\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n  Month.prototype.getLong = function getLong(field) {\n    if (field === ChronoField.MONTH_OF_YEAR) {\n      return this.value();\n    } else if (field instanceof ChronoField) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.getFrom(this);\n  };\n  Month.prototype.plus = function plus(months) {\n    var amount = MathUtil.intMod(months, 12) + 12;\n    var newMonthVal = MathUtil.intMod(this.value() + amount, 12);\n    newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;\n    return Month.of(newMonthVal);\n  };\n  Month.prototype.minus = function minus(months) {\n    return this.plus(-1 * MathUtil.intMod(months, 12));\n  };\n  Month.prototype.length = function length(leapYear) {\n    switch (this) {\n      case Month.FEBRUARY:\n        return leapYear ? 29 : 28;\n      case Month.APRIL:\n      case Month.JUNE:\n      case Month.SEPTEMBER:\n      case Month.NOVEMBER:\n        return 30;\n      default:\n        return 31;\n    }\n  };\n  Month.prototype.minLength = function minLength() {\n    switch (this) {\n      case Month.FEBRUARY:\n        return 28;\n      case Month.APRIL:\n      case Month.JUNE:\n      case Month.SEPTEMBER:\n      case Month.NOVEMBER:\n        return 30;\n      default:\n        return 31;\n    }\n  };\n  Month.prototype.maxLength = function maxLength() {\n    switch (this) {\n      case Month.FEBRUARY:\n        return 29;\n      case Month.APRIL:\n      case Month.JUNE:\n      case Month.SEPTEMBER:\n      case Month.NOVEMBER:\n        return 30;\n      default:\n        return 31;\n    }\n  };\n  Month.prototype.firstDayOfYear = function firstDayOfYear(leapYear) {\n    var leap = leapYear ? 1 : 0;\n    switch (this) {\n      case Month.JANUARY:\n        return 1;\n      case Month.FEBRUARY:\n        return 32;\n      case Month.MARCH:\n        return 60 + leap;\n      case Month.APRIL:\n        return 91 + leap;\n      case Month.MAY:\n        return 121 + leap;\n      case Month.JUNE:\n        return 152 + leap;\n      case Month.JULY:\n        return 182 + leap;\n      case Month.AUGUST:\n        return 213 + leap;\n      case Month.SEPTEMBER:\n        return 244 + leap;\n      case Month.OCTOBER:\n        return 274 + leap;\n      case Month.NOVEMBER:\n        return 305 + leap;\n      case Month.DECEMBER:\n      default:\n        return 335 + leap;\n    }\n  };\n  Month.prototype.firstMonthOfQuarter = function firstMonthOfQuarter() {\n    switch (this) {\n      case Month.JANUARY:\n      case Month.FEBRUARY:\n      case Month.MARCH:\n        return Month.JANUARY;\n      case Month.APRIL:\n      case Month.MAY:\n      case Month.JUNE:\n        return Month.APRIL;\n      case Month.JULY:\n      case Month.AUGUST:\n      case Month.SEPTEMBER:\n        return Month.JULY;\n      case Month.OCTOBER:\n      case Month.NOVEMBER:\n      case Month.DECEMBER:\n      default:\n        return Month.OCTOBER;\n    }\n  };\n  Month.prototype.query = function query(_query) {\n    assert(_query != null, 'query() parameter must not be null', DateTimeException);\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.MONTHS;\n    }\n    return _Temporal.prototype.query.call(this, _query);\n  };\n  Month.prototype.toString = function toString() {\n    switch (this) {\n      case Month.JANUARY:\n        return 'JANUARY';\n      case Month.FEBRUARY:\n        return 'FEBRUARY';\n      case Month.MARCH:\n        return 'MARCH';\n      case Month.APRIL:\n        return 'APRIL';\n      case Month.MAY:\n        return 'MAY';\n      case Month.JUNE:\n        return 'JUNE';\n      case Month.JULY:\n        return 'JULY';\n      case Month.AUGUST:\n        return 'AUGUST';\n      case Month.SEPTEMBER:\n        return 'SEPTEMBER';\n      case Month.OCTOBER:\n        return 'OCTOBER';\n      case Month.NOVEMBER:\n        return 'NOVEMBER';\n      case Month.DECEMBER:\n        return 'DECEMBER';\n      default:\n        return 'unknown Month, value: ' + this.value();\n    }\n  };\n  Month.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  Month.prototype.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());\n  };\n  Month.prototype.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, Month, 'other');\n    return this._value - other._value;\n  };\n  Month.prototype.equals = function equals(other) {\n    return this === other;\n  };\n  Month.valueOf = function valueOf(name) {\n    var ordinal = 0;\n    for (ordinal; ordinal < MONTHS.length; ordinal++) {\n      if (MONTHS[ordinal].name() === name) {\n        break;\n      }\n    }\n    return Month.of(ordinal + 1);\n  };\n  Month.values = function values() {\n    return MONTHS.slice();\n  };\n  Month.of = function of(month) {\n    if (month < 1 || month > 12) {\n      assert(false, 'Invalid value for MonthOfYear: ' + month, DateTimeException);\n    }\n    return MONTHS[month - 1];\n  };\n  Month.from = function from(temporal) {\n    if (temporal instanceof Month) {\n      return temporal;\n    }\n    try {\n      return Month.of(temporal.get(ChronoField.MONTH_OF_YEAR));\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain Month from TemporalAccessor: ' + temporal + ' of type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''), ex);\n    }\n  };\n  return Month;\n}(Temporal);\nvar MONTHS = void 0;\nfunction _init$5() {\n  Month.JANUARY = new Month(1, 'JANUARY');\n  Month.FEBRUARY = new Month(2, 'FEBRUARY');\n  Month.MARCH = new Month(3, 'MARCH');\n  Month.APRIL = new Month(4, 'APRIL');\n  Month.MAY = new Month(5, 'MAY');\n  Month.JUNE = new Month(6, 'JUNE');\n  Month.JULY = new Month(7, 'JULY');\n  Month.AUGUST = new Month(8, 'AUGUST');\n  Month.SEPTEMBER = new Month(9, 'SEPTEMBER');\n  Month.OCTOBER = new Month(10, 'OCTOBER');\n  Month.NOVEMBER = new Month(11, 'NOVEMBER');\n  Month.DECEMBER = new Month(12, 'DECEMBER');\n  MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];\n}\nfunction _classCallCheck$g(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$7(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$7(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;\nvar Period = function (_TemporalAmount) {\n  _inherits$7(Period, _TemporalAmount);\n  function Period(years, months, days) {\n    _classCallCheck$g(this, Period);\n    var _this = _possibleConstructorReturn$7(this, _TemporalAmount.call(this));\n    var _years = MathUtil.safeToInt(years);\n    var _months = MathUtil.safeToInt(months);\n    var _days = MathUtil.safeToInt(days);\n    if ((_years | _months | _days) === 0) {\n      var _ret;\n      if (!Period.ZERO) {\n        _this._years = _years;\n        _this._months = _months;\n        _this._days = _days;\n        Period.ZERO = _this;\n      }\n      return _ret = Period.ZERO, _possibleConstructorReturn$7(_this, _ret);\n    }\n    _this._years = _years;\n    _this._months = _months;\n    _this._days = _days;\n    return _this;\n  }\n  Period.ofYears = function ofYears(years) {\n    return Period.create(years, 0, 0);\n  };\n  Period.ofMonths = function ofMonths(months) {\n    return Period.create(0, months, 0);\n  };\n  Period.ofWeeks = function ofWeeks(weeks) {\n    return Period.create(0, 0, MathUtil.safeMultiply(weeks, 7));\n  };\n  Period.ofDays = function ofDays(days) {\n    return Period.create(0, 0, days);\n  };\n  Period.of = function of(years, months, days) {\n    return Period.create(years, months, days);\n  };\n  Period.from = function from(amount) {\n    if (amount instanceof Period) {\n      return amount;\n    }\n    requireNonNull(amount, 'amount');\n    var years = 0;\n    var months = 0;\n    var days = 0;\n    var units = amount.units();\n    for (var i = 0; i < units.length; i++) {\n      var unit = units[i];\n      var unitAmount = amount.get(unit);\n      if (unit === ChronoUnit.YEARS) {\n        years = MathUtil.safeToInt(unitAmount);\n      } else if (unit === ChronoUnit.MONTHS) {\n        months = MathUtil.safeToInt(unitAmount);\n      } else if (unit === ChronoUnit.DAYS) {\n        days = MathUtil.safeToInt(unitAmount);\n      } else {\n        throw new DateTimeException('Unit must be Years, Months or Days, but was ' + unit);\n      }\n    }\n    return Period.create(years, months, days);\n  };\n  Period.between = function between(startDate, endDate) {\n    requireNonNull(startDate, 'startDate');\n    requireNonNull(endDate, 'endDate');\n    requireInstance(startDate, LocalDate, 'startDate');\n    requireInstance(endDate, LocalDate, 'endDate');\n    return startDate.until(endDate);\n  };\n  Period.parse = function parse(text) {\n    requireNonNull(text, 'text');\n    try {\n      return Period._parse(text);\n    } catch (ex) {\n      if (ex instanceof ArithmeticException) {\n        throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0, ex);\n      } else {\n        throw ex;\n      }\n    }\n  };\n  Period._parse = function _parse(text) {\n    var matches = PATTERN.exec(text);\n    if (matches != null) {\n      var negate = '-' === matches[1] ? -1 : 1;\n      var yearMatch = matches[2];\n      var monthMatch = matches[3];\n      var weekMatch = matches[4];\n      var dayMatch = matches[5];\n      if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {\n        var years = Period._parseNumber(text, yearMatch, negate);\n        var months = Period._parseNumber(text, monthMatch, negate);\n        var weeks = Period._parseNumber(text, weekMatch, negate);\n        var days = Period._parseNumber(text, dayMatch, negate);\n        days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));\n        return Period.create(years, months, days);\n      }\n    }\n    throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0);\n  };\n  Period._parseNumber = function _parseNumber(text, str, negate) {\n    if (str == null) {\n      return 0;\n    }\n    var val = MathUtil.parseInt(str);\n    return MathUtil.safeMultiply(val, negate);\n  };\n  Period.create = function create(years, months, days) {\n    return new Period(years, months, days);\n  };\n  Period.prototype.units = function units() {\n    return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];\n  };\n  Period.prototype.chronology = function chronology() {\n    return IsoChronology.INSTANCE;\n  };\n  Period.prototype.get = function get(unit) {\n    if (unit === ChronoUnit.YEARS) {\n      return this._years;\n    }\n    if (unit === ChronoUnit.MONTHS) {\n      return this._months;\n    }\n    if (unit === ChronoUnit.DAYS) {\n      return this._days;\n    }\n    throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n  };\n  Period.prototype.isZero = function isZero() {\n    return this === Period.ZERO;\n  };\n  Period.prototype.isNegative = function isNegative() {\n    return this._years < 0 || this._months < 0 || this._days < 0;\n  };\n  Period.prototype.years = function years() {\n    return this._years;\n  };\n  Period.prototype.months = function months() {\n    return this._months;\n  };\n  Period.prototype.days = function days() {\n    return this._days;\n  };\n  Period.prototype.withYears = function withYears(years) {\n    if (years === this._years) {\n      return this;\n    }\n    return Period.create(years, this._months, this._days);\n  };\n  Period.prototype.withMonths = function withMonths(months) {\n    if (months === this._months) {\n      return this;\n    }\n    return Period.create(this._years, months, this._days);\n  };\n  Period.prototype.withDays = function withDays(days) {\n    if (days === this._days) {\n      return this;\n    }\n    return Period.create(this._years, this._months, days);\n  };\n  Period.prototype.plus = function plus(amountToAdd) {\n    var amount = Period.from(amountToAdd);\n    return Period.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));\n  };\n  Period.prototype.plusYears = function plusYears(yearsToAdd) {\n    if (yearsToAdd === 0) {\n      return this;\n    }\n    return Period.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);\n  };\n  Period.prototype.plusMonths = function plusMonths(monthsToAdd) {\n    if (monthsToAdd === 0) {\n      return this;\n    }\n    return Period.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);\n  };\n  Period.prototype.plusDays = function plusDays(daysToAdd) {\n    if (daysToAdd === 0) {\n      return this;\n    }\n    return Period.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));\n  };\n  Period.prototype.minus = function minus(amountToSubtract) {\n    var amount = Period.from(amountToSubtract);\n    return Period.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));\n  };\n  Period.prototype.minusYears = function minusYears(yearsToSubtract) {\n    return this.plusYears(-1 * yearsToSubtract);\n  };\n  Period.prototype.minusMonths = function minusMonths(monthsToSubtract) {\n    return this.plusMonths(-1 * monthsToSubtract);\n  };\n  Period.prototype.minusDays = function minusDays(daysToSubtract) {\n    return this.plusDays(-1 * daysToSubtract);\n  };\n  Period.prototype.multipliedBy = function multipliedBy(scalar) {\n    if (this === Period.ZERO || scalar === 1) {\n      return this;\n    }\n    return Period.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));\n  };\n  Period.prototype.negated = function negated() {\n    return this.multipliedBy(-1);\n  };\n  Period.prototype.normalized = function normalized() {\n    var totalMonths = this.toTotalMonths();\n    var splitYears = MathUtil.intDiv(totalMonths, 12);\n    var splitMonths = MathUtil.intMod(totalMonths, 12);\n    if (splitYears === this._years && splitMonths === this._months) {\n      return this;\n    }\n    return Period.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);\n  };\n  Period.prototype.toTotalMonths = function toTotalMonths() {\n    return this._years * 12 + this._months;\n  };\n  Period.prototype.addTo = function addTo(temporal) {\n    requireNonNull(temporal, 'temporal');\n    if (this._years !== 0) {\n      if (this._months !== 0) {\n        temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);\n      } else {\n        temporal = temporal.plus(this._years, ChronoUnit.YEARS);\n      }\n    } else if (this._months !== 0) {\n      temporal = temporal.plus(this._months, ChronoUnit.MONTHS);\n    }\n    if (this._days !== 0) {\n      temporal = temporal.plus(this._days, ChronoUnit.DAYS);\n    }\n    return temporal;\n  };\n  Period.prototype.subtractFrom = function subtractFrom(temporal) {\n    requireNonNull(temporal, 'temporal');\n    if (this._years !== 0) {\n      if (this._months !== 0) {\n        temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);\n      } else {\n        temporal = temporal.minus(this._years, ChronoUnit.YEARS);\n      }\n    } else if (this._months !== 0) {\n      temporal = temporal.minus(this._months, ChronoUnit.MONTHS);\n    }\n    if (this._days !== 0) {\n      temporal = temporal.minus(this._days, ChronoUnit.DAYS);\n    }\n    return temporal;\n  };\n  Period.prototype.equals = function equals(obj) {\n    if (this === obj) {\n      return true;\n    }\n    if (obj instanceof Period) {\n      var other = obj;\n      return this._years === other._years && this._months === other._months && this._days === other._days;\n    }\n    return false;\n  };\n  Period.prototype.hashCode = function hashCode() {\n    return MathUtil.hashCode(this._years, this._months, this._days);\n  };\n  Period.prototype.toString = function toString() {\n    if (this === Period.ZERO) {\n      return 'P0D';\n    } else {\n      var buf = 'P';\n      if (this._years !== 0) {\n        buf += '' + this._years + 'Y';\n      }\n      if (this._months !== 0) {\n        buf += '' + this._months + 'M';\n      }\n      if (this._days !== 0) {\n        buf += '' + this._days + 'D';\n      }\n      return buf;\n    }\n  };\n  Period.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  return Period;\n}(TemporalAmount);\nfunction _init$6() {\n  Period.ofDays(0);\n}\nfunction _classCallCheck$h(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar ParsePosition = function () {\n  function ParsePosition(index) {\n    _classCallCheck$h(this, ParsePosition);\n    this._index = index;\n    this._errorIndex = -1;\n  }\n  ParsePosition.prototype.getIndex = function getIndex() {\n    return this._index;\n  };\n  ParsePosition.prototype.setIndex = function setIndex(index) {\n    this._index = index;\n  };\n  ParsePosition.prototype.getErrorIndex = function getErrorIndex() {\n    return this._errorIndex;\n  };\n  ParsePosition.prototype.setErrorIndex = function setErrorIndex(errorIndex) {\n    this._errorIndex = errorIndex;\n  };\n  return ParsePosition;\n}();\nfunction _classCallCheck$i(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar EnumMap = function () {\n  function EnumMap() {\n    _classCallCheck$i(this, EnumMap);\n    this._map = {};\n  }\n  EnumMap.prototype.putAll = function putAll(otherMap) {\n    for (var key in otherMap._map) {\n      this._map[key] = otherMap._map[key];\n    }\n    return this;\n  };\n  EnumMap.prototype.containsKey = function containsKey(key) {\n    return this._map.hasOwnProperty(key.name()) && this.get(key) !== undefined;\n  };\n  EnumMap.prototype.get = function get(key) {\n    return this._map[key.name()];\n  };\n  EnumMap.prototype.put = function put(key, val) {\n    return this.set(key, val);\n  };\n  EnumMap.prototype.set = function set(key, val) {\n    this._map[key.name()] = val;\n    return this;\n  };\n  EnumMap.prototype.retainAll = function retainAll(keyList) {\n    var map = {};\n    for (var i = 0; i < keyList.length; i++) {\n      var key = keyList[i].name();\n      map[key] = this._map[key];\n    }\n    this._map = map;\n    return this;\n  };\n  EnumMap.prototype.remove = function remove(key) {\n    var keyName = key.name();\n    var val = this._map[keyName];\n    this._map[keyName] = undefined;\n    return val;\n  };\n  EnumMap.prototype.keySet = function keySet() {\n    return this._map;\n  };\n  EnumMap.prototype.clear = function clear() {\n    this._map = {};\n  };\n  return EnumMap;\n}();\nfunction _classCallCheck$j(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$8(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$8(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar ResolverStyle = function (_Enum) {\n  _inherits$8(ResolverStyle, _Enum);\n  function ResolverStyle() {\n    _classCallCheck$j(this, ResolverStyle);\n    return _possibleConstructorReturn$8(this, _Enum.apply(this, arguments));\n  }\n  return ResolverStyle;\n}(Enum);\nResolverStyle.STRICT = new ResolverStyle('STRICT');\nResolverStyle.SMART = new ResolverStyle('SMART');\nResolverStyle.LENIENT = new ResolverStyle('LENIENT');\nfunction _classCallCheck$k(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$9(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$9(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar ChronoLocalDate = function (_Temporal) {\n  _inherits$9(ChronoLocalDate, _Temporal);\n  function ChronoLocalDate() {\n    _classCallCheck$k(this, ChronoLocalDate);\n    return _possibleConstructorReturn$9(this, _Temporal.apply(this, arguments));\n  }\n  ChronoLocalDate.prototype.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isDateBased();\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isDateBased();\n    }\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n  ChronoLocalDate.prototype.query = function query(_query) {\n    if (_query === TemporalQueries.chronology()) {\n      return this.chronology();\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.DAYS;\n    } else if (_query === TemporalQueries.localDate()) {\n      return LocalDate.ofEpochDay(this.toEpochDay());\n    } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n    return _Temporal.prototype.query.call(this, _query);\n  };\n  ChronoLocalDate.prototype.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());\n  };\n  ChronoLocalDate.prototype.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.format(this);\n  };\n  return ChronoLocalDate;\n}(Temporal);\nfunction _classCallCheck$l(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar StringUtil = function () {\n  function StringUtil() {\n    _classCallCheck$l(this, StringUtil);\n  }\n  StringUtil.startsWith = function startsWith(text, pattern) {\n    return text.indexOf(pattern) === 0;\n  };\n  StringUtil.hashCode = function hashCode(text) {\n    var len = text.length;\n    if (len === 0) {\n      return 0;\n    }\n    var hash = 0;\n    for (var i = 0; i < len; i++) {\n      var chr = text.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0;\n    }\n    return MathUtil.smi(hash);\n  };\n  return StringUtil;\n}();\nfunction _classCallCheck$m(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar ZoneId = function () {\n  function ZoneId() {\n    _classCallCheck$m(this, ZoneId);\n  }\n  ZoneId.systemDefault = function systemDefault() {\n    throw new DateTimeException('not supported operation');\n  };\n  ZoneId.getAvailableZoneIds = function getAvailableZoneIds() {\n    throw new DateTimeException('not supported operation');\n  };\n  ZoneId.of = function of(zoneId) {\n    throw new DateTimeException('not supported operation' + zoneId);\n  };\n  ZoneId.ofOffset = function ofOffset(prefix, offset) {\n    throw new DateTimeException('not supported operation' + prefix + offset);\n  };\n  ZoneId.from = function from(temporal) {\n    throw new DateTimeException('not supported operation' + temporal);\n  };\n  ZoneId.prototype.id = function id() {\n    abstractMethodFail('ZoneId.id');\n  };\n  ZoneId.prototype.rules = function rules() {\n    abstractMethodFail('ZoneId.rules');\n  };\n  ZoneId.prototype.normalized = function normalized() {\n    var rules = this.rules();\n    if (rules.isFixedOffset()) {\n      return rules.offset(Instant.EPOCH);\n    }\n    return this;\n  };\n  ZoneId.prototype.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ZoneId) {\n      return this.id() === other.id();\n    }\n    return false;\n  };\n  ZoneId.prototype.hashCode = function hashCode() {\n    return StringUtil.hashCode(this.id());\n  };\n  ZoneId.prototype.toString = function toString() {\n    return this.id();\n  };\n  ZoneId.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  return ZoneId;\n}();\nfunction _possibleConstructorReturn$a(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$a(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction _classCallCheck$n(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar ZoneRules = function () {\n  function ZoneRules() {\n    _classCallCheck$n(this, ZoneRules);\n  }\n  ZoneRules.of = function of(offset) {\n    requireNonNull(offset, 'offset');\n    return new Fixed(offset);\n  };\n  ZoneRules.prototype.isFixedOffset = function isFixedOffset() {\n    abstractMethodFail('ZoneRules.isFixedOffset');\n  };\n  ZoneRules.prototype.offset = function offset(instantOrLocalDateTime) {\n    if (instantOrLocalDateTime instanceof Instant) {\n      return this.offsetOfInstant(instantOrLocalDateTime);\n    } else {\n      return this.offsetOfLocalDateTime(instantOrLocalDateTime);\n    }\n  };\n  ZoneRules.prototype.offsetOfInstant = function offsetOfInstant(instant) {\n    abstractMethodFail('ZoneRules.offsetInstant');\n  };\n  ZoneRules.prototype.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {\n    abstractMethodFail('ZoneRules.offsetOfEpochMilli');\n  };\n  ZoneRules.prototype.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {\n    abstractMethodFail('ZoneRules.offsetLocalDateTime');\n  };\n  ZoneRules.prototype.validOffsets = function validOffsets(localDateTime) {\n    abstractMethodFail('ZoneRules.validOffsets');\n  };\n  ZoneRules.prototype.transition = function transition(localDateTime) {\n    abstractMethodFail('ZoneRules.transition');\n  };\n  ZoneRules.prototype.standardOffset = function standardOffset(instant) {\n    abstractMethodFail('ZoneRules.standardOffset');\n  };\n  ZoneRules.prototype.daylightSavings = function daylightSavings(instant) {\n    abstractMethodFail('ZoneRules.daylightSavings');\n  };\n  ZoneRules.prototype.isDaylightSavings = function isDaylightSavings(instant) {\n    abstractMethodFail('ZoneRules.isDaylightSavings');\n  };\n  ZoneRules.prototype.isValidOffset = function isValidOffset(localDateTime, offset) {\n    abstractMethodFail('ZoneRules.isValidOffset');\n  };\n  ZoneRules.prototype.nextTransition = function nextTransition(instant) {\n    abstractMethodFail('ZoneRules.nextTransition');\n  };\n  ZoneRules.prototype.previousTransition = function previousTransition(instant) {\n    abstractMethodFail('ZoneRules.previousTransition');\n  };\n  ZoneRules.prototype.transitions = function transitions() {\n    abstractMethodFail('ZoneRules.transitions');\n  };\n  ZoneRules.prototype.transitionRules = function transitionRules() {\n    abstractMethodFail('ZoneRules.transitionRules');\n  };\n  ZoneRules.prototype.toString = function toString() {\n    abstractMethodFail('ZoneRules.toString');\n  };\n  ZoneRules.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  return ZoneRules;\n}();\nvar Fixed = function (_ZoneRules) {\n  _inherits$a(Fixed, _ZoneRules);\n  function Fixed(offset) {\n    _classCallCheck$n(this, Fixed);\n    var _this = _possibleConstructorReturn$a(this, _ZoneRules.call(this));\n    _this._offset = offset;\n    return _this;\n  }\n  Fixed.prototype.isFixedOffset = function isFixedOffset() {\n    return true;\n  };\n  Fixed.prototype.offsetOfInstant = function offsetOfInstant() {\n    return this._offset;\n  };\n  Fixed.prototype.offsetOfEpochMilli = function offsetOfEpochMilli() {\n    return this._offset;\n  };\n  Fixed.prototype.offsetOfLocalDateTime = function offsetOfLocalDateTime() {\n    return this._offset;\n  };\n  Fixed.prototype.validOffsets = function validOffsets() {\n    return [this._offset];\n  };\n  Fixed.prototype.transition = function transition() {\n    return null;\n  };\n  Fixed.prototype.standardOffset = function standardOffset() {\n    return this._offset;\n  };\n  Fixed.prototype.daylightSavings = function daylightSavings() {\n    return Duration.ZERO;\n  };\n  Fixed.prototype.isDaylightSavings = function isDaylightSavings() {\n    return false;\n  };\n  Fixed.prototype.isValidOffset = function isValidOffset(localDateTime, offset) {\n    return this._offset.equals(offset);\n  };\n  Fixed.prototype.nextTransition = function nextTransition() {\n    return null;\n  };\n  Fixed.prototype.previousTransition = function previousTransition() {\n    return null;\n  };\n  Fixed.prototype.transitions = function transitions() {\n    return [];\n  };\n  Fixed.prototype.transitionRules = function transitionRules() {\n    return [];\n  };\n  Fixed.prototype.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof Fixed) {\n      return this._offset.equals(other._offset);\n    }\n    return false;\n  };\n  Fixed.prototype.toString = function toString() {\n    return 'FixedRules:' + this._offset.toString();\n  };\n  return Fixed;\n}(ZoneRules);\nfunction _classCallCheck$o(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$b(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$b(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar SECONDS_CACHE = {};\nvar ID_CACHE = {};\nvar ZoneOffset = function (_ZoneId) {\n  _inherits$b(ZoneOffset, _ZoneId);\n  function ZoneOffset(totalSeconds) {\n    _classCallCheck$o(this, ZoneOffset);\n    var _this = _possibleConstructorReturn$b(this, _ZoneId.call(this));\n    ZoneOffset._validateTotalSeconds(totalSeconds);\n    _this._totalSeconds = MathUtil.safeToInt(totalSeconds);\n    _this._rules = ZoneRules.of(_this);\n    _this._id = ZoneOffset._buildId(totalSeconds);\n    return _this;\n  }\n  ZoneOffset.prototype.totalSeconds = function totalSeconds() {\n    return this._totalSeconds;\n  };\n  ZoneOffset.prototype.id = function id() {\n    return this._id;\n  };\n  ZoneOffset._buildId = function _buildId(totalSeconds) {\n    if (totalSeconds === 0) {\n      return 'Z';\n    } else {\n      var absTotalSeconds = Math.abs(totalSeconds);\n      var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);\n      var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n      var buf = '' + (totalSeconds < 0 ? '-' : '+') + (absHours < 10 ? '0' : '') + absHours + (absMinutes < 10 ? ':0' : ':') + absMinutes;\n      var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);\n      if (absSeconds !== 0) {\n        buf += (absSeconds < 10 ? ':0' : ':') + absSeconds;\n      }\n      return buf;\n    }\n  };\n  ZoneOffset._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {\n    if (Math.abs(totalSeconds) > ZoneOffset.MAX_SECONDS) {\n      throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n    }\n  };\n  ZoneOffset._validate = function _validate(hours, minutes, seconds) {\n    if (hours < -18 || hours > 18) {\n      throw new DateTimeException('Zone offset hours not in valid range: value ' + hours + ' is not in the range -18 to 18');\n    }\n    if (hours > 0) {\n      if (minutes < 0 || seconds < 0) {\n        throw new DateTimeException('Zone offset minutes and seconds must be positive because hours is positive');\n      }\n    } else if (hours < 0) {\n      if (minutes > 0 || seconds > 0) {\n        throw new DateTimeException('Zone offset minutes and seconds must be negative because hours is negative');\n      }\n    } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {\n      throw new DateTimeException('Zone offset minutes and seconds must have the same sign');\n    }\n    if (Math.abs(minutes) > 59) {\n      throw new DateTimeException('Zone offset minutes not in valid range: abs(value) ' + Math.abs(minutes) + ' is not in the range 0 to 59');\n    }\n    if (Math.abs(seconds) > 59) {\n      throw new DateTimeException('Zone offset seconds not in valid range: abs(value) ' + Math.abs(seconds) + ' is not in the range 0 to 59');\n    }\n    if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {\n      throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n    }\n  };\n  ZoneOffset.of = function of(offsetId) {\n    requireNonNull(offsetId, 'offsetId');\n    var offset = ID_CACHE[offsetId];\n    if (offset != null) {\n      return offset;\n    }\n    var hours = void 0,\n      minutes = void 0,\n      seconds = void 0;\n    switch (offsetId.length) {\n      case 2:\n        offsetId = offsetId[0] + '0' + offsetId[1];\n      case 3:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = 0;\n        seconds = 0;\n        break;\n      case 5:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n        seconds = 0;\n        break;\n      case 6:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n        seconds = 0;\n        break;\n      case 7:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n        seconds = ZoneOffset._parseNumber(offsetId, 5, false);\n        break;\n      case 9:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n        seconds = ZoneOffset._parseNumber(offsetId, 7, true);\n        break;\n      default:\n        throw new DateTimeException('Invalid ID for ZoneOffset, invalid format: ' + offsetId);\n    }\n    var first = offsetId[0];\n    if (first !== '+' && first !== '-') {\n      throw new DateTimeException('Invalid ID for ZoneOffset, plus/minus not found when expected: ' + offsetId);\n    }\n    if (first === '-') {\n      return ZoneOffset.ofHoursMinutesSeconds(-hours, -minutes, -seconds);\n    } else {\n      return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, seconds);\n    }\n  };\n  ZoneOffset._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {\n    if (precededByColon && offsetId[pos - 1] !== ':') {\n      throw new DateTimeException('Invalid ID for ZoneOffset, colon not found when expected: ' + offsetId);\n    }\n    var ch1 = offsetId[pos];\n    var ch2 = offsetId[pos + 1];\n    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n      throw new DateTimeException('Invalid ID for ZoneOffset, non numeric characters found: ' + offsetId);\n    }\n    return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n  };\n  ZoneOffset.ofHours = function ofHours(hours) {\n    return ZoneOffset.ofHoursMinutesSeconds(hours, 0, 0);\n  };\n  ZoneOffset.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {\n    return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, 0);\n  };\n  ZoneOffset.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {\n    ZoneOffset._validate(hours, minutes, seconds);\n    var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;\n    return ZoneOffset.ofTotalSeconds(totalSeconds);\n  };\n  ZoneOffset.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {\n    var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;\n    return ZoneOffset.ofTotalSeconds(totalSeconds);\n  };\n  ZoneOffset.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {\n    if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {\n      var totalSecs = totalSeconds;\n      var result = SECONDS_CACHE[totalSecs];\n      if (result == null) {\n        result = new ZoneOffset(totalSeconds);\n        SECONDS_CACHE[totalSecs] = result;\n        ID_CACHE[result.id()] = result;\n      }\n      return result;\n    } else {\n      return new ZoneOffset(totalSeconds);\n    }\n  };\n  ZoneOffset.prototype.rules = function rules() {\n    return this._rules;\n  };\n  ZoneOffset.prototype.get = function get(field) {\n    return this.getLong(field);\n  };\n  ZoneOffset.prototype.getLong = function getLong(field) {\n    if (field === ChronoField.OFFSET_SECONDS) {\n      return this._totalSeconds;\n    } else if (field instanceof ChronoField) {\n      throw new DateTimeException('Unsupported field: ' + field);\n    }\n    return field.getFrom(this);\n  };\n  ZoneOffset.prototype.query = function query(_query) {\n    requireNonNull(_query, 'query');\n    if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {\n      return this;\n    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {\n      return null;\n    }\n    return _query.queryFrom(this);\n  };\n  ZoneOffset.prototype.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);\n  };\n  ZoneOffset.prototype.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    return other._totalSeconds - this._totalSeconds;\n  };\n  ZoneOffset.prototype.equals = function equals(obj) {\n    if (this === obj) {\n      return true;\n    }\n    if (obj instanceof ZoneOffset) {\n      return this._totalSeconds === obj._totalSeconds;\n    }\n    return false;\n  };\n  ZoneOffset.prototype.hashCode = function hashCode() {\n    return this._totalSeconds;\n  };\n  ZoneOffset.prototype.toString = function toString() {\n    return this._id;\n  };\n  return ZoneOffset;\n}(ZoneId);\nfunction _init$7() {\n  ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n  ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n  ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n  ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);\n}\nfunction _classCallCheck$p(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$c(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$c(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar DateTimeBuilder = function (_Temporal) {\n  _inherits$c(DateTimeBuilder, _Temporal);\n  DateTimeBuilder.create = function create(field, value) {\n    var dtb = new DateTimeBuilder();\n    dtb._addFieldValue(field, value);\n    return dtb;\n  };\n  function DateTimeBuilder() {\n    _classCallCheck$p(this, DateTimeBuilder);\n    var _this = _possibleConstructorReturn$c(this, _Temporal.call(this));\n    _this.fieldValues = new EnumMap();\n    _this.chrono = null;\n    _this.zone = null;\n    _this.date = null;\n    _this.time = null;\n    _this.leapSecond = false;\n    _this.excessDays = null;\n    return _this;\n  }\n  DateTimeBuilder.prototype.getFieldValue0 = function getFieldValue0(field) {\n    return this.fieldValues.get(field);\n  };\n  DateTimeBuilder.prototype._addFieldValue = function _addFieldValue(field, value) {\n    requireNonNull(field, 'field');\n    var old = this.getFieldValue0(field);\n    if (old != null && old !== value) {\n      throw new DateTimeException('Conflict found: ' + field + ' ' + old + ' differs from ' + field + ' ' + value + ': ' + this);\n    }\n    return this._putFieldValue0(field, value);\n  };\n  DateTimeBuilder.prototype._putFieldValue0 = function _putFieldValue0(field, value) {\n    this.fieldValues.put(field, value);\n    return this;\n  };\n  DateTimeBuilder.prototype.resolve = function resolve(resolverStyle, resolverFields) {\n    if (resolverFields != null) {\n      this.fieldValues.retainAll(resolverFields);\n    }\n    this._mergeDate(resolverStyle);\n    this._mergeTime(resolverStyle);\n    this._resolveTimeInferZeroes(resolverStyle);\n    if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {\n      this.date = this.date.plus(this.excessDays);\n      this.excessDays = Period.ZERO;\n    }\n    this._resolveInstant();\n    return this;\n  };\n  DateTimeBuilder.prototype._mergeDate = function _mergeDate(resolverStyle) {\n    this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));\n  };\n  DateTimeBuilder.prototype._checkDate = function _checkDate(date) {\n    if (date != null) {\n      this._addObject(date);\n      for (var fieldName in this.fieldValues.keySet()) {\n        var field = ChronoField.byName(fieldName);\n        if (field) {\n          if (this.fieldValues.get(field) !== undefined) {\n            if (field.isDateBased()) {\n              var val1 = void 0;\n              try {\n                val1 = date.getLong(field);\n              } catch (ex) {\n                if (ex instanceof DateTimeException) {\n                  continue;\n                } else {\n                  throw ex;\n                }\n              }\n              var val2 = this.fieldValues.get(field);\n              if (val1 !== val2) {\n                throw new DateTimeException('Conflict found: Field ' + field + ' ' + val1 + ' differs from ' + field + ' ' + val2 + ' derived from ' + date);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  DateTimeBuilder.prototype._mergeTime = function _mergeTime(resolverStyle) {\n    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {\n      var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        if (resolverStyle === ResolverStyle.SMART && ch === 0) ;else {\n          ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);\n        }\n      }\n      this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);\n    }\n    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {\n      var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        if (resolverStyle === ResolverStyle.SMART && _ch === 0) ;else {\n          ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);\n        }\n      }\n      this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);\n    }\n    if (resolverStyle !== ResolverStyle.LENIENT) {\n      if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {\n        ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));\n      }\n      if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n        ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));\n      }\n    }\n    if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n      var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);\n      var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);\n      this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);\n    }\n    if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {\n      var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.NANO_OF_DAY.checkValidValue(nod);\n      }\n      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1000000000));\n      this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000));\n    }\n    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {\n      var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.MICRO_OF_DAY.checkValidValue(cod);\n      }\n      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1000000));\n      this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1000000));\n    }\n    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {\n      var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.MILLI_OF_DAY.checkValidValue(lod);\n      }\n      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1000));\n      this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1000));\n    }\n    if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {\n      var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.SECOND_OF_DAY.checkValidValue(sod);\n      }\n      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));\n      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));\n      this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));\n    }\n    if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {\n      var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.MINUTE_OF_DAY.checkValidValue(mod);\n      }\n      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));\n      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));\n    }\n    if (resolverStyle !== ResolverStyle.LENIENT) {\n      if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n        ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));\n      }\n      if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n        ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));\n      }\n    }\n    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n      var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n      var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);\n      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1000 + MathUtil.intMod(cos, 1000));\n    }\n    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n      var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1000));\n      this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n    }\n    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n      var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n      this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1000000));\n      this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n    }\n    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n      var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1000);\n    } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n      var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1000000);\n    }\n  };\n  DateTimeBuilder.prototype._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {\n    var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);\n    var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);\n    var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);\n    var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n    if (hod == null) {\n      return;\n    }\n    if (moh == null && (som != null || nos != null)) {\n      return;\n    }\n    if (moh != null && som == null && nos != null) {\n      return;\n    }\n    if (resolverStyle !== ResolverStyle.LENIENT) {\n      if (hod != null) {\n        if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {\n          hod = 0;\n          this.excessDays = Period.ofDays(1);\n        }\n        var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);\n        if (moh != null) {\n          var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);\n          if (som != null) {\n            var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);\n            if (nos != null) {\n              var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);\n              this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));\n            } else {\n              this._addObject(LocalTime.of(hodVal, mohVal, somVal));\n            }\n          } else {\n            if (nos == null) {\n              this._addObject(LocalTime.of(hodVal, mohVal));\n            }\n          }\n        } else {\n          if (som == null && nos == null) {\n            this._addObject(LocalTime.of(hodVal, 0));\n          }\n        }\n      }\n    } else {\n      if (hod != null) {\n        var _hodVal = hod;\n        if (moh != null) {\n          if (som != null) {\n            if (nos == null) {\n              nos = 0;\n            }\n            var totalNanos = MathUtil.safeMultiply(_hodVal, 3600000000000);\n            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 60000000000));\n            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1000000000));\n            totalNanos = MathUtil.safeAdd(totalNanos, nos);\n            var excessDays = MathUtil.floorDiv(totalNanos, 86400000000000);\n            var nod = MathUtil.floorMod(totalNanos, 86400000000000);\n            this._addObject(LocalTime.ofNanoOfDay(nod));\n            this.excessDays = Period.ofDays(excessDays);\n          } else {\n            var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);\n            totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));\n            var _excessDays = MathUtil.floorDiv(totalSecs, 86400);\n            var sod = MathUtil.floorMod(totalSecs, 86400);\n            this._addObject(LocalTime.ofSecondOfDay(sod));\n            this.excessDays = Period.ofDays(_excessDays);\n          }\n        } else {\n          var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));\n          _hodVal = MathUtil.floorMod(_hodVal, 24);\n          this._addObject(LocalTime.of(_hodVal, 0));\n          this.excessDays = Period.ofDays(_excessDays2);\n        }\n      }\n    }\n    this.fieldValues.remove(ChronoField.HOUR_OF_DAY);\n    this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);\n    this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);\n    this.fieldValues.remove(ChronoField.NANO_OF_SECOND);\n  };\n  DateTimeBuilder.prototype._addObject = function _addObject(dateOrTime) {\n    if (dateOrTime instanceof ChronoLocalDate) {\n      this.date = dateOrTime;\n    } else if (dateOrTime instanceof LocalTime) {\n      this.time = dateOrTime;\n    }\n  };\n  DateTimeBuilder.prototype._resolveInstant = function _resolveInstant() {\n    if (this.date != null && this.time != null) {\n      var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);\n      if (offsetSecs != null) {\n        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n        var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);\n        this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);\n      } else if (this.zone != null) {\n        var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);\n        this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);\n      }\n    }\n  };\n  DateTimeBuilder.prototype.build = function build(type) {\n    return type.queryFrom(this);\n  };\n  DateTimeBuilder.prototype.isSupported = function isSupported(field) {\n    if (field == null) {\n      return false;\n    }\n    return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== undefined || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);\n  };\n  DateTimeBuilder.prototype.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n    var value = this.getFieldValue0(field);\n    if (value == null) {\n      if (this.date != null && this.date.isSupported(field)) {\n        return this.date.getLong(field);\n      }\n      if (this.time != null && this.time.isSupported(field)) {\n        return this.time.getLong(field);\n      }\n      throw new DateTimeException('Field not found: ' + field);\n    }\n    return value;\n  };\n  DateTimeBuilder.prototype.query = function query(_query) {\n    if (_query === TemporalQueries.zoneId()) {\n      return this.zone;\n    } else if (_query === TemporalQueries.chronology()) {\n      return this.chrono;\n    } else if (_query === TemporalQueries.localDate()) {\n      return this.date != null ? LocalDate.from(this.date) : null;\n    } else if (_query === TemporalQueries.localTime()) {\n      return this.time;\n    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {\n      return _query.queryFrom(this);\n    } else if (_query === TemporalQueries.precision()) {\n      return null;\n    }\n    return _query.queryFrom(this);\n  };\n  return DateTimeBuilder;\n}(Temporal);\nfunction _possibleConstructorReturn$d(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$d(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction _classCallCheck$q(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar DateTimeParseContext = function () {\n  function DateTimeParseContext() {\n    _classCallCheck$q(this, DateTimeParseContext);\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof DateTimeParseContext) {\n        this._constructorSelf.apply(this, arguments);\n        return;\n      } else {\n        this._constructorFormatter.apply(this, arguments);\n      }\n    } else {\n      this._constructorParam.apply(this, arguments);\n    }\n    this._caseSensitive = true;\n    this._strict = true;\n    this._parsed = [new Parsed(this)];\n  }\n  DateTimeParseContext.prototype._constructorParam = function _constructorParam(locale, symbols, chronology) {\n    this._locale = locale;\n    this._symbols = symbols;\n    this._overrideChronology = chronology;\n  };\n  DateTimeParseContext.prototype._constructorFormatter = function _constructorFormatter(formatter) {\n    this._locale = formatter.locale();\n    this._symbols = formatter.decimalStyle();\n    this._overrideChronology = formatter.chronology();\n  };\n  DateTimeParseContext.prototype._constructorSelf = function _constructorSelf(other) {\n    this._locale = other._locale;\n    this._symbols = other._symbols;\n    this._overrideChronology = other._overrideChronology;\n    this._overrideZone = other._overrideZone;\n    this._caseSensitive = other._caseSensitive;\n    this._strict = other._strict;\n    this._parsed = [new Parsed(this)];\n  };\n  DateTimeParseContext.prototype.copy = function copy() {\n    return new DateTimeParseContext(this);\n  };\n  DateTimeParseContext.prototype.symbols = function symbols() {\n    return this._symbols;\n  };\n  DateTimeParseContext.prototype.isStrict = function isStrict() {\n    return this._strict;\n  };\n  DateTimeParseContext.prototype.setStrict = function setStrict(strict) {\n    this._strict = strict;\n  };\n  DateTimeParseContext.prototype.locale = function locale() {\n    return this._locale;\n  };\n  DateTimeParseContext.prototype.setLocale = function setLocale(locale) {\n    this._locale = locale;\n  };\n  DateTimeParseContext.prototype.startOptional = function startOptional() {\n    this._parsed.push(this.currentParsed().copy());\n  };\n  DateTimeParseContext.prototype.endOptional = function endOptional(successful) {\n    if (successful) {\n      this._parsed.splice(this._parsed.length - 2, 1);\n    } else {\n      this._parsed.splice(this._parsed.length - 1, 1);\n    }\n  };\n  DateTimeParseContext.prototype.isCaseSensitive = function isCaseSensitive() {\n    return this._caseSensitive;\n  };\n  DateTimeParseContext.prototype.setCaseSensitive = function setCaseSensitive(caseSensitive) {\n    this._caseSensitive = caseSensitive;\n  };\n  DateTimeParseContext.prototype.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {\n    if (offset1 + length > cs1.length || offset2 + length > cs2.length) {\n      return false;\n    }\n    if (!this.isCaseSensitive()) {\n      cs1 = cs1.toLowerCase();\n      cs2 = cs2.toLowerCase();\n    }\n    for (var i = 0; i < length; i++) {\n      var ch1 = cs1[offset1 + i];\n      var ch2 = cs2[offset2 + i];\n      if (ch1 !== ch2) {\n        return false;\n      }\n    }\n    return true;\n  };\n  DateTimeParseContext.prototype.charEquals = function charEquals(ch1, ch2) {\n    if (this.isCaseSensitive()) {\n      return ch1 === ch2;\n    }\n    return this.charEqualsIgnoreCase(ch1, ch2);\n  };\n  DateTimeParseContext.prototype.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {\n    return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();\n  };\n  DateTimeParseContext.prototype.setParsedField = function setParsedField(field, value, errorPos, successPos) {\n    var currentParsedFieldValues = this.currentParsed().fieldValues;\n    var old = currentParsedFieldValues.get(field);\n    currentParsedFieldValues.set(field, value);\n    return old != null && old !== value ? ~errorPos : successPos;\n  };\n  DateTimeParseContext.prototype.setParsedZone = function setParsedZone(zone) {\n    requireNonNull(zone, 'zone');\n    this.currentParsed().zone = zone;\n  };\n  DateTimeParseContext.prototype.getParsed = function getParsed(field) {\n    return this.currentParsed().fieldValues.get(field);\n  };\n  DateTimeParseContext.prototype.toParsed = function toParsed() {\n    return this.currentParsed();\n  };\n  DateTimeParseContext.prototype.currentParsed = function currentParsed() {\n    return this._parsed[this._parsed.length - 1];\n  };\n  DateTimeParseContext.prototype.setParsedLeapSecond = function setParsedLeapSecond() {\n    this.currentParsed().leapSecond = true;\n  };\n  DateTimeParseContext.prototype.getEffectiveChronology = function getEffectiveChronology() {\n    var chrono = this.currentParsed().chrono;\n    if (chrono == null) {\n      chrono = this._overrideChronology;\n      if (chrono == null) {\n        chrono = IsoChronology.INSTANCE;\n      }\n    }\n    return chrono;\n  };\n  return DateTimeParseContext;\n}();\nvar Parsed = function (_Temporal) {\n  _inherits$d(Parsed, _Temporal);\n  function Parsed(dateTimeParseContext) {\n    _classCallCheck$q(this, Parsed);\n    var _this = _possibleConstructorReturn$d(this, _Temporal.call(this));\n    _this.chrono = null;\n    _this.zone = null;\n    _this.fieldValues = new EnumMap();\n    _this.leapSecond = false;\n    _this.dateTimeParseContext = dateTimeParseContext;\n    return _this;\n  }\n  Parsed.prototype.copy = function copy() {\n    var cloned = new Parsed();\n    cloned.chrono = this.chrono;\n    cloned.zone = this.zone;\n    cloned.fieldValues.putAll(this.fieldValues);\n    cloned.leapSecond = this.leapSecond;\n    cloned.dateTimeParseContext = this.dateTimeParseContext;\n    return cloned;\n  };\n  Parsed.prototype.toString = function toString() {\n    return this.fieldValues + ', ' + this.chrono + ', ' + this.zone;\n  };\n  Parsed.prototype.isSupported = function isSupported(field) {\n    return this.fieldValues.containsKey(field);\n  };\n  Parsed.prototype.get = function get(field) {\n    var val = this.fieldValues.get(field);\n    assert(val != null);\n    return val;\n  };\n  Parsed.prototype.query = function query(_query) {\n    if (_query === TemporalQueries.chronology()) {\n      return this.chrono;\n    }\n    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {\n      return this.zone;\n    }\n    return _Temporal.prototype.query.call(this, _query);\n  };\n  Parsed.prototype.toBuilder = function toBuilder() {\n    var builder = new DateTimeBuilder();\n    builder.fieldValues.putAll(this.fieldValues);\n    builder.chrono = this.dateTimeParseContext.getEffectiveChronology();\n    if (this.zone != null) {\n      builder.zone = this.zone;\n    } else {\n      builder.zone = this.overrideZone;\n    }\n    builder.leapSecond = this.leapSecond;\n    builder.excessDays = this.excessDays;\n    return builder;\n  };\n  return Parsed;\n}(Temporal);\nfunction _classCallCheck$r(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar DateTimePrintContext = function () {\n  function DateTimePrintContext(temporal, localeOrFormatter, symbols) {\n    _classCallCheck$r(this, DateTimePrintContext);\n    if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {\n      this._temporal = DateTimePrintContext.adjust(temporal, localeOrFormatter);\n      this._locale = localeOrFormatter.locale();\n      this._symbols = localeOrFormatter.decimalStyle();\n    } else {\n      this._temporal = temporal;\n      this._locale = localeOrFormatter;\n      this._symbols = symbols;\n    }\n    this._optional = 0;\n  }\n  DateTimePrintContext.adjust = function adjust(temporal, formatter) {\n    return temporal;\n  };\n  DateTimePrintContext.prototype.symbols = function symbols() {\n    return this._symbols;\n  };\n  DateTimePrintContext.prototype.startOptional = function startOptional() {\n    this._optional++;\n  };\n  DateTimePrintContext.prototype.endOptional = function endOptional() {\n    this._optional--;\n  };\n  DateTimePrintContext.prototype.getValueQuery = function getValueQuery(query) {\n    var result = this._temporal.query(query);\n    if (result == null && this._optional === 0) {\n      throw new DateTimeException('Unable to extract value: ' + this._temporal);\n    }\n    return result;\n  };\n  DateTimePrintContext.prototype.getValue = function getValue(field) {\n    try {\n      return this._temporal.getLong(field);\n    } catch (ex) {\n      if (ex instanceof DateTimeException && this._optional > 0) {\n        return null;\n      }\n      throw ex;\n    }\n  };\n  DateTimePrintContext.prototype.temporal = function temporal() {\n    return this._temporal;\n  };\n  DateTimePrintContext.prototype.locale = function locale() {\n    return this._locale;\n  };\n  DateTimePrintContext.prototype.setDateTime = function setDateTime(temporal) {\n    this._temporal = temporal;\n  };\n  DateTimePrintContext.prototype.setLocale = function setLocale(locale) {\n    this._locale = locale;\n  };\n  return DateTimePrintContext;\n}();\nfunction _possibleConstructorReturn$e(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$e(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction _classCallCheck$s(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar IsoFields = function IsoFields() {\n  _classCallCheck$s(this, IsoFields);\n};\nvar QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];\nvar Field = function (_TemporalField) {\n  _inherits$e(Field, _TemporalField);\n  function Field() {\n    _classCallCheck$s(this, Field);\n    return _possibleConstructorReturn$e(this, _TemporalField.apply(this, arguments));\n  }\n  Field.prototype.isDateBased = function isDateBased() {\n    return true;\n  };\n  Field.prototype.isTimeBased = function isTimeBased() {\n    return false;\n  };\n  Field.prototype._isIso = function _isIso() {\n    return true;\n  };\n  Field._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {\n    var wby = Field._getWeekBasedYear(date);\n    return ValueRange.of(1, Field._getWeekRangeByYear(wby));\n  };\n  Field._getWeekRangeByYear = function _getWeekRangeByYear(wby) {\n    var date = LocalDate.of(wby, 1, 1);\n    if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {\n      return 53;\n    }\n    return 52;\n  };\n  Field._getWeek = function _getWeek(date) {\n    var dow0 = date.dayOfWeek().ordinal();\n    var doy0 = date.dayOfYear() - 1;\n    var doyThu0 = doy0 + (3 - dow0);\n    var alignedWeek = MathUtil.intDiv(doyThu0, 7);\n    var firstThuDoy0 = doyThu0 - alignedWeek * 7;\n    var firstMonDoy0 = firstThuDoy0 - 3;\n    if (firstMonDoy0 < -3) {\n      firstMonDoy0 += 7;\n    }\n    if (doy0 < firstMonDoy0) {\n      return Field._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();\n    }\n    var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;\n    if (week === 53) {\n      if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {\n        week = 1;\n      }\n    }\n    return week;\n  };\n  Field._getWeekBasedYear = function _getWeekBasedYear(date) {\n    var year = date.year();\n    var doy = date.dayOfYear();\n    if (doy <= 3) {\n      var dow = date.dayOfWeek().ordinal();\n      if (doy - dow < -2) {\n        year--;\n      }\n    } else if (doy >= 363) {\n      var _dow = date.dayOfWeek().ordinal();\n      doy = doy - 363 - (date.isLeapYear() ? 1 : 0);\n      if (doy - _dow >= 0) {\n        year++;\n      }\n    }\n    return year;\n  };\n  Field.prototype.getDisplayName = function getDisplayName() {\n    return this.toString();\n  };\n  Field.prototype.resolve = function resolve() {\n    return null;\n  };\n  Field.prototype.name = function name() {\n    return this.toString();\n  };\n  return Field;\n}(TemporalField);\nvar DAY_OF_QUARTER_FIELD = function (_Field) {\n  _inherits$e(DAY_OF_QUARTER_FIELD, _Field);\n  function DAY_OF_QUARTER_FIELD() {\n    _classCallCheck$s(this, DAY_OF_QUARTER_FIELD);\n    return _possibleConstructorReturn$e(this, _Field.apply(this, arguments));\n  }\n  DAY_OF_QUARTER_FIELD.prototype.toString = function toString() {\n    return 'DayOfQuarter';\n  };\n  DAY_OF_QUARTER_FIELD.prototype.baseUnit = function baseUnit() {\n    return ChronoUnit.DAYS;\n  };\n  DAY_OF_QUARTER_FIELD.prototype.rangeUnit = function rangeUnit() {\n    return QUARTER_YEARS;\n  };\n  DAY_OF_QUARTER_FIELD.prototype.range = function range() {\n    return ValueRange.of(1, 90, 92);\n  };\n  DAY_OF_QUARTER_FIELD.prototype.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);\n  };\n  DAY_OF_QUARTER_FIELD.prototype.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n    }\n    var qoy = temporal.getLong(QUARTER_OF_YEAR);\n    if (qoy === 1) {\n      var year = temporal.getLong(ChronoField.YEAR);\n      return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);\n    } else if (qoy === 2) {\n      return ValueRange.of(1, 91);\n    } else if (qoy === 3 || qoy === 4) {\n      return ValueRange.of(1, 92);\n    }\n    return this.range();\n  };\n  DAY_OF_QUARTER_FIELD.prototype.getFrom = function getFrom(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n    }\n    var doy = temporal.get(ChronoField.DAY_OF_YEAR);\n    var moy = temporal.get(ChronoField.MONTH_OF_YEAR);\n    var year = temporal.getLong(ChronoField.YEAR);\n    return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];\n  };\n  DAY_OF_QUARTER_FIELD.prototype.adjustInto = function adjustInto(temporal, newValue) {\n    var curValue = this.getFrom(temporal);\n    this.range().checkValidValue(newValue, this);\n    return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));\n  };\n  DAY_OF_QUARTER_FIELD.prototype.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {\n    var yearLong = fieldValues.get(ChronoField.YEAR);\n    var qoyLong = fieldValues.get(QUARTER_OF_YEAR);\n    if (yearLong == null || qoyLong == null) {\n      return null;\n    }\n    var y = ChronoField.YEAR.checkValidIntValue(yearLong);\n    var doq = fieldValues.get(DAY_OF_QUARTER);\n    var date = void 0;\n    if (resolverStyle === ResolverStyle.LENIENT) {\n      var qoy = qoyLong;\n      date = LocalDate.of(y, 1, 1);\n      date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));\n      date = date.plusDays(MathUtil.safeSubtract(doq, 1));\n    } else {\n      var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);\n      if (resolverStyle === ResolverStyle.STRICT) {\n        var max = 92;\n        if (_qoy === 1) {\n          max = IsoChronology.isLeapYear(y) ? 91 : 90;\n        } else if (_qoy === 2) {\n          max = 91;\n        }\n        ValueRange.of(1, max).checkValidValue(doq, this);\n      } else {\n        this.range().checkValidValue(doq, this);\n      }\n      date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);\n    }\n    fieldValues.remove(this);\n    fieldValues.remove(ChronoField.YEAR);\n    fieldValues.remove(QUARTER_OF_YEAR);\n    return date;\n  };\n  return DAY_OF_QUARTER_FIELD;\n}(Field);\nvar QUARTER_OF_YEAR_FIELD = function (_Field2) {\n  _inherits$e(QUARTER_OF_YEAR_FIELD, _Field2);\n  function QUARTER_OF_YEAR_FIELD() {\n    _classCallCheck$s(this, QUARTER_OF_YEAR_FIELD);\n    return _possibleConstructorReturn$e(this, _Field2.apply(this, arguments));\n  }\n  QUARTER_OF_YEAR_FIELD.prototype.toString = function toString() {\n    return 'QuarterOfYear';\n  };\n  QUARTER_OF_YEAR_FIELD.prototype.baseUnit = function baseUnit() {\n    return QUARTER_YEARS;\n  };\n  QUARTER_OF_YEAR_FIELD.prototype.rangeUnit = function rangeUnit() {\n    return ChronoUnit.YEARS;\n  };\n  QUARTER_OF_YEAR_FIELD.prototype.range = function range() {\n    return ValueRange.of(1, 4);\n  };\n  QUARTER_OF_YEAR_FIELD.prototype.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);\n  };\n  QUARTER_OF_YEAR_FIELD.prototype.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    return this.range();\n  };\n  QUARTER_OF_YEAR_FIELD.prototype.getFrom = function getFrom(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: QuarterOfYear');\n    }\n    var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);\n    return MathUtil.intDiv(moy + 2, 3);\n  };\n  QUARTER_OF_YEAR_FIELD.prototype.adjustInto = function adjustInto(temporal, newValue) {\n    var curValue = this.getFrom(temporal);\n    this.range().checkValidValue(newValue, this);\n    return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);\n  };\n  return QUARTER_OF_YEAR_FIELD;\n}(Field);\nvar WEEK_OF_WEEK_BASED_YEAR_FIELD = function (_Field3) {\n  _inherits$e(WEEK_OF_WEEK_BASED_YEAR_FIELD, _Field3);\n  function WEEK_OF_WEEK_BASED_YEAR_FIELD() {\n    _classCallCheck$s(this, WEEK_OF_WEEK_BASED_YEAR_FIELD);\n    return _possibleConstructorReturn$e(this, _Field3.apply(this, arguments));\n  }\n  WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.toString = function toString() {\n    return 'WeekOfWeekBasedYear';\n  };\n  WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.baseUnit = function baseUnit() {\n    return ChronoUnit.WEEKS;\n  };\n  WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.rangeUnit = function rangeUnit() {\n    return WEEK_BASED_YEARS;\n  };\n  WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.range = function range() {\n    return ValueRange.of(1, 52, 53);\n  };\n  WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n  };\n  WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n    }\n    return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));\n  };\n  WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.getFrom = function getFrom(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n    }\n    return Field._getWeek(LocalDate.from(temporal));\n  };\n  WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.adjustInto = function adjustInto(temporal, newValue) {\n    this.range().checkValidValue(newValue, this);\n    return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);\n  };\n  WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {\n    var wbyLong = fieldValues.get(WEEK_BASED_YEAR);\n    var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);\n    if (wbyLong == null || dowLong == null) {\n      return null;\n    }\n    var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);\n    var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);\n    var date = void 0;\n    if (resolverStyle === ResolverStyle.LENIENT) {\n      var dow = dowLong;\n      var weeks = 0;\n      if (dow > 7) {\n        weeks = MathUtil.intDiv(dow - 1, 7);\n        dow = MathUtil.intMod(dow - 1, 7) + 1;\n      } else if (dow < 1) {\n        weeks = MathUtil.intDiv(dow, 7) - 1;\n        dow = MathUtil.intMod(dow, 7) + 7;\n      }\n      date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);\n    } else {\n      var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);\n      if (resolverStyle === ResolverStyle.STRICT) {\n        var temp = LocalDate.of(wby, 1, 4);\n        var range = Field._getWeekRangeByLocalDate(temp);\n        range.checkValidValue(wowby, this);\n      } else {\n        this.range().checkValidValue(wowby, this);\n      }\n      date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);\n    }\n    fieldValues.remove(this);\n    fieldValues.remove(WEEK_BASED_YEAR);\n    fieldValues.remove(ChronoField.DAY_OF_WEEK);\n    return date;\n  };\n  WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.getDisplayName = function getDisplayName() {\n    return 'Week';\n  };\n  return WEEK_OF_WEEK_BASED_YEAR_FIELD;\n}(Field);\nvar WEEK_BASED_YEAR_FIELD = function (_Field4) {\n  _inherits$e(WEEK_BASED_YEAR_FIELD, _Field4);\n  function WEEK_BASED_YEAR_FIELD() {\n    _classCallCheck$s(this, WEEK_BASED_YEAR_FIELD);\n    return _possibleConstructorReturn$e(this, _Field4.apply(this, arguments));\n  }\n  WEEK_BASED_YEAR_FIELD.prototype.toString = function toString() {\n    return 'WeekBasedYear';\n  };\n  WEEK_BASED_YEAR_FIELD.prototype.baseUnit = function baseUnit() {\n    return WEEK_BASED_YEARS;\n  };\n  WEEK_BASED_YEAR_FIELD.prototype.rangeUnit = function rangeUnit() {\n    return ChronoUnit.FOREVER;\n  };\n  WEEK_BASED_YEAR_FIELD.prototype.range = function range() {\n    return ChronoField.YEAR.range();\n  };\n  WEEK_BASED_YEAR_FIELD.prototype.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n  };\n  WEEK_BASED_YEAR_FIELD.prototype.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    return ChronoField.YEAR.range();\n  };\n  WEEK_BASED_YEAR_FIELD.prototype.getFrom = function getFrom(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n    }\n    return Field._getWeekBasedYear(LocalDate.from(temporal));\n  };\n  WEEK_BASED_YEAR_FIELD.prototype.adjustInto = function adjustInto(temporal, newValue) {\n    if (this.isSupportedBy(temporal) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n    }\n    var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);\n    var date = LocalDate.from(temporal);\n    var dow = date.get(ChronoField.DAY_OF_WEEK);\n    var week = Field._getWeek(date);\n    if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {\n      week = 52;\n    }\n    var resolved = LocalDate.of(newWby, 1, 4);\n    var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;\n    resolved = resolved.plusDays(days);\n    return temporal.with(resolved);\n  };\n  return WEEK_BASED_YEAR_FIELD;\n}(Field);\nvar Unit = function (_TemporalUnit) {\n  _inherits$e(Unit, _TemporalUnit);\n  function Unit(name, estimatedDuration) {\n    _classCallCheck$s(this, Unit);\n    var _this6 = _possibleConstructorReturn$e(this, _TemporalUnit.call(this));\n    _this6._name = name;\n    _this6._duration = estimatedDuration;\n    return _this6;\n  }\n  Unit.prototype.duration = function duration() {\n    return this._duration;\n  };\n  Unit.prototype.isDurationEstimated = function isDurationEstimated() {\n    return true;\n  };\n  Unit.prototype.isDateBased = function isDateBased() {\n    return true;\n  };\n  Unit.prototype.isTimeBased = function isTimeBased() {\n    return false;\n  };\n  Unit.prototype.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.EPOCH_DAY);\n  };\n  Unit.prototype.addTo = function addTo(temporal, periodToAdd) {\n    switch (this) {\n      case WEEK_BASED_YEARS:\n        {\n          var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);\n          return temporal.with(WEEK_BASED_YEAR, added);\n        }\n      case QUARTER_YEARS:\n        return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);\n      default:\n        throw new IllegalStateException('Unreachable');\n    }\n  };\n  Unit.prototype.between = function between(temporal1, temporal2) {\n    switch (this) {\n      case WEEK_BASED_YEARS:\n        return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));\n      case QUARTER_YEARS:\n        return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);\n      default:\n        throw new IllegalStateException('Unreachable');\n    }\n  };\n  Unit.prototype.toString = function toString() {\n    return name;\n  };\n  return Unit;\n}(TemporalUnit);\nvar DAY_OF_QUARTER = null;\nvar QUARTER_OF_YEAR = null;\nvar WEEK_OF_WEEK_BASED_YEAR = null;\nvar WEEK_BASED_YEAR = null;\nvar WEEK_BASED_YEARS = null;\nvar QUARTER_YEARS = null;\nfunction _init$8() {\n  DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();\n  QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();\n  WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();\n  WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();\n  WEEK_BASED_YEARS = new Unit('WeekBasedYears', Duration.ofSeconds(31556952));\n  QUARTER_YEARS = new Unit('QuarterYears', Duration.ofSeconds(31556952 / 4));\n  IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;\n  IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;\n  IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;\n  IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;\n  IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;\n  IsoFields.QUARTER_YEARS = QUARTER_YEARS;\n  LocalDate.prototype.isoWeekOfWeekyear = function () {\n    return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);\n  };\n  LocalDate.prototype.isoWeekyear = function () {\n    return this.get(IsoFields.WEEK_BASED_YEAR);\n  };\n}\nfunction _classCallCheck$t(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar DecimalStyle = function () {\n  function DecimalStyle(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {\n    _classCallCheck$t(this, DecimalStyle);\n    this._zeroDigit = zeroChar;\n    this._zeroDigitCharCode = zeroChar.charCodeAt(0);\n    this._positiveSign = positiveSignChar;\n    this._negativeSign = negativeSignChar;\n    this._decimalSeparator = decimalPointChar;\n  }\n  DecimalStyle.prototype.positiveSign = function positiveSign() {\n    return this._positiveSign;\n  };\n  DecimalStyle.prototype.withPositiveSign = function withPositiveSign(positiveSign) {\n    if (positiveSign === this._positiveSign) {\n      return this;\n    }\n    return new DecimalStyle(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);\n  };\n  DecimalStyle.prototype.negativeSign = function negativeSign() {\n    return this._negativeSign;\n  };\n  DecimalStyle.prototype.withNegativeSign = function withNegativeSign(negativeSign) {\n    if (negativeSign === this._negativeSign) {\n      return this;\n    }\n    return new DecimalStyle(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);\n  };\n  DecimalStyle.prototype.zeroDigit = function zeroDigit() {\n    return this._zeroDigit;\n  };\n  DecimalStyle.prototype.withZeroDigit = function withZeroDigit(zeroDigit) {\n    if (zeroDigit === this._zeroDigit) {\n      return this;\n    }\n    return new DecimalStyle(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);\n  };\n  DecimalStyle.prototype.decimalSeparator = function decimalSeparator() {\n    return this._decimalSeparator;\n  };\n  DecimalStyle.prototype.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {\n    if (decimalSeparator === this._decimalSeparator) {\n      return this;\n    }\n    return new DecimalStyle(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);\n  };\n  DecimalStyle.prototype.convertToDigit = function convertToDigit(char) {\n    var val = char.charCodeAt(0) - this._zeroDigitCharCode;\n    return val >= 0 && val <= 9 ? val : -1;\n  };\n  DecimalStyle.prototype.convertNumberToI18N = function convertNumberToI18N(numericText) {\n    if (this._zeroDigit === '0') {\n      return numericText;\n    }\n    var diff = this._zeroDigitCharCode - '0'.charCodeAt(0);\n    var convertedText = '';\n    for (var i = 0; i < numericText.length; i++) {\n      convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);\n    }\n    return convertedText;\n  };\n  DecimalStyle.prototype.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof DecimalStyle) {\n      return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;\n    }\n    return false;\n  };\n  DecimalStyle.prototype.hashCode = function hashCode() {\n    return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;\n  };\n  DecimalStyle.prototype.toString = function toString() {\n    return 'DecimalStyle[' + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + ']';\n  };\n  DecimalStyle.of = function of() {\n    throw new Error('not yet supported');\n  };\n  DecimalStyle.availableLocales = function availableLocales() {\n    throw new Error('not yet supported');\n  };\n  return DecimalStyle;\n}();\nDecimalStyle.STANDARD = new DecimalStyle('0', '+', '-', '.');\nfunction _classCallCheck$u(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$f(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$f(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar SignStyle = function (_Enum) {\n  _inherits$f(SignStyle, _Enum);\n  function SignStyle() {\n    _classCallCheck$u(this, SignStyle);\n    return _possibleConstructorReturn$f(this, _Enum.apply(this, arguments));\n  }\n  SignStyle.prototype.parse = function parse(positive, strict, fixedWidth) {\n    switch (this) {\n      case SignStyle.NORMAL:\n        return !positive || !strict;\n      case SignStyle.ALWAYS:\n      case SignStyle.EXCEEDS_PAD:\n        return true;\n      default:\n        return !strict && !fixedWidth;\n    }\n  };\n  return SignStyle;\n}(Enum);\nSignStyle.NORMAL = new SignStyle('NORMAL');\nSignStyle.NEVER = new SignStyle('NEVER');\nSignStyle.ALWAYS = new SignStyle('ALWAYS');\nSignStyle.EXCEEDS_PAD = new SignStyle('EXCEEDS_PAD');\nSignStyle.NOT_NEGATIVE = new SignStyle('NOT_NEGATIVE');\nfunction _classCallCheck$v(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$g(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$g(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar TextStyle = function (_Enum) {\n  _inherits$g(TextStyle, _Enum);\n  function TextStyle() {\n    _classCallCheck$v(this, TextStyle);\n    return _possibleConstructorReturn$g(this, _Enum.apply(this, arguments));\n  }\n  TextStyle.prototype.isStandalone = function isStandalone() {\n    switch (this) {\n      case TextStyle.FULL_STANDALONE:\n      case TextStyle.SHORT_STANDALONE:\n      case TextStyle.NARROW_STANDALONE:\n        return true;\n      default:\n        return false;\n    }\n  };\n  TextStyle.prototype.asStandalone = function asStandalone() {\n    switch (this) {\n      case TextStyle.FULL:\n        return TextStyle.FULL_STANDALONE;\n      case TextStyle.SHORT:\n        return TextStyle.SHORT_STANDALONE;\n      case TextStyle.NARROW:\n        return TextStyle.NARROW_STANDALONE;\n      default:\n        return this;\n    }\n  };\n  TextStyle.prototype.asNormal = function asNormal() {\n    switch (this) {\n      case TextStyle.FULL_STANDALONE:\n        return TextStyle.FULL;\n      case TextStyle.SHORT_STANDALONE:\n        return TextStyle.SHORT;\n      case TextStyle.NARROW_STANDALONE:\n        return TextStyle.NARROW;\n      default:\n        return this;\n    }\n  };\n  return TextStyle;\n}(Enum);\nTextStyle.FULL = new TextStyle('FULL');\nTextStyle.FULL_STANDALONE = new TextStyle('FULL_STANDALONE');\nTextStyle.SHORT = new TextStyle('SHORT');\nTextStyle.SHORT_STANDALONE = new TextStyle('SHORT_STANDALONE');\nTextStyle.NARROW = new TextStyle('NARROW');\nTextStyle.NARROW_STANDALONE = new TextStyle('NARROW_STANDALONE');\nfunction _classCallCheck$w(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar CharLiteralPrinterParser = function () {\n  function CharLiteralPrinterParser(literal) {\n    _classCallCheck$w(this, CharLiteralPrinterParser);\n    if (literal.length > 1) {\n      throw new IllegalArgumentException('invalid literal, too long: \"' + literal + '\"');\n    }\n    this._literal = literal;\n  }\n  CharLiteralPrinterParser.prototype.print = function print(context, buf) {\n    buf.append(this._literal);\n    return true;\n  };\n  CharLiteralPrinterParser.prototype.parse = function parse(context, text, position) {\n    var length = text.length;\n    if (position === length) {\n      return ~position;\n    }\n    var ch = text.charAt(position);\n    if (context.charEquals(this._literal, ch) === false) {\n      return ~position;\n    }\n    return position + this._literal.length;\n  };\n  CharLiteralPrinterParser.prototype.toString = function toString() {\n    if (this._literal === '\\'') {\n      return \"''\";\n    }\n    return \"'\" + this._literal + \"'\";\n  };\n  return CharLiteralPrinterParser;\n}();\nfunction _classCallCheck$x(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar CompositePrinterParser = function () {\n  function CompositePrinterParser(printerParsers, optional) {\n    _classCallCheck$x(this, CompositePrinterParser);\n    this._printerParsers = printerParsers;\n    this._optional = optional;\n  }\n  CompositePrinterParser.prototype.withOptional = function withOptional(optional) {\n    if (optional === this._optional) {\n      return this;\n    }\n    return new CompositePrinterParser(this._printerParsers, optional);\n  };\n  CompositePrinterParser.prototype.print = function print(context, buf) {\n    var length = buf.length();\n    if (this._optional) {\n      context.startOptional();\n    }\n    try {\n      for (var i = 0; i < this._printerParsers.length; i++) {\n        var pp = this._printerParsers[i];\n        if (pp.print(context, buf) === false) {\n          buf.setLength(length);\n          return true;\n        }\n      }\n    } finally {\n      if (this._optional) {\n        context.endOptional();\n      }\n    }\n    return true;\n  };\n  CompositePrinterParser.prototype.parse = function parse(context, text, position) {\n    if (this._optional) {\n      context.startOptional();\n      var pos = position;\n      for (var i = 0; i < this._printerParsers.length; i++) {\n        var pp = this._printerParsers[i];\n        pos = pp.parse(context, text, pos);\n        if (pos < 0) {\n          context.endOptional(false);\n          return position;\n        }\n      }\n      context.endOptional(true);\n      return pos;\n    } else {\n      for (var _i = 0; _i < this._printerParsers.length; _i++) {\n        var _pp = this._printerParsers[_i];\n        position = _pp.parse(context, text, position);\n        if (position < 0) {\n          break;\n        }\n      }\n      return position;\n    }\n  };\n  CompositePrinterParser.prototype.toString = function toString() {\n    var buf = '';\n    if (this._printerParsers != null) {\n      buf += this._optional ? '[' : '(';\n      for (var i = 0; i < this._printerParsers.length; i++) {\n        var pp = this._printerParsers[i];\n        buf += pp.toString();\n      }\n      buf += this._optional ? ']' : ')';\n    }\n    return buf;\n  };\n  return CompositePrinterParser;\n}();\nfunction _classCallCheck$y(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar FractionPrinterParser = function () {\n  function FractionPrinterParser(field, minWidth, maxWidth, decimalPoint) {\n    _classCallCheck$y(this, FractionPrinterParser);\n    requireNonNull(field, 'field');\n    if (field.range().isFixed() === false) {\n      throw new IllegalArgumentException('Field must have a fixed set of values: ' + field);\n    }\n    if (minWidth < 0 || minWidth > 9) {\n      throw new IllegalArgumentException('Minimum width must be from 0 to 9 inclusive but was ' + minWidth);\n    }\n    if (maxWidth < 1 || maxWidth > 9) {\n      throw new IllegalArgumentException('Maximum width must be from 1 to 9 inclusive but was ' + maxWidth);\n    }\n    if (maxWidth < minWidth) {\n      throw new IllegalArgumentException('Maximum width must exceed or equal the minimum width but ' + maxWidth + ' < ' + minWidth);\n    }\n    this.field = field;\n    this.minWidth = minWidth;\n    this.maxWidth = maxWidth;\n    this.decimalPoint = decimalPoint;\n  }\n  FractionPrinterParser.prototype.print = function print(context, buf) {\n    var value = context.getValue(this.field);\n    if (value === null) {\n      return false;\n    }\n    var symbols = context.symbols();\n    if (value === 0) {\n      if (this.minWidth > 0) {\n        if (this.decimalPoint) {\n          buf.append(symbols.decimalSeparator());\n        }\n        for (var i = 0; i < this.minWidth; i++) {\n          buf.append(symbols.zeroDigit());\n        }\n      }\n    } else {\n      var fraction = this.convertToFraction(value, symbols.zeroDigit());\n      var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);\n      fraction = fraction.substr(0, outputScale);\n      if (fraction * 1 > 0) {\n        while (fraction.length > this.minWidth && fraction[fraction.length - 1] === '0') {\n          fraction = fraction.substr(0, fraction.length - 1);\n        }\n      }\n      var str = fraction;\n      str = symbols.convertNumberToI18N(str);\n      if (this.decimalPoint) {\n        buf.append(symbols.decimalSeparator());\n      }\n      buf.append(str);\n    }\n    return true;\n  };\n  FractionPrinterParser.prototype.parse = function parse(context, text, position) {\n    var effectiveMin = context.isStrict() ? this.minWidth : 0;\n    var effectiveMax = context.isStrict() ? this.maxWidth : 9;\n    var length = text.length;\n    if (position === length) {\n      return effectiveMin > 0 ? ~position : position;\n    }\n    if (this.decimalPoint) {\n      if (text[position] !== context.symbols().decimalSeparator()) {\n        return effectiveMin > 0 ? ~position : position;\n      }\n      position++;\n    }\n    var minEndPos = position + effectiveMin;\n    if (minEndPos > length) {\n      return ~position;\n    }\n    var maxEndPos = Math.min(position + effectiveMax, length);\n    var total = 0;\n    var pos = position;\n    while (pos < maxEndPos) {\n      var ch = text.charAt(pos++);\n      var digit = context.symbols().convertToDigit(ch);\n      if (digit < 0) {\n        if (pos < minEndPos) {\n          return ~position;\n        }\n        pos--;\n        break;\n      }\n      total = total * 10 + digit;\n    }\n    var moveLeft = pos - position;\n    var scale = Math.pow(10, moveLeft);\n    var value = this.convertFromFraction(total, scale);\n    return context.setParsedField(this.field, value, position, pos);\n  };\n  FractionPrinterParser.prototype.convertToFraction = function convertToFraction(value, zeroDigit) {\n    var range = this.field.range();\n    range.checkValidValue(value, this.field);\n    var _min = range.minimum();\n    var _range = range.maximum() - _min + 1;\n    var _value = value - _min;\n    var _scaled = MathUtil.intDiv(_value * 1000000000, _range);\n    var fraction = '' + _scaled;\n    while (fraction.length < 9) {\n      fraction = zeroDigit + fraction;\n    }\n    return fraction;\n  };\n  FractionPrinterParser.prototype.convertFromFraction = function convertFromFraction(total, scale) {\n    var range = this.field.range();\n    var _min = range.minimum();\n    var _range = range.maximum() - _min + 1;\n    var _value = MathUtil.intDiv(total * _range, scale);\n    return _value;\n  };\n  FractionPrinterParser.prototype.toString = function toString() {\n    var decimal = this.decimalPoint ? ',DecimalPoint' : '';\n    return 'Fraction(' + this.field + ',' + this.minWidth + ',' + this.maxWidth + decimal + ')';\n  };\n  return FractionPrinterParser;\n}();\nfunction _possibleConstructorReturn$h(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$h(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction _classCallCheck$z(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar MAX_WIDTH = 15;\nvar EXCEED_POINTS = [0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];\nvar NumberPrinterParser = function () {\n  function NumberPrinterParser(field, minWidth, maxWidth, signStyle) {\n    var subsequentWidth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    _classCallCheck$z(this, NumberPrinterParser);\n    this._field = field;\n    this._minWidth = minWidth;\n    this._maxWidth = maxWidth;\n    this._signStyle = signStyle;\n    this._subsequentWidth = subsequentWidth;\n  }\n  NumberPrinterParser.prototype.field = function field() {\n    return this._field;\n  };\n  NumberPrinterParser.prototype.minWidth = function minWidth() {\n    return this._minWidth;\n  };\n  NumberPrinterParser.prototype.maxWidth = function maxWidth() {\n    return this._maxWidth;\n  };\n  NumberPrinterParser.prototype.signStyle = function signStyle() {\n    return this._signStyle;\n  };\n  NumberPrinterParser.prototype.withFixedWidth = function withFixedWidth() {\n    if (this._subsequentWidth === -1) {\n      return this;\n    }\n    return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);\n  };\n  NumberPrinterParser.prototype.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {\n    return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);\n  };\n  NumberPrinterParser.prototype._isFixedWidth = function _isFixedWidth() {\n    return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;\n  };\n  NumberPrinterParser.prototype.print = function print(context, buf) {\n    var contextValue = context.getValue(this._field);\n    if (contextValue == null) {\n      return false;\n    }\n    var value = this._getValue(context, contextValue);\n    var symbols = context.symbols();\n    var str = '' + Math.abs(value);\n    if (str.length > this._maxWidth) {\n      throw new DateTimeException('Field ' + this._field + ' cannot be printed as the value ' + value + ' exceeds the maximum print width of ' + this._maxWidth);\n    }\n    str = symbols.convertNumberToI18N(str);\n    if (value >= 0) {\n      switch (this._signStyle) {\n        case SignStyle.EXCEEDS_PAD:\n          if (this._minWidth < MAX_WIDTH && value >= EXCEED_POINTS[this._minWidth]) {\n            buf.append(symbols.positiveSign());\n          }\n          break;\n        case SignStyle.ALWAYS:\n          buf.append(symbols.positiveSign());\n          break;\n      }\n    } else {\n      switch (this._signStyle) {\n        case SignStyle.NORMAL:\n        case SignStyle.EXCEEDS_PAD:\n        case SignStyle.ALWAYS:\n          buf.append(symbols.negativeSign());\n          break;\n        case SignStyle.NOT_NEGATIVE:\n          throw new DateTimeException('Field ' + this._field + ' cannot be printed as the value ' + value + ' cannot be negative according to the SignStyle');\n      }\n    }\n    for (var i = 0; i < this._minWidth - str.length; i++) {\n      buf.append(symbols.zeroDigit());\n    }\n    buf.append(str);\n    return true;\n  };\n  NumberPrinterParser.prototype.parse = function parse(context, text, position) {\n    var length = text.length;\n    if (position === length) {\n      return ~position;\n    }\n    assert(position >= 0 && position < length);\n    var sign = text.charAt(position);\n    var negative = false;\n    var positive = false;\n    if (sign === context.symbols().positiveSign()) {\n      if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n        return ~position;\n      }\n      positive = true;\n      position++;\n    } else if (sign === context.symbols().negativeSign()) {\n      if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n        return ~position;\n      }\n      negative = true;\n      position++;\n    } else {\n      if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {\n        return ~position;\n      }\n    }\n    var effMinWidth = context.isStrict() || this._isFixedWidth() ? this._minWidth : 1;\n    var minEndPos = position + effMinWidth;\n    if (minEndPos > length) {\n      return ~position;\n    }\n    var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);\n    var total = 0;\n    var pos = position;\n    for (var pass = 0; pass < 2; pass++) {\n      var maxEndPos = Math.min(pos + effMaxWidth, length);\n      while (pos < maxEndPos) {\n        var ch = text.charAt(pos++);\n        var digit = context.symbols().convertToDigit(ch);\n        if (digit < 0) {\n          pos--;\n          if (pos < minEndPos) {\n            return ~position;\n          }\n          break;\n        }\n        if (pos - position > MAX_WIDTH) {\n          throw new ArithmeticException('number text exceeds length');\n        } else {\n          total = total * 10 + digit;\n        }\n      }\n      if (this._subsequentWidth > 0 && pass === 0) {\n        var parseLen = pos - position;\n        effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);\n        pos = position;\n        total = 0;\n      } else {\n        break;\n      }\n    }\n    if (negative) {\n      if (total === 0 && context.isStrict()) {\n        return ~(position - 1);\n      }\n      if (total !== 0) {\n        total = -total;\n      }\n    } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {\n      var _parseLen = pos - position;\n      if (positive) {\n        if (_parseLen <= this._minWidth) {\n          return ~(position - 1);\n        }\n      } else {\n        if (_parseLen > this._minWidth) {\n          return ~position;\n        }\n      }\n    }\n    return this._setValue(context, total, position, pos);\n  };\n  NumberPrinterParser.prototype._getValue = function _getValue(context, value) {\n    return value;\n  };\n  NumberPrinterParser.prototype._setValue = function _setValue(context, value, errorPos, successPos) {\n    return context.setParsedField(this._field, value, errorPos, successPos);\n  };\n  NumberPrinterParser.prototype.toString = function toString() {\n    if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH && this._signStyle === SignStyle.NORMAL) {\n      return 'Value(' + this._field + ')';\n    }\n    if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {\n      return 'Value(' + this._field + ',' + this._minWidth + ')';\n    }\n    return 'Value(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + this._signStyle + ')';\n  };\n  return NumberPrinterParser;\n}();\nvar ReducedPrinterParser = function (_NumberPrinterParser) {\n  _inherits$h(ReducedPrinterParser, _NumberPrinterParser);\n  function ReducedPrinterParser(field, width, maxWidth, baseValue, baseDate) {\n    _classCallCheck$z(this, ReducedPrinterParser);\n    var _this = _possibleConstructorReturn$h(this, _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE));\n    if (width < 1 || width > 10) {\n      throw new IllegalArgumentException('The width must be from 1 to 10 inclusive but was ' + width);\n    }\n    if (maxWidth < 1 || maxWidth > 10) {\n      throw new IllegalArgumentException('The maxWidth must be from 1 to 10 inclusive but was ' + maxWidth);\n    }\n    if (maxWidth < width) {\n      throw new IllegalArgumentException('The maxWidth must be greater than the width');\n    }\n    if (baseDate === null) {\n      if (field.range().isValidValue(baseValue) === false) {\n        throw new IllegalArgumentException('The base value must be within the range of the field');\n      }\n      if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {\n        throw new DateTimeException('Unable to add printer-parser as the range exceeds the capacity of an int');\n      }\n    }\n    _this._baseValue = baseValue;\n    _this._baseDate = baseDate;\n    return _this;\n  }\n  ReducedPrinterParser.prototype._getValue = function _getValue(context, value) {\n    var absValue = Math.abs(value);\n    var baseValue = this._baseValue;\n    if (this._baseDate !== null) {\n      context.temporal();\n      var chrono = IsoChronology.INSTANCE;\n      baseValue = chrono.date(this._baseDate).get(this._field);\n    }\n    if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {\n      return absValue % EXCEED_POINTS[this._minWidth];\n    }\n    return absValue % EXCEED_POINTS[this._maxWidth];\n  };\n  ReducedPrinterParser.prototype._setValue = function _setValue(context, value, errorPos, successPos) {\n    var baseValue = this._baseValue;\n    if (this._baseDate != null) {\n      var chrono = context.getEffectiveChronology();\n      baseValue = chrono.date(this._baseDate).get(this._field);\n    }\n    var parseLen = successPos - errorPos;\n    if (parseLen === this._minWidth && value >= 0) {\n      var range = EXCEED_POINTS[this._minWidth];\n      var lastPart = baseValue % range;\n      var basePart = baseValue - lastPart;\n      if (baseValue > 0) {\n        value = basePart + value;\n      } else {\n        value = basePart - value;\n      }\n      if (value < baseValue) {\n        value += range;\n      }\n    }\n    return context.setParsedField(this._field, value, errorPos, successPos);\n  };\n  ReducedPrinterParser.prototype.withFixedWidth = function withFixedWidth() {\n    if (this._subsequentWidth === -1) {\n      return this;\n    }\n    return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, -1);\n  };\n  ReducedPrinterParser.prototype.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {\n    return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);\n  };\n  ReducedPrinterParser.prototype.isFixedWidth = function isFixedWidth(context) {\n    if (context.isStrict() === false) {\n      return false;\n    }\n    return _NumberPrinterParser.prototype.isFixedWidth.call(this, context);\n  };\n  ReducedPrinterParser.prototype.toString = function toString() {\n    return 'ReducedValue(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + (this._baseDate != null ? this._baseDate : this._baseValue) + ')';\n  };\n  return ReducedPrinterParser;\n}(NumberPrinterParser);\nfunction _classCallCheck$A(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar PATTERNS = ['+HH', '+HHmm', '+HH:mm', '+HHMM', '+HH:MM', '+HHMMss', '+HH:MM:ss', '+HHMMSS', '+HH:MM:SS'];\nvar OffsetIdPrinterParser = function () {\n  function OffsetIdPrinterParser(noOffsetText, pattern) {\n    _classCallCheck$A(this, OffsetIdPrinterParser);\n    requireNonNull(noOffsetText, 'noOffsetText');\n    requireNonNull(pattern, 'pattern');\n    this.noOffsetText = noOffsetText;\n    this.type = this._checkPattern(pattern);\n  }\n  OffsetIdPrinterParser.prototype._checkPattern = function _checkPattern(pattern) {\n    for (var i = 0; i < PATTERNS.length; i++) {\n      if (PATTERNS[i] === pattern) {\n        return i;\n      }\n    }\n    throw new IllegalArgumentException('Invalid zone offset pattern: ' + pattern);\n  };\n  OffsetIdPrinterParser.prototype.print = function print(context, buf) {\n    var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);\n    if (offsetSecs == null) {\n      return false;\n    }\n    var totalSecs = MathUtil.safeToInt(offsetSecs);\n    if (totalSecs === 0) {\n      buf.append(this.noOffsetText);\n    } else {\n      var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));\n      var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));\n      var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));\n      var bufPos = buf.length();\n      var output = absHours;\n      buf.append(totalSecs < 0 ? '-' : '+').appendChar(MathUtil.intDiv(absHours, 10) + '0').appendChar(MathUtil.intMod(absHours, 10) + '0');\n      if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {\n        buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absMinutes, 10) + '0').appendChar(absMinutes % 10 + '0');\n        output += absMinutes;\n        if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {\n          buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absSeconds, 10) + '0').appendChar(absSeconds % 10 + '0');\n          output += absSeconds;\n        }\n      }\n      if (output === 0) {\n        buf.setLength(bufPos);\n        buf.append(this.noOffsetText);\n      }\n    }\n    return true;\n  };\n  OffsetIdPrinterParser.prototype.parse = function parse(context, text, position) {\n    var length = text.length;\n    var noOffsetLen = this.noOffsetText.length;\n    if (noOffsetLen === 0) {\n      if (position === length) {\n        return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);\n      }\n    } else {\n      if (position === length) {\n        return ~position;\n      }\n      if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {\n        return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n      }\n    }\n    var sign = text[position];\n    if (sign === '+' || sign === '-') {\n      var negative = sign === '-' ? -1 : 1;\n      var array = [0, 0, 0, 0];\n      array[0] = position + 1;\n      if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {\n        var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));\n        return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);\n      }\n    }\n    if (noOffsetLen === 0) {\n      return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n    }\n    return ~position;\n  };\n  OffsetIdPrinterParser.prototype._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {\n    if ((this.type + 3) / 2 < arrayIndex) {\n      return false;\n    }\n    var pos = array[0];\n    if (this.type % 2 === 0 && arrayIndex > 1) {\n      if (pos + 1 > parseText.length || parseText[pos] !== ':') {\n        return required;\n      }\n      pos++;\n    }\n    if (pos + 2 > parseText.length) {\n      return required;\n    }\n    var ch1 = parseText[pos++];\n    var ch2 = parseText[pos++];\n    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n      return required;\n    }\n    var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n    if (value < 0 || value > 59) {\n      return required;\n    }\n    array[arrayIndex] = value;\n    array[0] = pos;\n    return false;\n  };\n  OffsetIdPrinterParser.prototype.toString = function toString() {\n    var converted = this.noOffsetText.replace('\\'', '\\'\\'');\n    return 'Offset(' + PATTERNS[this.type] + ',\\'' + converted + '\\')';\n  };\n  return OffsetIdPrinterParser;\n}();\nOffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser('Z', '+HH:MM:ss');\nOffsetIdPrinterParser.PATTERNS = PATTERNS;\nfunction _classCallCheck$B(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar PadPrinterParserDecorator = function () {\n  function PadPrinterParserDecorator(printerParser, padWidth, padChar) {\n    _classCallCheck$B(this, PadPrinterParserDecorator);\n    this._printerParser = printerParser;\n    this._padWidth = padWidth;\n    this._padChar = padChar;\n  }\n  PadPrinterParserDecorator.prototype.print = function print(context, buf) {\n    var preLen = buf.length();\n    if (this._printerParser.print(context, buf) === false) {\n      return false;\n    }\n    var len = buf.length() - preLen;\n    if (len > this._padWidth) {\n      throw new DateTimeException('Cannot print as output of ' + len + ' characters exceeds pad width of ' + this._padWidth);\n    }\n    for (var i = 0; i < this._padWidth - len; i++) {\n      buf.insert(preLen, this._padChar);\n    }\n    return true;\n  };\n  PadPrinterParserDecorator.prototype.parse = function parse(context, text, position) {\n    var strict = context.isStrict();\n    var caseSensitive = context.isCaseSensitive();\n    assert(!(position > text.length));\n    assert(position >= 0);\n    if (position === text.length) {\n      return ~position;\n    }\n    var endPos = position + this._padWidth;\n    if (endPos > text.length) {\n      if (strict) {\n        return ~position;\n      }\n      endPos = text.length;\n    }\n    var pos = position;\n    while (pos < endPos && (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {\n      pos++;\n    }\n    text = text.substring(0, endPos);\n    var resultPos = this._printerParser.parse(context, text, pos);\n    if (resultPos !== endPos && strict) {\n      return ~(position + pos);\n    }\n    return resultPos;\n  };\n  PadPrinterParserDecorator.prototype.toString = function toString() {\n    return 'Pad(' + this._printerParser + ',' + this._padWidth + (this._padChar === ' ' ? ')' : ',\\'' + this._padChar + '\\')');\n  };\n  return PadPrinterParserDecorator;\n}();\nfunction _classCallCheck$C(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$i(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$i(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar SettingsParser = function (_Enum) {\n  _inherits$i(SettingsParser, _Enum);\n  function SettingsParser() {\n    _classCallCheck$C(this, SettingsParser);\n    return _possibleConstructorReturn$i(this, _Enum.apply(this, arguments));\n  }\n  SettingsParser.prototype.print = function print() {\n    return true;\n  };\n  SettingsParser.prototype.parse = function parse(context, text, position) {\n    switch (this) {\n      case SettingsParser.SENSITIVE:\n        context.setCaseSensitive(true);\n        break;\n      case SettingsParser.INSENSITIVE:\n        context.setCaseSensitive(false);\n        break;\n      case SettingsParser.STRICT:\n        context.setStrict(true);\n        break;\n      case SettingsParser.LENIENT:\n        context.setStrict(false);\n        break;\n    }\n    return position;\n  };\n  SettingsParser.prototype.toString = function toString() {\n    switch (this) {\n      case SettingsParser.SENSITIVE:\n        return 'ParseCaseSensitive(true)';\n      case SettingsParser.INSENSITIVE:\n        return 'ParseCaseSensitive(false)';\n      case SettingsParser.STRICT:\n        return 'ParseStrict(true)';\n      case SettingsParser.LENIENT:\n        return 'ParseStrict(false)';\n    }\n  };\n  return SettingsParser;\n}(Enum);\nSettingsParser.SENSITIVE = new SettingsParser('SENSITIVE');\nSettingsParser.INSENSITIVE = new SettingsParser('INSENSITIVE');\nSettingsParser.STRICT = new SettingsParser('STRICT');\nSettingsParser.LENIENT = new SettingsParser('LENIENT');\nfunction _classCallCheck$D(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar StringLiteralPrinterParser = function () {\n  function StringLiteralPrinterParser(literal) {\n    _classCallCheck$D(this, StringLiteralPrinterParser);\n    this._literal = literal;\n  }\n  StringLiteralPrinterParser.prototype.print = function print(context, buf) {\n    buf.append(this._literal);\n    return true;\n  };\n  StringLiteralPrinterParser.prototype.parse = function parse(context, text, position) {\n    var length = text.length;\n    assert(!(position > length || position < 0));\n    if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {\n      return ~position;\n    }\n    return position + this._literal.length;\n  };\n  StringLiteralPrinterParser.prototype.toString = function toString() {\n    var converted = this._literal.replace(\"'\", \"''\");\n    return '\\'' + converted + '\\'';\n  };\n  return StringLiteralPrinterParser;\n}();\nfunction _classCallCheck$E(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar ZoneRulesProvider = function () {\n  function ZoneRulesProvider() {\n    _classCallCheck$E(this, ZoneRulesProvider);\n  }\n  ZoneRulesProvider.getRules = function getRules(zoneId) {\n    throw new DateTimeException('unsupported ZoneId:' + zoneId);\n  };\n  ZoneRulesProvider.getAvailableZoneIds = function getAvailableZoneIds() {\n    return [];\n  };\n  return ZoneRulesProvider;\n}();\nfunction _classCallCheck$F(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$j(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$j(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar ZoneRegion = function (_ZoneId) {\n  _inherits$j(ZoneRegion, _ZoneId);\n  ZoneRegion.ofId = function ofId(zoneId) {\n    var rules = ZoneRulesProvider.getRules(zoneId);\n    return new ZoneRegion(zoneId, rules);\n  };\n  function ZoneRegion(id, rules) {\n    _classCallCheck$F(this, ZoneRegion);\n    var _this = _possibleConstructorReturn$j(this, _ZoneId.call(this));\n    _this._id = id;\n    _this._rules = rules;\n    return _this;\n  }\n  ZoneRegion.prototype.id = function id() {\n    return this._id;\n  };\n  ZoneRegion.prototype.rules = function rules() {\n    return this._rules;\n  };\n  return ZoneRegion;\n}(ZoneId);\nfunction _classCallCheck$G(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar ZoneIdPrinterParser = function () {\n  function ZoneIdPrinterParser(query, description) {\n    _classCallCheck$G(this, ZoneIdPrinterParser);\n    this.query = query;\n    this.description = description;\n  }\n  ZoneIdPrinterParser.prototype.print = function print(context, buf) {\n    var zone = context.getValueQuery(this.query);\n    if (zone == null) {\n      return false;\n    }\n    buf.append(zone.id());\n    return true;\n  };\n  ZoneIdPrinterParser.prototype.parse = function parse(context, text, position) {\n    var length = text.length;\n    if (position > length) {\n      return ~position;\n    }\n    if (position === length) {\n      return ~position;\n    }\n    var nextChar = text.charAt(position);\n    if (nextChar === '+' || nextChar === '-') {\n      var newContext = context.copy();\n      var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n      if (endPos < 0) {\n        return endPos;\n      }\n      var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n      var zone = ZoneOffset.ofTotalSeconds(offset);\n      context.setParsedZone(zone);\n      return endPos;\n    } else if (length >= position + 2) {\n      var nextNextChar = text.charAt(position + 1);\n      if (context.charEquals(nextChar, 'U') && context.charEquals(nextNextChar, 'T')) {\n        if (length >= position + 3 && context.charEquals(text.charAt(position + 2), 'C')) {\n          return this._parsePrefixedOffset(context, text, position, position + 3);\n        }\n        return this._parsePrefixedOffset(context, text, position, position + 2);\n      } else if (context.charEquals(nextChar, 'G') && length >= position + 3 && context.charEquals(nextNextChar, 'M') && context.charEquals(text.charAt(position + 2), 'T')) {\n        return this._parsePrefixedOffset(context, text, position, position + 3);\n      }\n    }\n    if (text.substr(position, 6) === 'SYSTEM') {\n      context.setParsedZone(ZoneId.systemDefault());\n      return position + 6;\n    }\n    if (context.charEquals(nextChar, 'Z')) {\n      context.setParsedZone(ZoneOffset.UTC);\n      return position + 1;\n    }\n    var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();\n    if (zoneIdTree.size !== availableZoneIds.length) {\n      zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);\n    }\n    var maxParseLength = length - position;\n    var treeMap = zoneIdTree.treeMap;\n    var parsedZoneId = null;\n    var parseLength = 0;\n    while (treeMap != null) {\n      var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));\n      treeMap = treeMap.get(parsedSubZoneId);\n      if (treeMap != null && treeMap.isLeaf) {\n        parsedZoneId = parsedSubZoneId;\n        parseLength = treeMap.length;\n      }\n    }\n    if (parsedZoneId != null) {\n      context.setParsedZone(ZoneRegion.ofId(parsedZoneId));\n      return position + parseLength;\n    }\n    return ~position;\n  };\n  ZoneIdPrinterParser.prototype._parsePrefixedOffset = function _parsePrefixedOffset(context, text, prefixPos, position) {\n    var prefix = text.substring(prefixPos, position).toUpperCase();\n    var newContext = context.copy();\n    if (position < text.length && context.charEquals(text.charAt(position), 'Z')) {\n      context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));\n      return position;\n    }\n    var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n    if (endPos < 0) {\n      context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));\n      return position;\n    }\n    var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n    var offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n    context.setParsedZone(ZoneId.ofOffset(prefix, offset));\n    return endPos;\n  };\n  ZoneIdPrinterParser.prototype.toString = function toString() {\n    return this.description;\n  };\n  return ZoneIdPrinterParser;\n}();\nvar ZoneIdTree = function () {\n  ZoneIdTree.createTreeMap = function createTreeMap(availableZoneIds) {\n    var sortedZoneIds = availableZoneIds.sort(function (a, b) {\n      return a.length - b.length;\n    });\n    var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);\n    for (var i = 0; i < sortedZoneIds.length; i++) {\n      treeMap.add(sortedZoneIds[i]);\n    }\n    return new ZoneIdTree(sortedZoneIds.length, treeMap);\n  };\n  function ZoneIdTree(size, treeMap) {\n    _classCallCheck$G(this, ZoneIdTree);\n    this.size = size;\n    this.treeMap = treeMap;\n  }\n  return ZoneIdTree;\n}();\nvar ZoneIdTreeMap = function () {\n  function ZoneIdTreeMap() {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var isLeaf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    _classCallCheck$G(this, ZoneIdTreeMap);\n    this.length = length;\n    this.isLeaf = isLeaf;\n    this._treeMap = {};\n  }\n  ZoneIdTreeMap.prototype.add = function add(zoneId) {\n    var idLength = zoneId.length;\n    if (idLength === this.length) {\n      this._treeMap[zoneId] = new ZoneIdTreeMap(idLength, true);\n    } else if (idLength > this.length) {\n      var subZoneId = zoneId.substr(0, this.length);\n      var subTreeMap = this._treeMap[subZoneId];\n      if (subTreeMap == null) {\n        subTreeMap = new ZoneIdTreeMap(idLength, false);\n        this._treeMap[subZoneId] = subTreeMap;\n      }\n      subTreeMap.add(zoneId);\n    }\n  };\n  ZoneIdTreeMap.prototype.get = function get(zoneId) {\n    return this._treeMap[zoneId];\n  };\n  return ZoneIdTreeMap;\n}();\nvar zoneIdTree = new ZoneIdTree([]);\nfunction _classCallCheck$H(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar MAX_WIDTH$1 = 15;\nvar DateTimeFormatterBuilder = function () {\n  function DateTimeFormatterBuilder() {\n    _classCallCheck$H(this, DateTimeFormatterBuilder);\n    this._active = this;\n    this._parent = null;\n    this._printerParsers = [];\n    this._optional = false;\n    this._padNextWidth = 0;\n    this._padNextChar = null;\n    this._valueParserIndex = -1;\n  }\n  DateTimeFormatterBuilder._of = function _of(parent, optional) {\n    requireNonNull(parent, 'parent');\n    requireNonNull(optional, 'optional');\n    var dtFormatterBuilder = new DateTimeFormatterBuilder();\n    dtFormatterBuilder._parent = parent;\n    dtFormatterBuilder._optional = optional;\n    return dtFormatterBuilder;\n  };\n  DateTimeFormatterBuilder.prototype.parseCaseSensitive = function parseCaseSensitive() {\n    this._appendInternalPrinterParser(SettingsParser.SENSITIVE);\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.parseCaseInsensitive = function parseCaseInsensitive() {\n    this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.parseStrict = function parseStrict() {\n    this._appendInternalPrinterParser(SettingsParser.STRICT);\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.parseLenient = function parseLenient() {\n    this._appendInternalPrinterParser(SettingsParser.LENIENT);\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.appendValue = function appendValue() {\n    if (arguments.length === 1) {\n      return this._appendValue1.apply(this, arguments);\n    } else if (arguments.length === 2) {\n      return this._appendValue2.apply(this, arguments);\n    } else {\n      return this._appendValue4.apply(this, arguments);\n    }\n  };\n  DateTimeFormatterBuilder.prototype._appendValue1 = function _appendValue1(field) {\n    requireNonNull(field);\n    this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH$1, SignStyle.NORMAL));\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype._appendValue2 = function _appendValue2(field, width) {\n    requireNonNull(field);\n    if (width < 1 || width > MAX_WIDTH$1) {\n      throw new IllegalArgumentException('The width must be from 1 to ' + MAX_WIDTH$1 + ' inclusive but was ' + width);\n    }\n    var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);\n    this._appendValuePrinterParser(pp);\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {\n    requireNonNull(field);\n    requireNonNull(signStyle);\n    if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {\n      return this._appendValue2(field, maxWidth);\n    }\n    if (minWidth < 1 || minWidth > MAX_WIDTH$1) {\n      throw new IllegalArgumentException('The minimum width must be from 1 to ' + MAX_WIDTH$1 + ' inclusive but was ' + minWidth);\n    }\n    if (maxWidth < 1 || maxWidth > MAX_WIDTH$1) {\n      throw new IllegalArgumentException('The minimum width must be from 1 to ' + MAX_WIDTH$1 + ' inclusive but was ' + maxWidth);\n    }\n    if (maxWidth < minWidth) {\n      throw new IllegalArgumentException('The maximum width must exceed or equal the minimum width but ' + maxWidth + ' < ' + minWidth);\n    }\n    var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);\n    this._appendValuePrinterParser(pp);\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.appendValueReduced = function appendValueReduced() {\n    if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {\n      return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);\n    } else {\n      return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);\n    }\n  };\n  DateTimeFormatterBuilder.prototype._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {\n    requireNonNull(field, 'field');\n    var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);\n    this._appendValuePrinterParser(pp);\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {\n    requireNonNull(field, 'field');\n    requireNonNull(baseDate, 'baseDate');\n    requireInstance(baseDate, ChronoLocalDate, 'baseDate');\n    var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);\n    this._appendValuePrinterParser(pp);\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype._appendValuePrinterParser = function _appendValuePrinterParser(pp) {\n    assert(pp != null);\n    if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {\n      var activeValueParser = this._active._valueParserIndex;\n      var basePP = this._active._printerParsers[activeValueParser];\n      if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {\n        basePP = basePP.withSubsequentWidth(pp.maxWidth());\n        this._appendInternal(pp.withFixedWidth());\n        this._active._valueParserIndex = activeValueParser;\n      } else {\n        basePP = basePP.withFixedWidth();\n        this._active._valueParserIndex = this._appendInternal(pp);\n      }\n      this._active._printerParsers[activeValueParser] = basePP;\n    } else {\n      this._active._valueParserIndex = this._appendInternal(pp);\n    }\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {\n    this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.appendInstant = function appendInstant() {\n    var fractionalDigits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -2;\n    if (fractionalDigits < -2 || fractionalDigits > 9) {\n      throw new IllegalArgumentException('Invalid fractional digits: ' + fractionalDigits);\n    }\n    this._appendInternal(new InstantPrinterParser(fractionalDigits));\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.appendOffsetId = function appendOffsetId() {\n    this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.appendOffset = function appendOffset(pattern, noOffsetText) {\n    this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.appendZoneId = function appendZoneId() {\n    this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), 'ZoneId()'));\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.appendPattern = function appendPattern(pattern) {\n    requireNonNull(pattern, 'pattern');\n    this._parsePattern(pattern);\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.appendZoneText = function appendZoneText() {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n  };\n  DateTimeFormatterBuilder.prototype.appendText = function appendText() {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n  };\n  DateTimeFormatterBuilder.prototype.appendLocalizedOffset = function appendLocalizedOffset() {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n  };\n  DateTimeFormatterBuilder.prototype.appendWeekField = function appendWeekField() {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n  };\n  DateTimeFormatterBuilder.prototype._parsePattern = function _parsePattern(pattern) {\n    var FIELD_MAP = {\n      'G': ChronoField.ERA,\n      'y': ChronoField.YEAR_OF_ERA,\n      'u': ChronoField.YEAR,\n      'Q': IsoFields.QUARTER_OF_YEAR,\n      'q': IsoFields.QUARTER_OF_YEAR,\n      'M': ChronoField.MONTH_OF_YEAR,\n      'L': ChronoField.MONTH_OF_YEAR,\n      'D': ChronoField.DAY_OF_YEAR,\n      'd': ChronoField.DAY_OF_MONTH,\n      'F': ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,\n      'E': ChronoField.DAY_OF_WEEK,\n      'c': ChronoField.DAY_OF_WEEK,\n      'e': ChronoField.DAY_OF_WEEK,\n      'a': ChronoField.AMPM_OF_DAY,\n      'H': ChronoField.HOUR_OF_DAY,\n      'k': ChronoField.CLOCK_HOUR_OF_DAY,\n      'K': ChronoField.HOUR_OF_AMPM,\n      'h': ChronoField.CLOCK_HOUR_OF_AMPM,\n      'm': ChronoField.MINUTE_OF_HOUR,\n      's': ChronoField.SECOND_OF_MINUTE,\n      'S': ChronoField.NANO_OF_SECOND,\n      'A': ChronoField.MILLI_OF_DAY,\n      'n': ChronoField.NANO_OF_SECOND,\n      'N': ChronoField.NANO_OF_DAY\n    };\n    for (var pos = 0; pos < pattern.length; pos++) {\n      var cur = pattern.charAt(pos);\n      if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {\n        var start = pos++;\n        for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) {}\n        var count = pos - start;\n        if (cur === 'p') {\n          var pad = 0;\n          if (pos < pattern.length) {\n            cur = pattern.charAt(pos);\n            if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {\n              pad = count;\n              start = pos++;\n              for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) {}\n              count = pos - start;\n            }\n          }\n          if (pad === 0) {\n            throw new IllegalArgumentException('Pad letter \\'p\\' must be followed by valid pad pattern: ' + pattern);\n          }\n          this.padNext(pad);\n        }\n        var field = FIELD_MAP[cur];\n        if (field != null) {\n          this._parseField(cur, count, field);\n        } else if (cur === 'z') {\n          if (count > 4) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          } else if (count === 4) {\n            this.appendZoneText(TextStyle.FULL);\n          } else {\n            this.appendZoneText(TextStyle.SHORT);\n          }\n        } else if (cur === 'V') {\n          if (count !== 2) {\n            throw new IllegalArgumentException('Pattern letter count must be 2: ' + cur);\n          }\n          this.appendZoneId();\n        } else if (cur === 'Z') {\n          if (count < 4) {\n            this.appendOffset('+HHMM', '+0000');\n          } else if (count === 4) {\n            this.appendLocalizedOffset(TextStyle.FULL);\n          } else if (count === 5) {\n            this.appendOffset('+HH:MM:ss', 'Z');\n          } else {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n        } else if (cur === 'O') {\n          if (count === 1) {\n            this.appendLocalizedOffset(TextStyle.SHORT);\n          } else if (count === 4) {\n            this.appendLocalizedOffset(TextStyle.FULL);\n          } else {\n            throw new IllegalArgumentException('Pattern letter count must be 1 or 4: ' + cur);\n          }\n        } else if (cur === 'X') {\n          if (count > 5) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], 'Z');\n        } else if (cur === 'x') {\n          if (count > 5) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n          var zero = count === 1 ? '+00' : count % 2 === 0 ? '+0000' : '+00:00';\n          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);\n        } else if (cur === 'W') {\n          if (count > 1) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n          this.appendWeekField('W', count);\n        } else if (cur === 'w') {\n          if (count > 2) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n          this.appendWeekField('w', count);\n        } else if (cur === 'Y') {\n          this.appendWeekField('Y', count);\n        } else {\n          throw new IllegalArgumentException('Unknown pattern letter: ' + cur);\n        }\n        pos--;\n      } else if (cur === '\\'') {\n        var _start = pos++;\n        for (; pos < pattern.length; pos++) {\n          if (pattern.charAt(pos) === '\\'') {\n            if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === '\\'') {\n              pos++;\n            } else {\n              break;\n            }\n          }\n        }\n        if (pos >= pattern.length) {\n          throw new IllegalArgumentException('Pattern ends with an incomplete string literal: ' + pattern);\n        }\n        var str = pattern.substring(_start + 1, pos);\n        if (str.length === 0) {\n          this.appendLiteral('\\'');\n        } else {\n          this.appendLiteral(str.replace('\\'\\'', '\\''));\n        }\n      } else if (cur === '[') {\n        this.optionalStart();\n      } else if (cur === ']') {\n        if (this._active._parent === null) {\n          throw new IllegalArgumentException('Pattern invalid as it contains ] without previous [');\n        }\n        this.optionalEnd();\n      } else if (cur === '{' || cur === '}' || cur === '#') {\n        throw new IllegalArgumentException('Pattern includes reserved character: \\'' + cur + '\\'');\n      } else {\n        this.appendLiteral(cur);\n      }\n    }\n  };\n  DateTimeFormatterBuilder.prototype._parseField = function _parseField(cur, count, field) {\n    switch (cur) {\n      case 'u':\n      case 'y':\n        if (count === 2) {\n          this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);\n        } else if (count < 4) {\n          this.appendValue(field, count, MAX_WIDTH$1, SignStyle.NORMAL);\n        } else {\n          this.appendValue(field, count, MAX_WIDTH$1, SignStyle.EXCEEDS_PAD);\n        }\n        break;\n      case 'M':\n      case 'Q':\n        switch (count) {\n          case 1:\n            this.appendValue(field);\n            break;\n          case 2:\n            this.appendValue(field, 2);\n            break;\n          case 3:\n            this.appendText(field, TextStyle.SHORT);\n            break;\n          case 4:\n            this.appendText(field, TextStyle.FULL);\n            break;\n          case 5:\n            this.appendText(field, TextStyle.NARROW);\n            break;\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n        break;\n      case 'L':\n      case 'q':\n        switch (count) {\n          case 1:\n            this.appendValue(field);\n            break;\n          case 2:\n            this.appendValue(field, 2);\n            break;\n          case 3:\n            this.appendText(field, TextStyle.SHORT_STANDALONE);\n            break;\n          case 4:\n            this.appendText(field, TextStyle.FULL_STANDALONE);\n            break;\n          case 5:\n            this.appendText(field, TextStyle.NARROW_STANDALONE);\n            break;\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n        break;\n      case 'e':\n        switch (count) {\n          case 1:\n          case 2:\n            this.appendWeekField('e', count);\n            break;\n          case 3:\n            this.appendText(field, TextStyle.SHORT);\n            break;\n          case 4:\n            this.appendText(field, TextStyle.FULL);\n            break;\n          case 5:\n            this.appendText(field, TextStyle.NARROW);\n            break;\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n        break;\n      case 'c':\n        switch (count) {\n          case 1:\n            this.appendWeekField('c', count);\n            break;\n          case 2:\n            throw new IllegalArgumentException('Invalid number of pattern letters: ' + cur);\n          case 3:\n            this.appendText(field, TextStyle.SHORT_STANDALONE);\n            break;\n          case 4:\n            this.appendText(field, TextStyle.FULL_STANDALONE);\n            break;\n          case 5:\n            this.appendText(field, TextStyle.NARROW_STANDALONE);\n            break;\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n        break;\n      case 'a':\n        if (count === 1) {\n          this.appendText(field, TextStyle.SHORT);\n        } else {\n          throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n        break;\n      case 'E':\n      case 'G':\n        switch (count) {\n          case 1:\n          case 2:\n          case 3:\n            this.appendText(field, TextStyle.SHORT);\n            break;\n          case 4:\n            this.appendText(field, TextStyle.FULL);\n            break;\n          case 5:\n            this.appendText(field, TextStyle.NARROW);\n            break;\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n        break;\n      case 'S':\n        this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);\n        break;\n      case 'F':\n        if (count === 1) {\n          this.appendValue(field);\n        } else {\n          throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n        break;\n      case 'd':\n      case 'h':\n      case 'H':\n      case 'k':\n      case 'K':\n      case 'm':\n      case 's':\n        if (count === 1) {\n          this.appendValue(field);\n        } else if (count === 2) {\n          this.appendValue(field, count);\n        } else {\n          throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n        break;\n      case 'D':\n        if (count === 1) {\n          this.appendValue(field);\n        } else if (count <= 3) {\n          this.appendValue(field, count);\n        } else {\n          throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n        break;\n      default:\n        if (count === 1) {\n          this.appendValue(field);\n        } else {\n          this.appendValue(field, count);\n        }\n        break;\n    }\n  };\n  DateTimeFormatterBuilder.prototype.padNext = function padNext() {\n    if (arguments.length === 1) {\n      return this._padNext1.apply(this, arguments);\n    } else {\n      return this._padNext2.apply(this, arguments);\n    }\n  };\n  DateTimeFormatterBuilder.prototype._padNext1 = function _padNext1(padWidth) {\n    return this._padNext2(padWidth, ' ');\n  };\n  DateTimeFormatterBuilder.prototype._padNext2 = function _padNext2(padWidth, padChar) {\n    if (padWidth < 1) {\n      throw new IllegalArgumentException('The pad width must be at least one but was ' + padWidth);\n    }\n    this._active._padNextWidth = padWidth;\n    this._active._padNextChar = padChar;\n    this._active._valueParserIndex = -1;\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.optionalStart = function optionalStart() {\n    this._active._valueParserIndex = -1;\n    this._active = DateTimeFormatterBuilder._of(this._active, true);\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.optionalEnd = function optionalEnd() {\n    if (this._active._parent == null) {\n      throw new IllegalStateException('Cannot call optionalEnd() as there was no previous call to optionalStart()');\n    }\n    if (this._active._printerParsers.length > 0) {\n      var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);\n      this._active = this._active._parent;\n      this._appendInternal(cpp);\n    } else {\n      this._active = this._active._parent;\n    }\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype._appendInternal = function _appendInternal(pp) {\n    assert(pp != null);\n    if (this._active._padNextWidth > 0) {\n      if (pp != null) {\n        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n      }\n      this._active._padNextWidth = 0;\n      this._active._padNextChar = 0;\n    }\n    this._active._printerParsers.push(pp);\n    this._active._valueParserIndex = -1;\n    return this._active._printerParsers.length - 1;\n  };\n  DateTimeFormatterBuilder.prototype.appendLiteral = function appendLiteral(literal) {\n    assert(literal != null);\n    if (literal.length > 0) {\n      if (literal.length === 1) {\n        this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));\n      } else {\n        this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));\n      }\n    }\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {\n    assert(pp != null);\n    if (this._active._padNextWidth > 0) {\n      if (pp != null) {\n        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n      }\n      this._active._padNextWidth = 0;\n      this._active._padNextChar = 0;\n    }\n    this._active._printerParsers.push(pp);\n    this._active._valueParserIndex = -1;\n    return this._active._printerParsers.length - 1;\n  };\n  DateTimeFormatterBuilder.prototype.append = function append(formatter) {\n    requireNonNull(formatter, 'formatter');\n    this._appendInternal(formatter._toPrinterParser(false));\n    return this;\n  };\n  DateTimeFormatterBuilder.prototype.toFormatter = function toFormatter() {\n    var resolverStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ResolverStyle.SMART;\n    while (this._active._parent != null) {\n      this.optionalEnd();\n    }\n    var pp = new CompositePrinterParser(this._printerParsers, false);\n    return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);\n  };\n  return DateTimeFormatterBuilder;\n}();\nvar SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;\nvar SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;\nvar InstantPrinterParser = function () {\n  function InstantPrinterParser(fractionalDigits) {\n    _classCallCheck$H(this, InstantPrinterParser);\n    this.fractionalDigits = fractionalDigits;\n  }\n  InstantPrinterParser.prototype.print = function print(context, buf) {\n    var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);\n    var inNanos = 0;\n    if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {\n      inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);\n    }\n    if (inSecs == null) {\n      return false;\n    }\n    var inSec = inSecs;\n    var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);\n    if (inSec >= -SECONDS_0000_TO_1970) {\n      var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;\n      var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;\n      var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);\n      var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n      if (hi > 0) {\n        buf.append('+').append(hi);\n      }\n      buf.append(ldt);\n      if (ldt.second() === 0) {\n        buf.append(':00');\n      }\n    } else {\n      var _zeroSecs = inSec + SECONDS_0000_TO_1970;\n      var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);\n      var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);\n      var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n      var pos = buf.length();\n      buf.append(_ldt);\n      if (_ldt.second() === 0) {\n        buf.append(':00');\n      }\n      if (_hi < 0) {\n        if (_ldt.year() === -10000) {\n          buf.replace(pos, pos + 2, '' + (_hi - 1));\n        } else if (_lo === 0) {\n          buf.insert(pos, _hi);\n        } else {\n          buf.insert(pos + 1, Math.abs(_hi));\n        }\n      }\n    }\n    if (this.fractionalDigits === -2) {\n      if (inNano !== 0) {\n        buf.append('.');\n        if (MathUtil.intMod(inNano, 1000000) === 0) {\n          buf.append(('' + (MathUtil.intDiv(inNano, 1000000) + 1000)).substring(1));\n        } else if (MathUtil.intMod(inNano, 1000) === 0) {\n          buf.append(('' + (MathUtil.intDiv(inNano, 1000) + 1000000)).substring(1));\n        } else {\n          buf.append(('' + (inNano + 1000000000)).substring(1));\n        }\n      }\n    } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {\n      buf.append('.');\n      var div = 100000000;\n      for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {\n        var digit = MathUtil.intDiv(inNano, div);\n        buf.append(digit);\n        inNano = inNano - digit * div;\n        div = MathUtil.intDiv(div, 10);\n      }\n    }\n    buf.append('Z');\n    return true;\n  };\n  InstantPrinterParser.prototype.parse = function parse(context, text, position) {\n    var newContext = context.copy();\n    var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;\n    var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;\n    var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral('Z').toFormatter()._toPrinterParser(false);\n    var pos = parser.parse(newContext, text, position);\n    if (pos < 0) {\n      return pos;\n    }\n    var yearParsed = newContext.getParsed(ChronoField.YEAR);\n    var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);\n    var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);\n    var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);\n    var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);\n    var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);\n    var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);\n    var sec = secVal != null ? secVal : 0;\n    var nano = nanoVal != null ? nanoVal : 0;\n    var year = MathUtil.intMod(yearParsed, 10000);\n    var days = 0;\n    if (hour === 24 && min === 0 && sec === 0 && nano === 0) {\n      hour = 0;\n      days = 1;\n    } else if (hour === 23 && min === 59 && sec === 60) {\n      context.setParsedLeapSecond();\n      sec = 59;\n    }\n    var instantSecs = void 0;\n    try {\n      var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);\n      instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);\n      instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);\n    } catch (ex) {\n      return ~position;\n    }\n    var successPos = pos;\n    successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);\n    return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);\n  };\n  InstantPrinterParser.prototype.toString = function toString() {\n    return 'Instant()';\n  };\n  return InstantPrinterParser;\n}();\nfunction _init$9() {\n  ReducedPrinterParser.BASE_DATE = LocalDate.of(2000, 1, 1);\n  DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;\n  DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;\n  DateTimeFormatterBuilder.SettingsParser = SettingsParser;\n  DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;\n  DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;\n  DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;\n  DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;\n  DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;\n  DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;\n  DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;\n  DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;\n}\nfunction _classCallCheck$I(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar StringBuilder = function () {\n  function StringBuilder() {\n    _classCallCheck$I(this, StringBuilder);\n    this._str = '';\n  }\n  StringBuilder.prototype.append = function append(str) {\n    this._str += str;\n    return this;\n  };\n  StringBuilder.prototype.appendChar = function appendChar(str) {\n    this._str += str[0];\n    return this;\n  };\n  StringBuilder.prototype.insert = function insert(offset, str) {\n    this._str = this._str.slice(0, offset) + str + this._str.slice(offset);\n    return this;\n  };\n  StringBuilder.prototype.replace = function replace(start, end, str) {\n    this._str = this._str.slice(0, start) + str + this._str.slice(end);\n    return this;\n  };\n  StringBuilder.prototype.length = function length() {\n    return this._str.length;\n  };\n  StringBuilder.prototype.setLength = function setLength(length) {\n    this._str = this._str.slice(0, length);\n    return this;\n  };\n  StringBuilder.prototype.toString = function toString() {\n    return this._str;\n  };\n  return StringBuilder;\n}();\nfunction _classCallCheck$J(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar DateTimeFormatter = function () {\n  DateTimeFormatter.parsedExcessDays = function parsedExcessDays() {\n    return DateTimeFormatter.PARSED_EXCESS_DAYS;\n  };\n  DateTimeFormatter.parsedLeapSecond = function parsedLeapSecond() {\n    return DateTimeFormatter.PARSED_LEAP_SECOND;\n  };\n  DateTimeFormatter.ofPattern = function ofPattern(pattern) {\n    return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n  };\n  function DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields) {\n    var chrono = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : IsoChronology.INSTANCE;\n    var zone = arguments[6];\n    _classCallCheck$J(this, DateTimeFormatter);\n    assert(printerParser != null);\n    assert(decimalStyle != null);\n    assert(resolverStyle != null);\n    this._printerParser = printerParser;\n    this._locale = locale;\n    this._decimalStyle = decimalStyle;\n    this._resolverStyle = resolverStyle;\n    this._resolverFields = resolverFields;\n    this._chrono = chrono;\n    this._zone = zone;\n  }\n  DateTimeFormatter.prototype.locale = function locale() {\n    return this._locale;\n  };\n  DateTimeFormatter.prototype.decimalStyle = function decimalStyle() {\n    return this._decimalStyle;\n  };\n  DateTimeFormatter.prototype.chronology = function chronology() {\n    return this._chrono;\n  };\n  DateTimeFormatter.prototype.withChronology = function withChronology(chrono) {\n    if (this._chrono != null && this._chrono.equals(chrono)) {\n      return this;\n    }\n    return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);\n  };\n  DateTimeFormatter.prototype.withLocale = function withLocale() {\n    return this;\n  };\n  DateTimeFormatter.prototype.withResolverStyle = function withResolverStyle(resolverStyle) {\n    requireNonNull(resolverStyle, 'resolverStyle');\n    if (resolverStyle.equals(this._resolverStyle)) {\n      return this;\n    }\n    return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);\n  };\n  DateTimeFormatter.prototype.format = function format(temporal) {\n    var buf = new StringBuilder(32);\n    this._formatTo(temporal, buf);\n    return buf.toString();\n  };\n  DateTimeFormatter.prototype._formatTo = function _formatTo(temporal, appendable) {\n    requireNonNull(temporal, 'temporal');\n    requireNonNull(appendable, 'appendable');\n    var context = new DateTimePrintContext(temporal, this);\n    this._printerParser.print(context, appendable);\n  };\n  DateTimeFormatter.prototype.parse = function parse(text, type) {\n    if (arguments.length === 1) {\n      return this.parse1(text);\n    } else {\n      return this.parse2(text, type);\n    }\n  };\n  DateTimeFormatter.prototype.parse1 = function parse1(text) {\n    requireNonNull(text, 'text');\n    try {\n      return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n    } catch (ex) {\n      if (ex instanceof DateTimeParseException) {\n        throw ex;\n      } else {\n        throw this._createError(text, ex);\n      }\n    }\n  };\n  DateTimeFormatter.prototype.parse2 = function parse2(text, type) {\n    requireNonNull(text, 'text');\n    requireNonNull(type, 'type');\n    try {\n      var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n      return builder.build(type);\n    } catch (ex) {\n      if (ex instanceof DateTimeParseException) {\n        throw ex;\n      } else {\n        throw this._createError(text, ex);\n      }\n    }\n  };\n  DateTimeFormatter.prototype._createError = function _createError(text, ex) {\n    var abbr = '';\n    if (text.length > 64) {\n      abbr = text.substring(0, 64) + '...';\n    } else {\n      abbr = text;\n    }\n    return new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed: ' + ex.message, text, 0, ex);\n  };\n  DateTimeFormatter.prototype._parseToBuilder = function _parseToBuilder(text, position) {\n    var pos = position != null ? position : new ParsePosition(0);\n    var result = this._parseUnresolved0(text, pos);\n    if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {\n      var abbr = '';\n      if (text.length > 64) {\n        abbr = text.substr(0, 64).toString() + '...';\n      } else {\n        abbr = text;\n      }\n      if (pos.getErrorIndex() >= 0) {\n        throw new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed at index ' + pos.getErrorIndex(), text, pos.getErrorIndex());\n      } else {\n        throw new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed, unparsed text found at index ' + pos.getIndex(), text, pos.getIndex());\n      }\n    }\n    return result.toBuilder();\n  };\n  DateTimeFormatter.prototype.parseUnresolved = function parseUnresolved(text, position) {\n    return this._parseUnresolved0(text, position);\n  };\n  DateTimeFormatter.prototype._parseUnresolved0 = function _parseUnresolved0(text, position) {\n    assert(text != null, 'text', NullPointerException);\n    assert(position != null, 'position', NullPointerException);\n    var context = new DateTimeParseContext(this);\n    var pos = position.getIndex();\n    pos = this._printerParser.parse(context, text, pos);\n    if (pos < 0) {\n      position.setErrorIndex(~pos);\n      return null;\n    }\n    position.setIndex(pos);\n    return context.toParsed();\n  };\n  DateTimeFormatter.prototype._toPrinterParser = function _toPrinterParser(optional) {\n    return this._printerParser.withOptional(optional);\n  };\n  DateTimeFormatter.prototype.toString = function toString() {\n    var pattern = this._printerParser.toString();\n    return pattern.indexOf('[') === 0 ? pattern : pattern.substring(1, pattern.length - 1);\n  };\n  return DateTimeFormatter;\n}();\nfunction _init$a() {\n  DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);\n  DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);\n  DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral('[').parseCaseSensitive().appendZoneId().appendLiteral(']').toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery('PARSED_EXCESS_DAYS', function (temporal) {\n    if (temporal instanceof DateTimeBuilder) {\n      return temporal.excessDays;\n    } else {\n      return Period.ZERO;\n    }\n  });\n  DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery('PARSED_LEAP_SECOND', function (temporal) {\n    if (temporal instanceof DateTimeBuilder) {\n      return temporal.leapSecond;\n    } else {\n      return false;\n    }\n  });\n}\nfunction _classCallCheck$K(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$k(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$k(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar MonthDay = function (_Temporal) {\n  _inherits$k(MonthDay, _Temporal);\n  MonthDay.now = function now(zoneIdOrClock) {\n    if (arguments.length === 0) {\n      return MonthDay.now0();\n    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n      return MonthDay.nowZoneId(zoneIdOrClock);\n    } else {\n      return MonthDay.nowClock(zoneIdOrClock);\n    }\n  };\n  MonthDay.now0 = function now0() {\n    return this.nowClock(Clock.systemDefaultZone());\n  };\n  MonthDay.nowZoneId = function nowZoneId(zone) {\n    requireNonNull(zone, 'zone');\n    return this.nowClock(Clock.system(zone));\n  };\n  MonthDay.nowClock = function nowClock(clock) {\n    requireNonNull(clock, 'clock');\n    var now = LocalDate.now(clock);\n    return MonthDay.of(now.month(), now.dayOfMonth());\n  };\n  MonthDay.of = function of(monthOrNumber, number) {\n    if (arguments.length === 2 && monthOrNumber instanceof Month) {\n      return MonthDay.ofMonthNumber(monthOrNumber, number);\n    } else {\n      return MonthDay.ofNumberNumber(monthOrNumber, number);\n    }\n  };\n  MonthDay.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {\n    requireNonNull(month, 'month');\n    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n    if (dayOfMonth > month.maxLength()) {\n      throw new DateTimeException('Illegal value for DayOfMonth field, value ' + dayOfMonth + ' is not valid for month ' + month.toString());\n    }\n    return new MonthDay(month.value(), dayOfMonth);\n  };\n  MonthDay.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {\n    requireNonNull(month, 'month');\n    requireNonNull(dayOfMonth, 'dayOfMonth');\n    return MonthDay.of(Month.of(month), dayOfMonth);\n  };\n  MonthDay.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    requireInstance(temporal, TemporalAccessor, 'temporal');\n    if (temporal instanceof MonthDay) {\n      return temporal;\n    }\n    try {\n      return MonthDay.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain MonthDay from TemporalAccessor: ' + temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n  MonthDay.parse = function parse(text, formatter) {\n    if (arguments.length === 1) {\n      return MonthDay.parseString(text);\n    } else {\n      return MonthDay.parseStringFormatter(text, formatter);\n    }\n  };\n  MonthDay.parseString = function parseString(text) {\n    return MonthDay.parseStringFormatter(text, PARSER);\n  };\n  MonthDay.parseStringFormatter = function parseStringFormatter(text, formatter) {\n    requireNonNull(text, 'text');\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.parse(text, MonthDay.FROM);\n  };\n  function MonthDay(month, dayOfMonth) {\n    _classCallCheck$K(this, MonthDay);\n    var _this = _possibleConstructorReturn$k(this, _Temporal.call(this));\n    _this._month = MathUtil.safeToInt(month);\n    _this._day = MathUtil.safeToInt(dayOfMonth);\n    return _this;\n  }\n  MonthDay.prototype.monthValue = function monthValue() {\n    return this._month;\n  };\n  MonthDay.prototype.month = function month() {\n    return Month.of(this._month);\n  };\n  MonthDay.prototype.dayOfMonth = function dayOfMonth() {\n    return this._day;\n  };\n  MonthDay.prototype.isSupported = function isSupported(field) {\n    if (field instanceof ChronoField) {\n      return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;\n    }\n    return field != null && field.isSupportedBy(this);\n  };\n  MonthDay.prototype.range = function range(field) {\n    if (field === ChronoField.MONTH_OF_YEAR) {\n      return field.range();\n    } else if (field === ChronoField.DAY_OF_MONTH) {\n      return ValueRange.of(1, this.month().minLength(), this.month().maxLength());\n    }\n    return _Temporal.prototype.range.call(this, field);\n  };\n  MonthDay.prototype.get = function get(field) {\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n  MonthDay.prototype.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.DAY_OF_MONTH:\n          return this._day;\n        case ChronoField.MONTH_OF_YEAR:\n          return this._month;\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.getFrom(this);\n  };\n  MonthDay.prototype.isValidYear = function isValidYear(year) {\n    return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;\n  };\n  MonthDay.prototype.withMonth = function withMonth(month) {\n    return this.with(Month.of(month));\n  };\n  MonthDay.prototype.with = function _with(month) {\n    requireNonNull(month, 'month');\n    if (month.value() === this._month) {\n      return this;\n    }\n    var day = Math.min(this._day, month.maxLength());\n    return new MonthDay(month.value(), day);\n  };\n  MonthDay.prototype.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    if (dayOfMonth === this._day) {\n      return this;\n    }\n    return MonthDay.of(this._month, dayOfMonth);\n  };\n  MonthDay.prototype.query = function query(_query) {\n    requireNonNull(_query, 'query');\n    requireInstance(_query, TemporalQuery, 'query');\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    }\n    return _Temporal.prototype.query.call(this, _query);\n  };\n  MonthDay.prototype.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);\n    return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));\n  };\n  MonthDay.prototype.atYear = function atYear(year) {\n    return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);\n  };\n  MonthDay.prototype.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, MonthDay, 'other');\n    var cmp = this._month - other.monthValue();\n    if (cmp === 0) {\n      cmp = this._day - other.dayOfMonth();\n    }\n    return cmp;\n  };\n  MonthDay.prototype.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, MonthDay, 'other');\n    return this.compareTo(other) > 0;\n  };\n  MonthDay.prototype.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, MonthDay, 'other');\n    return this.compareTo(other) < 0;\n  };\n  MonthDay.prototype.equals = function equals(obj) {\n    if (this === obj) {\n      return true;\n    }\n    if (obj instanceof MonthDay) {\n      var other = obj;\n      return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();\n    }\n    return false;\n  };\n  MonthDay.prototype.toString = function toString() {\n    return '--' + (this._month < 10 ? '0' : '') + this._month + (this._day < 10 ? '-0' : '-') + this._day;\n  };\n  MonthDay.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  MonthDay.prototype.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.format(this);\n  };\n  return MonthDay;\n}(Temporal);\nvar PARSER = void 0;\nfunction _init$b() {\n  PARSER = new DateTimeFormatterBuilder().appendLiteral('--').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();\n  MonthDay.FROM = createTemporalQuery('MonthDay.FROM', function (temporal) {\n    return MonthDay.from(temporal);\n  });\n}\nfunction _classCallCheck$L(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$l(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$l(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar YearMonth = function (_Temporal) {\n  _inherits$l(YearMonth, _Temporal);\n  YearMonth.now = function now(zoneIdOrClock) {\n    if (arguments.length === 0) {\n      return YearMonth.now0();\n    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n      return YearMonth.nowZoneId(zoneIdOrClock);\n    } else {\n      return YearMonth.nowClock(zoneIdOrClock);\n    }\n  };\n  YearMonth.now0 = function now0() {\n    return YearMonth.nowClock(Clock.systemDefaultZone());\n  };\n  YearMonth.nowZoneId = function nowZoneId(zone) {\n    return YearMonth.nowClock(Clock.system(zone));\n  };\n  YearMonth.nowClock = function nowClock(clock) {\n    var now = LocalDate.now(clock);\n    return YearMonth.of(now.year(), now.month());\n  };\n  YearMonth.of = function of(year, monthOrNumber) {\n    if (arguments.length === 2 && monthOrNumber instanceof Month) {\n      return YearMonth.ofNumberMonth(year, monthOrNumber);\n    } else {\n      return YearMonth.ofNumberNumber(year, monthOrNumber);\n    }\n  };\n  YearMonth.ofNumberMonth = function ofNumberMonth(year, month) {\n    requireNonNull(month, 'month');\n    requireInstance(month, Month, 'month');\n    return YearMonth.ofNumberNumber(year, month.value());\n  };\n  YearMonth.ofNumberNumber = function ofNumberNumber(year, month) {\n    requireNonNull(year, 'year');\n    requireNonNull(month, 'month');\n    ChronoField.YEAR.checkValidValue(year);\n    ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n    return new YearMonth(year, month);\n  };\n  YearMonth.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    if (temporal instanceof YearMonth) {\n      return temporal;\n    }\n    try {\n      return YearMonth.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain YearMonth from TemporalAccessor: ' + temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n  YearMonth.parse = function parse(text, formatter) {\n    if (arguments.length === 1) {\n      return YearMonth.parseString(text);\n    } else {\n      return YearMonth.parseStringFormatter(text, formatter);\n    }\n  };\n  YearMonth.parseString = function parseString(text) {\n    return YearMonth.parseStringFormatter(text, PARSER$1);\n  };\n  YearMonth.parseStringFormatter = function parseStringFormatter(text, formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, YearMonth.FROM);\n  };\n  function YearMonth(year, month) {\n    _classCallCheck$L(this, YearMonth);\n    var _this = _possibleConstructorReturn$l(this, _Temporal.call(this));\n    _this._year = MathUtil.safeToInt(year);\n    _this._month = MathUtil.safeToInt(month);\n    return _this;\n  }\n  YearMonth.prototype.isSupported = function isSupported(fieldOrUnit) {\n    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n      return this.isSupportedField(fieldOrUnit);\n    } else {\n      return this.isSupportedUnit(fieldOrUnit);\n    }\n  };\n  YearMonth.prototype.isSupportedField = function isSupportedField(field) {\n    if (field instanceof ChronoField) {\n      return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n    }\n    return field != null && field.isSupportedBy(this);\n  };\n  YearMonth.prototype.isSupportedUnit = function isSupportedUnit(unit) {\n    if (unit instanceof ChronoUnit) {\n      return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n    }\n    return unit != null && unit.isSupportedBy(this);\n  };\n  YearMonth.prototype.range = function range(field) {\n    if (field === ChronoField.YEAR_OF_ERA) {\n      return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);\n    }\n    return _Temporal.prototype.range.call(this, field);\n  };\n  YearMonth.prototype.get = function get(field) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n  YearMonth.prototype.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.MONTH_OF_YEAR:\n          return this._month;\n        case ChronoField.PROLEPTIC_MONTH:\n          return this._getProlepticMonth();\n        case ChronoField.YEAR_OF_ERA:\n          return this._year < 1 ? 1 - this._year : this._year;\n        case ChronoField.YEAR:\n          return this._year;\n        case ChronoField.ERA:\n          return this._year < 1 ? 0 : 1;\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.getFrom(this);\n  };\n  YearMonth.prototype._getProlepticMonth = function _getProlepticMonth() {\n    return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);\n  };\n  YearMonth.prototype.year = function year() {\n    return this._year;\n  };\n  YearMonth.prototype.monthValue = function monthValue() {\n    return this._month;\n  };\n  YearMonth.prototype.month = function month() {\n    return Month.of(this._month);\n  };\n  YearMonth.prototype.isLeapYear = function isLeapYear() {\n    return IsoChronology.isLeapYear(this._year);\n  };\n  YearMonth.prototype.isValidDay = function isValidDay(dayOfMonth) {\n    return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();\n  };\n  YearMonth.prototype.lengthOfMonth = function lengthOfMonth() {\n    return this.month().length(this.isLeapYear());\n  };\n  YearMonth.prototype.lengthOfYear = function lengthOfYear() {\n    return this.isLeapYear() ? 366 : 365;\n  };\n  YearMonth.prototype.with = function _with(adjusterOrFieldOrNumber, value) {\n    if (arguments.length === 1) {\n      return this.withAdjuster(adjusterOrFieldOrNumber);\n    } else if (arguments.length === 2 && adjusterOrFieldOrNumber instanceof TemporalField) {\n      return this.withFieldValue(adjusterOrFieldOrNumber, value);\n    } else {\n      return this.withYearMonth(adjusterOrFieldOrNumber, value);\n    }\n  };\n  YearMonth.prototype.withYearMonth = function withYearMonth(newYear, newMonth) {\n    requireNonNull(newYear);\n    requireNonNull(newMonth);\n    if (this._year === newYear && this._month === newMonth) {\n      return this;\n    }\n    return new YearMonth(newYear, newMonth);\n  };\n  YearMonth.prototype.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n  YearMonth.prototype.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n    if (field instanceof ChronoField) {\n      var f = field;\n      f.checkValidValue(newValue);\n      switch (f) {\n        case ChronoField.MONTH_OF_YEAR:\n          return this.withMonth(newValue);\n        case ChronoField.PROLEPTIC_MONTH:\n          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n        case ChronoField.YEAR_OF_ERA:\n          return this.withYear(this._year < 1 ? 1 - newValue : newValue);\n        case ChronoField.YEAR:\n          return this.withYear(newValue);\n        case ChronoField.ERA:\n          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.adjustInto(this, newValue);\n  };\n  YearMonth.prototype.withYear = function withYear(year) {\n    ChronoField.YEAR.checkValidValue(year);\n    return this.withYearMonth(year, this._month);\n  };\n  YearMonth.prototype.withMonth = function withMonth(month) {\n    ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n    return this.withYearMonth(this._year, month);\n  };\n  YearMonth.prototype.plus = function plus(amountOrNumber, unit) {\n    if (arguments.length === 1) {\n      return this.plusAmount(amountOrNumber);\n    } else {\n      return this.plusAmountUnit(amountOrNumber, unit);\n    }\n  };\n  YearMonth.prototype.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.addTo(this);\n  };\n  YearMonth.prototype.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit, 'unit');\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.MONTHS:\n          return this.plusMonths(amountToAdd);\n        case ChronoUnit.YEARS:\n          return this.plusYears(amountToAdd);\n        case ChronoUnit.DECADES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n        case ChronoUnit.CENTURIES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n        case ChronoUnit.MILLENNIA:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n        case ChronoUnit.ERAS:\n          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n    return unit.addTo(this, amountToAdd);\n  };\n  YearMonth.prototype.plusYears = function plusYears(yearsToAdd) {\n    if (yearsToAdd === 0) {\n      return this;\n    }\n    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);\n    return this.withYearMonth(newYear, this._month);\n  };\n  YearMonth.prototype.plusMonths = function plusMonths(monthsToAdd) {\n    if (monthsToAdd === 0) {\n      return this;\n    }\n    var monthCount = this._year * 12 + (this._month - 1);\n    var calcMonths = monthCount + monthsToAdd;\n    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n    return this.withYearMonth(newYear, newMonth);\n  };\n  YearMonth.prototype.minus = function minus(amountOrNumber, unit) {\n    if (arguments.length === 1) {\n      return this.minusAmount(amountOrNumber);\n    } else {\n      return this.minusAmountUnit(amountOrNumber, unit);\n    }\n  };\n  YearMonth.prototype.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n  YearMonth.prototype.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    return amountToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusAmountUnit(MathUtil.MAX_SAFE_INTEGER, unit).plusAmountUnit(1, unit) : this.plusAmountUnit(-amountToSubtract, unit);\n  };\n  YearMonth.prototype.minusYears = function minusYears(yearsToSubtract) {\n    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);\n  };\n  YearMonth.prototype.minusMonths = function minusMonths(monthsToSubtract) {\n    return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);\n  };\n  YearMonth.prototype.query = function query(_query) {\n    requireNonNull(_query, 'query');\n    requireInstance(_query, TemporalQuery, 'query');\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.MONTHS;\n    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n    return _Temporal.prototype.query.call(this, _query);\n  };\n  YearMonth.prototype.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    requireInstance(temporal, Temporal, 'temporal');\n    return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());\n  };\n  YearMonth.prototype.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    requireInstance(endExclusive, Temporal, 'endExclusive');\n    requireInstance(unit, TemporalUnit, 'unit');\n    var end = YearMonth.from(endExclusive);\n    if (unit instanceof ChronoUnit) {\n      var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();\n      switch (unit) {\n        case ChronoUnit.MONTHS:\n          return monthsUntil;\n        case ChronoUnit.YEARS:\n          return monthsUntil / 12;\n        case ChronoUnit.DECADES:\n          return monthsUntil / 120;\n        case ChronoUnit.CENTURIES:\n          return monthsUntil / 1200;\n        case ChronoUnit.MILLENNIA:\n          return monthsUntil / 12000;\n        case ChronoUnit.ERAS:\n          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n    return unit.between(this, end);\n  };\n  YearMonth.prototype.atDay = function atDay(dayOfMonth) {\n    return LocalDate.of(this._year, this._month, dayOfMonth);\n  };\n  YearMonth.prototype.atEndOfMonth = function atEndOfMonth() {\n    return LocalDate.of(this._year, this._month, this.lengthOfMonth());\n  };\n  YearMonth.prototype.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, YearMonth, 'other');\n    var cmp = this._year - other.year();\n    if (cmp === 0) {\n      cmp = this._month - other.monthValue();\n    }\n    return cmp;\n  };\n  YearMonth.prototype.isAfter = function isAfter(other) {\n    return this.compareTo(other) > 0;\n  };\n  YearMonth.prototype.isBefore = function isBefore(other) {\n    return this.compareTo(other) < 0;\n  };\n  YearMonth.prototype.equals = function equals(obj) {\n    if (this === obj) {\n      return true;\n    }\n    if (obj instanceof YearMonth) {\n      var other = obj;\n      return this.year() === other.year() && this.monthValue() === other.monthValue();\n    }\n    return false;\n  };\n  YearMonth.prototype.toString = function toString() {\n    return PARSER$1.format(this);\n  };\n  YearMonth.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  YearMonth.prototype.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n  return YearMonth;\n}(Temporal);\nvar PARSER$1 = void 0;\nfunction _init$c() {\n  PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();\n  YearMonth.FROM = createTemporalQuery('YearMonth.FROM', function (temporal) {\n    return YearMonth.from(temporal);\n  });\n}\nfunction _classCallCheck$M(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$m(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$m(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar Year = function (_Temporal) {\n  _inherits$m(Year, _Temporal);\n  function Year(value) {\n    _classCallCheck$M(this, Year);\n    var _this = _possibleConstructorReturn$m(this, _Temporal.call(this));\n    _this._year = MathUtil.safeToInt(value);\n    return _this;\n  }\n  Year.prototype.value = function value() {\n    return this._year;\n  };\n  Year.now = function now() {\n    var zoneIdOrClock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    if (zoneIdOrClock === undefined) {\n      return Year.now0();\n    } else if (zoneIdOrClock instanceof ZoneId) {\n      return Year.nowZoneId(zoneIdOrClock);\n    } else {\n      return Year.nowClock(zoneIdOrClock);\n    }\n  };\n  Year.now0 = function now0() {\n    return Year.nowClock(Clock.systemDefaultZone());\n  };\n  Year.nowZoneId = function nowZoneId(zone) {\n    requireNonNull(zone, 'zone');\n    requireInstance(zone, ZoneId, 'zone');\n    return Year.nowClock(Clock.system(zone));\n  };\n  Year.nowClock = function nowClock(clock) {\n    requireNonNull(clock, 'clock');\n    requireInstance(clock, Clock, 'clock');\n    var now = LocalDate.now(clock);\n    return Year.of(now.year());\n  };\n  Year.of = function of(isoYear) {\n    requireNonNull(isoYear, 'isoYear');\n    ChronoField.YEAR.checkValidValue(isoYear);\n    return new Year(isoYear);\n  };\n  Year.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    requireInstance(temporal, TemporalAccessor, 'temporal');\n    if (temporal instanceof Year) {\n      return temporal;\n    }\n    try {\n      return Year.of(temporal.get(ChronoField.YEAR));\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain Year from TemporalAccessor: ' + temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n  Year.parse = function parse(text, formatter) {\n    if (arguments.length <= 1) {\n      return Year.parseText(text);\n    } else {\n      return Year.parseTextFormatter(text, formatter);\n    }\n  };\n  Year.parseText = function parseText(text) {\n    requireNonNull(text, 'text');\n    return Year.parse(text, PARSER$2);\n  };\n  Year.parseTextFormatter = function parseTextFormatter(text) {\n    var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PARSER$2;\n    requireNonNull(text, 'text');\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.parse(text, Year.FROM);\n  };\n  Year.isLeap = function isLeap(year) {\n    return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);\n  };\n  Year.prototype.isSupported = function isSupported(fieldOrUnit) {\n    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n      return this.isSupportedField(fieldOrUnit);\n    } else {\n      return this.isSupportedUnit(fieldOrUnit);\n    }\n  };\n  Year.prototype.isSupportedField = function isSupportedField(field) {\n    if (field instanceof ChronoField) {\n      return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n    }\n    return field != null && field.isSupportedBy(this);\n  };\n  Year.prototype.isSupportedUnit = function isSupportedUnit(unit) {\n    if (unit instanceof ChronoUnit) {\n      return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n    }\n    return unit != null && unit.isSupportedBy(this);\n  };\n  Year.prototype.range = function range(field) {\n    if (this.isSupported(field)) {\n      return field.range();\n    } else if (field instanceof ChronoField) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return _Temporal.prototype.range.call(this, field);\n  };\n  Year.prototype.get = function get(field) {\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n  Year.prototype.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.YEAR_OF_ERA:\n          return this._year < 1 ? 1 - this._year : this._year;\n        case ChronoField.YEAR:\n          return this._year;\n        case ChronoField.ERA:\n          return this._year < 1 ? 0 : 1;\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.getFrom(this);\n  };\n  Year.prototype.isLeap = function isLeap() {\n    return Year.isLeap(this._year);\n  };\n  Year.prototype.with = function _with(adjusterOrFieldOrNumber, value) {\n    if (arguments.length === 2 && adjusterOrFieldOrNumber instanceof TemporalField) {\n      return this.withFieldValue(adjusterOrFieldOrNumber, value);\n    } else {\n      return this.withAdjuster(adjusterOrFieldOrNumber);\n    }\n  };\n  Year.prototype.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n  Year.prototype.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n    if (field instanceof ChronoField) {\n      field.checkValidValue(newValue);\n      switch (field) {\n        case ChronoField.YEAR_OF_ERA:\n          return Year.of(this._year < 1 ? 1 - newValue : newValue);\n        case ChronoField.YEAR:\n          return Year.of(newValue);\n        case ChronoField.ERA:\n          return this.getLong(ChronoField.ERA) === newValue ? this : Year.of(1 - this._year);\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.adjustInto(this, newValue);\n  };\n  Year.prototype.plus = function plus(amountOrNumber, unit) {\n    if (arguments.length === 1) {\n      return this.plusAmount(amountOrNumber);\n    } else {\n      return this.plusAmountToAddUnit(amountOrNumber, unit);\n    }\n  };\n  Year.prototype.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.addTo(this);\n  };\n  Year.prototype.plusAmountToAddUnit = function plusAmountToAddUnit(amountToAdd, unit) {\n    requireNonNull(amountToAdd, 'amountToAdd');\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit, 'unit');\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.YEARS:\n          return this.plusYears(amountToAdd);\n        case ChronoUnit.DECADES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n        case ChronoUnit.CENTURIES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n        case ChronoUnit.MILLENNIA:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n        case ChronoUnit.ERAS:\n          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n    return unit.addTo(this, amountToAdd);\n  };\n  Year.prototype.plusYears = function plusYears(yearsToAdd) {\n    if (yearsToAdd === 0) {\n      return this;\n    }\n    return Year.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));\n  };\n  Year.prototype.minus = function minus(amountOrNumber, unit) {\n    if (arguments.length === 1) {\n      return this.minusAmount(amountOrNumber);\n    } else {\n      return this.minusAmountToSubtractUnit(amountOrNumber, unit);\n    }\n  };\n  Year.prototype.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.subtractFrom(this);\n  };\n  Year.prototype.minusAmountToSubtractUnit = function minusAmountToSubtractUnit(amountToSubtract, unit) {\n    requireNonNull(amountToSubtract, 'amountToSubtract');\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit, 'unit');\n    return amountToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plus(MathUtil.MAX_SAFE_INTEGER, unit).plus(1, unit) : this.plus(-amountToSubtract, unit);\n  };\n  Year.prototype.minusYears = function minusYears(yearsToSubtract) {\n    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);\n  };\n  Year.prototype.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    return temporal.with(ChronoField.YEAR, this._year);\n  };\n  Year.prototype.isValidMonthDay = function isValidMonthDay(monthDay) {\n    return monthDay != null && monthDay.isValidYear(this._year);\n  };\n  Year.prototype.length = function length() {\n    return this.isLeap() ? 366 : 365;\n  };\n  Year.prototype.atDay = function atDay(dayOfYear) {\n    return LocalDate.ofYearDay(this._year, dayOfYear);\n  };\n  Year.prototype.atMonth = function atMonth(monthOrNumber) {\n    if (arguments.length === 1 && monthOrNumber instanceof Month) {\n      return this.atMonthMonth(monthOrNumber);\n    } else {\n      return this.atMonthNumber(monthOrNumber);\n    }\n  };\n  Year.prototype.atMonthMonth = function atMonthMonth(month) {\n    requireNonNull(month, 'month');\n    requireInstance(month, Month, 'month');\n    return YearMonth.of(this._year, month);\n  };\n  Year.prototype.atMonthNumber = function atMonthNumber(month) {\n    requireNonNull(month, 'month');\n    return YearMonth.of(this._year, month);\n  };\n  Year.prototype.atMonthDay = function atMonthDay(monthDay) {\n    requireNonNull(monthDay, 'monthDay');\n    requireInstance(monthDay, MonthDay, 'monthDay');\n    return monthDay.atYear(this._year);\n  };\n  Year.prototype.query = function query(_query) {\n    requireNonNull(_query, 'query()');\n    requireInstance(_query, TemporalQuery, 'query()');\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.YEARS;\n    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n    return _Temporal.prototype.query.call(this, _query);\n  };\n  Year.prototype.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, Year, 'other');\n    return this._year - other._year;\n  };\n  Year.prototype.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, Year, 'other');\n    return this._year > other._year;\n  };\n  Year.prototype.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, Year, 'other');\n    return this._year < other._year;\n  };\n  Year.prototype.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.format(this);\n  };\n  Year.prototype.equals = function equals(otherYear) {\n    if (this === otherYear) {\n      return true;\n    }\n    if (otherYear instanceof Year) {\n      return this.value() === otherYear.value();\n    }\n    return false;\n  };\n  Year.prototype.toString = function toString() {\n    return '' + this._year;\n  };\n  Year.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  return Year;\n}(Temporal);\nvar PARSER$2 = void 0;\nfunction _init$d() {\n  Year.MIN_VALUE = YearConstants.MIN_VALUE;\n  Year.MAX_VALUE = YearConstants.MAX_VALUE;\n  PARSER$2 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();\n  Year.FROM = createTemporalQuery('Year.FROM', function (temporal) {\n    return Year.from(temporal);\n  });\n}\nfunction _classCallCheck$N(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar TemporalAdjuster = function () {\n  function TemporalAdjuster() {\n    _classCallCheck$N(this, TemporalAdjuster);\n  }\n  TemporalAdjuster.prototype.adjustInto = function adjustInto(temporal) {\n    abstractMethodFail('adjustInto');\n  };\n  return TemporalAdjuster;\n}();\nfunction _possibleConstructorReturn$n(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$n(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction _classCallCheck$O(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar TemporalAdjusters = function () {\n  function TemporalAdjusters() {\n    _classCallCheck$O(this, TemporalAdjusters);\n  }\n  TemporalAdjusters.firstDayOfMonth = function firstDayOfMonth() {\n    return Impl.FIRST_DAY_OF_MONTH;\n  };\n  TemporalAdjusters.lastDayOfMonth = function lastDayOfMonth() {\n    return Impl.LAST_DAY_OF_MONTH;\n  };\n  TemporalAdjusters.firstDayOfNextMonth = function firstDayOfNextMonth() {\n    return Impl.FIRST_DAY_OF_NEXT_MONTH;\n  };\n  TemporalAdjusters.firstDayOfYear = function firstDayOfYear() {\n    return Impl.FIRST_DAY_OF_YEAR;\n  };\n  TemporalAdjusters.lastDayOfYear = function lastDayOfYear() {\n    return Impl.LAST_DAY_OF_YEAR;\n  };\n  TemporalAdjusters.firstDayOfNextYear = function firstDayOfNextYear() {\n    return Impl.FIRST_DAY_OF_NEXT_YEAR;\n  };\n  TemporalAdjusters.firstInMonth = function firstInMonth(dayOfWeek) {\n    requireNonNull(dayOfWeek, 'dayOfWeek');\n    return new DayOfWeekInMonth(1, dayOfWeek);\n  };\n  TemporalAdjusters.lastInMonth = function lastInMonth(dayOfWeek) {\n    requireNonNull(dayOfWeek, 'dayOfWeek');\n    return new DayOfWeekInMonth(-1, dayOfWeek);\n  };\n  TemporalAdjusters.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {\n    requireNonNull(dayOfWeek, 'dayOfWeek');\n    return new DayOfWeekInMonth(ordinal, dayOfWeek);\n  };\n  TemporalAdjusters.next = function next(dayOfWeek) {\n    return new RelativeDayOfWeek(2, dayOfWeek);\n  };\n  TemporalAdjusters.nextOrSame = function nextOrSame(dayOfWeek) {\n    return new RelativeDayOfWeek(0, dayOfWeek);\n  };\n  TemporalAdjusters.previous = function previous(dayOfWeek) {\n    return new RelativeDayOfWeek(3, dayOfWeek);\n  };\n  TemporalAdjusters.previousOrSame = function previousOrSame(dayOfWeek) {\n    return new RelativeDayOfWeek(1, dayOfWeek);\n  };\n  return TemporalAdjusters;\n}();\nvar Impl = function (_TemporalAdjuster) {\n  _inherits$n(Impl, _TemporalAdjuster);\n  function Impl(ordinal) {\n    _classCallCheck$O(this, Impl);\n    var _this = _possibleConstructorReturn$n(this, _TemporalAdjuster.call(this));\n    _this._ordinal = ordinal;\n    return _this;\n  }\n  Impl.prototype.adjustInto = function adjustInto(temporal) {\n    switch (this._ordinal) {\n      case 0:\n        return temporal.with(ChronoField.DAY_OF_MONTH, 1);\n      case 1:\n        return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n      case 2:\n        return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);\n      case 3:\n        return temporal.with(ChronoField.DAY_OF_YEAR, 1);\n      case 4:\n        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());\n      case 5:\n        return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);\n    }\n    throw new IllegalStateException('Unreachable');\n  };\n  return Impl;\n}(TemporalAdjuster);\nImpl.FIRST_DAY_OF_MONTH = new Impl(0);\nImpl.LAST_DAY_OF_MONTH = new Impl(1);\nImpl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);\nImpl.FIRST_DAY_OF_YEAR = new Impl(3);\nImpl.LAST_DAY_OF_YEAR = new Impl(4);\nImpl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);\nvar DayOfWeekInMonth = function (_TemporalAdjuster2) {\n  _inherits$n(DayOfWeekInMonth, _TemporalAdjuster2);\n  function DayOfWeekInMonth(ordinal, dow) {\n    _classCallCheck$O(this, DayOfWeekInMonth);\n    var _this2 = _possibleConstructorReturn$n(this, _TemporalAdjuster2.call(this));\n    _this2._ordinal = ordinal;\n    _this2._dowValue = dow.value();\n    return _this2;\n  }\n  DayOfWeekInMonth.prototype.adjustInto = function adjustInto(temporal) {\n    if (this._ordinal >= 0) {\n      var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);\n      var curDow = temp.get(ChronoField.DAY_OF_WEEK);\n      var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);\n      dowDiff += (this._ordinal - 1) * 7;\n      return temp.plus(dowDiff, ChronoUnit.DAYS);\n    } else {\n      var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n      var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);\n      var daysDiff = this._dowValue - _curDow;\n      daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;\n      daysDiff -= (-this._ordinal - 1) * 7;\n      return _temp.plus(daysDiff, ChronoUnit.DAYS);\n    }\n  };\n  return DayOfWeekInMonth;\n}(TemporalAdjuster);\nvar RelativeDayOfWeek = function (_TemporalAdjuster3) {\n  _inherits$n(RelativeDayOfWeek, _TemporalAdjuster3);\n  function RelativeDayOfWeek(relative, dayOfWeek) {\n    _classCallCheck$O(this, RelativeDayOfWeek);\n    var _this3 = _possibleConstructorReturn$n(this, _TemporalAdjuster3.call(this));\n    requireNonNull(dayOfWeek, 'dayOfWeek');\n    _this3._relative = relative;\n    _this3._dowValue = dayOfWeek.value();\n    return _this3;\n  }\n  RelativeDayOfWeek.prototype.adjustInto = function adjustInto(temporal) {\n    var calDow = temporal.get(ChronoField.DAY_OF_WEEK);\n    if (this._relative < 2 && calDow === this._dowValue) {\n      return temporal;\n    }\n    if ((this._relative & 1) === 0) {\n      var daysDiff = calDow - this._dowValue;\n      return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);\n    } else {\n      var _daysDiff = this._dowValue - calDow;\n      return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);\n    }\n  };\n  return RelativeDayOfWeek;\n}(TemporalAdjuster);\nfunction _classCallCheck$P(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$o(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$o(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar IsoChronology = function (_Enum) {\n  _inherits$o(IsoChronology, _Enum);\n  function IsoChronology() {\n    _classCallCheck$P(this, IsoChronology);\n    return _possibleConstructorReturn$o(this, _Enum.apply(this, arguments));\n  }\n  IsoChronology.isLeapYear = function isLeapYear(prolepticYear) {\n    return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);\n  };\n  IsoChronology.prototype._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {\n    requireNonNull(fieldValues, 'fieldValues');\n    requireNonNull(field, 'field');\n    var current = fieldValues.get(field);\n    if (current != null && current !== value) {\n      throw new DateTimeException('Invalid state, field: ' + field + ' ' + current + ' conflicts with ' + field + ' ' + value);\n    }\n    fieldValues.put(field, value);\n  };\n  IsoChronology.prototype.resolveDate = function resolveDate(fieldValues, resolverStyle) {\n    if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {\n      return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));\n    }\n    var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);\n    if (prolepticMonth != null) {\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);\n      }\n      this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);\n      this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));\n    }\n    var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);\n    if (yoeLong != null) {\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);\n      }\n      var era = fieldValues.remove(ChronoField.ERA);\n      if (era == null) {\n        var year = fieldValues.get(ChronoField.YEAR);\n        if (resolverStyle === ResolverStyle.STRICT) {\n          if (year != null) {\n            this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));\n          } else {\n            fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);\n          }\n        } else {\n          this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));\n        }\n      } else if (era === 1) {\n        this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);\n      } else if (era === 0) {\n        this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));\n      } else {\n        throw new DateTimeException('Invalid value for era: ' + era);\n      }\n    } else if (fieldValues.containsKey(ChronoField.ERA)) {\n      ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));\n    }\n    if (fieldValues.containsKey(ChronoField.YEAR)) {\n      if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {\n        if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {\n          var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n          var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);\n          var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);\n          if (resolverStyle === ResolverStyle.LENIENT) {\n            var months = moy - 1;\n            var days = dom - 1;\n            return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);\n          } else if (resolverStyle === ResolverStyle.SMART) {\n            ChronoField.DAY_OF_MONTH.checkValidValue(dom);\n            if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {\n              dom = Math.min(dom, 30);\n            } else if (moy === 2) {\n              dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));\n            }\n            return LocalDate.of(y, moy, dom);\n          } else {\n            return LocalDate.of(y, moy, dom);\n          }\n        }\n      }\n      if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {\n        var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n        if (resolverStyle === ResolverStyle.LENIENT) {\n          var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);\n          return LocalDate.ofYearDay(_y, 1).plusDays(_days);\n        }\n        var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));\n        return LocalDate.ofYearDay(_y, doy);\n      }\n      if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {\n        if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {\n          var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n          if (resolverStyle === ResolverStyle.LENIENT) {\n            var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n            var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);\n            return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);\n          }\n          var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n          var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n          var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));\n          if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {\n            throw new DateTimeException('Strict mode rejected date parsed to a different year');\n          }\n          return date;\n        }\n        if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {\n          var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n          if (resolverStyle === ResolverStyle.LENIENT) {\n            var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n            var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);\n            return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);\n          }\n          var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n          var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));\n          var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));\n          if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {\n            throw new DateTimeException('Strict mode rejected date parsed to a different month');\n          }\n          return _date;\n        }\n      }\n    }\n    return null;\n  };\n  IsoChronology.prototype.date = function date(temporal) {\n    return LocalDate.from(temporal);\n  };\n  return IsoChronology;\n}(Enum);\nfunction _init$e() {\n  IsoChronology.INSTANCE = new IsoChronology('IsoChronology');\n}\nfunction _classCallCheck$Q(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$p(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$p(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar ChronoZonedDateTime = function (_Temporal) {\n  _inherits$p(ChronoZonedDateTime, _Temporal);\n  function ChronoZonedDateTime() {\n    _classCallCheck$Q(this, ChronoZonedDateTime);\n    return _possibleConstructorReturn$p(this, _Temporal.apply(this, arguments));\n  }\n  ChronoZonedDateTime.prototype.query = function query(_query) {\n    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {\n      return this.zone();\n    } else if (_query === TemporalQueries.chronology()) {\n      return this.toLocalDate().chronology();\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.offset()) {\n      return this.offset();\n    } else if (_query === TemporalQueries.localDate()) {\n      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n    } else if (_query === TemporalQueries.localTime()) {\n      return this.toLocalTime();\n    }\n    return _Temporal.prototype.query.call(this, _query);\n  };\n  ChronoZonedDateTime.prototype.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n  ChronoZonedDateTime.prototype.toInstant = function toInstant() {\n    return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());\n  };\n  ChronoZonedDateTime.prototype.toEpochSecond = function toEpochSecond() {\n    var epochDay = this.toLocalDate().toEpochDay();\n    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n    secs -= this.offset().totalSeconds();\n    return secs;\n  };\n  ChronoZonedDateTime.prototype.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());\n    if (cmp === 0) {\n      cmp = this.toLocalTime().nano() - other.toLocalTime().nano();\n      if (cmp === 0) {\n        cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());\n        if (cmp === 0) {\n          cmp = strcmp(this.zone().id(), other.zone().id());\n        }\n      }\n    }\n    return cmp;\n  };\n  ChronoZonedDateTime.prototype.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    var thisEpochSec = this.toEpochSecond();\n    var otherEpochSec = other.toEpochSecond();\n    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();\n  };\n  ChronoZonedDateTime.prototype.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    var thisEpochSec = this.toEpochSecond();\n    var otherEpochSec = other.toEpochSecond();\n    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();\n  };\n  ChronoZonedDateTime.prototype.isEqual = function isEqual(other) {\n    requireNonNull(other, 'other');\n    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();\n  };\n  ChronoZonedDateTime.prototype.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ChronoZonedDateTime) {\n      return this.compareTo(other) === 0;\n    }\n    return false;\n  };\n  return ChronoZonedDateTime;\n}(Temporal);\nfunction strcmp(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nfunction _classCallCheck$R(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$q(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$q(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar ZonedDateTime = function (_ChronoZonedDateTime) {\n  _inherits$q(ZonedDateTime, _ChronoZonedDateTime);\n  ZonedDateTime.now = function now(clockOrZone) {\n    var clock = void 0;\n    if (clockOrZone instanceof ZoneId) {\n      clock = Clock.system(clockOrZone);\n    } else {\n      clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;\n    }\n    return ZonedDateTime.ofInstant(clock.instant(), clock.zone());\n  };\n  ZonedDateTime.of = function of() {\n    if (arguments.length <= 2) {\n      return ZonedDateTime.of2.apply(this, arguments);\n    } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {\n      return ZonedDateTime.of3.apply(this, arguments);\n    } else {\n      return ZonedDateTime.of8.apply(this, arguments);\n    }\n  };\n  ZonedDateTime.of3 = function of3(date, time, zone) {\n    return ZonedDateTime.of2(LocalDateTime.of(date, time), zone);\n  };\n  ZonedDateTime.of2 = function of2(localDateTime, zone) {\n    return ZonedDateTime.ofLocal(localDateTime, zone, null);\n  };\n  ZonedDateTime.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {\n    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n    return ZonedDateTime.ofLocal(dt, zone, null);\n  };\n  ZonedDateTime.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {\n    requireNonNull(localDateTime, 'localDateTime');\n    requireNonNull(zone, 'zone');\n    if (zone instanceof ZoneOffset) {\n      return new ZonedDateTime(localDateTime, zone, zone);\n    }\n    var offset = null;\n    var rules = zone.rules();\n    var validOffsets = rules.validOffsets(localDateTime);\n    if (validOffsets.length === 1) {\n      offset = validOffsets[0];\n    } else if (validOffsets.length === 0) {\n      var trans = rules.transition(localDateTime);\n      localDateTime = localDateTime.plusSeconds(trans.duration().seconds());\n      offset = trans.offsetAfter();\n    } else {\n      if (preferredOffset != null && validOffsets.some(function (validOffset) {\n        return validOffset.equals(preferredOffset);\n      })) {\n        offset = preferredOffset;\n      } else {\n        offset = requireNonNull(validOffsets[0], 'offset');\n      }\n    }\n    return new ZonedDateTime(localDateTime, offset, zone);\n  };\n  ZonedDateTime.ofInstant = function ofInstant() {\n    if (arguments.length === 2) {\n      return ZonedDateTime.ofInstant2.apply(this, arguments);\n    } else {\n      return ZonedDateTime.ofInstant3.apply(this, arguments);\n    }\n  };\n  ZonedDateTime.ofInstant2 = function ofInstant2(instant, zone) {\n    requireNonNull(instant, 'instant');\n    requireNonNull(zone, 'zone');\n    return ZonedDateTime._create(instant.epochSecond(), instant.nano(), zone);\n  };\n  ZonedDateTime.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {\n    requireNonNull(localDateTime, 'localDateTime');\n    requireNonNull(offset, 'offset');\n    requireNonNull(zone, 'zone');\n    return ZonedDateTime._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);\n  };\n  ZonedDateTime._create = function _create(epochSecond, nanoOfSecond, zone) {\n    var rules = zone.rules();\n    var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);\n    var offset = rules.offset(instant);\n    var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);\n    return new ZonedDateTime(ldt, offset, zone);\n  };\n  ZonedDateTime.ofStrict = function ofStrict(localDateTime, offset, zone) {\n    requireNonNull(localDateTime, 'localDateTime');\n    requireNonNull(offset, 'offset');\n    requireNonNull(zone, 'zone');\n    var rules = zone.rules();\n    if (rules.isValidOffset(localDateTime, offset) === false) {\n      var trans = rules.transition(localDateTime);\n      if (trans != null && trans.isGap()) {\n        throw new DateTimeException('LocalDateTime ' + localDateTime + ' does not exist in zone ' + zone + ' due to a gap in the local time-line, typically caused by daylight savings');\n      }\n      throw new DateTimeException('ZoneOffset \"' + offset + '\" is not valid for LocalDateTime \"' + localDateTime + '\" in zone \"' + zone + '\"');\n    }\n    return new ZonedDateTime(localDateTime, offset, zone);\n  };\n  ZonedDateTime.ofLenient = function ofLenient(localDateTime, offset, zone) {\n    requireNonNull(localDateTime, 'localDateTime');\n    requireNonNull(offset, 'offset');\n    requireNonNull(zone, 'zone');\n    if (zone instanceof ZoneOffset && offset.equals(zone) === false) {\n      throw new IllegalArgumentException('ZoneId must match ZoneOffset');\n    }\n    return new ZonedDateTime(localDateTime, offset, zone);\n  };\n  ZonedDateTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    if (temporal instanceof ZonedDateTime) {\n      return temporal;\n    }\n    var zone = ZoneId.from(temporal);\n    if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {\n      var zdt = ZonedDateTime._from(temporal, zone);\n      if (zdt != null) return zdt;\n    }\n    var ldt = LocalDateTime.from(temporal);\n    return ZonedDateTime.of2(ldt, zone);\n  };\n  ZonedDateTime._from = function _from(temporal, zone) {\n    try {\n      return ZonedDateTime.__from(temporal, zone);\n    } catch (ex) {\n      if (!(ex instanceof DateTimeException)) throw ex;\n    }\n  };\n  ZonedDateTime.__from = function __from(temporal, zone) {\n    var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);\n    var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n    return ZonedDateTime._create(epochSecond, nanoOfSecond, zone);\n  };\n  ZonedDateTime.parse = function parse(text) {\n    var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DateTimeFormatter.ISO_ZONED_DATE_TIME;\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, ZonedDateTime.FROM);\n  };\n  function ZonedDateTime(dateTime, offset, zone) {\n    _classCallCheck$R(this, ZonedDateTime);\n    requireNonNull(dateTime, 'dateTime');\n    requireNonNull(offset, 'offset');\n    requireNonNull(zone, 'zone');\n    var _this = _possibleConstructorReturn$q(this, _ChronoZonedDateTime.call(this));\n    _this._dateTime = dateTime;\n    _this._offset = offset;\n    _this._zone = zone;\n    return _this;\n  }\n  ZonedDateTime.prototype._resolveLocal = function _resolveLocal(newDateTime) {\n    requireNonNull(newDateTime, 'newDateTime');\n    return ZonedDateTime.ofLocal(newDateTime, this._zone, this._offset);\n  };\n  ZonedDateTime.prototype._resolveInstant = function _resolveInstant(newDateTime) {\n    return ZonedDateTime.ofInstant3(newDateTime, this._offset, this._zone);\n  };\n  ZonedDateTime.prototype._resolveOffset = function _resolveOffset(offset) {\n    if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {\n      return new ZonedDateTime(this._dateTime, offset, this._zone);\n    }\n    return this;\n  };\n  ZonedDateTime.prototype.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return true;\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    }\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n  ZonedDateTime.prototype.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {\n        return field.range();\n      }\n      return this._dateTime.range(field);\n    }\n    return field.rangeRefinedBy(this);\n  };\n  ZonedDateTime.prototype.get = function get(field) {\n    return this.getLong(field);\n  };\n  ZonedDateTime.prototype.getLong = function getLong(field) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.INSTANT_SECONDS:\n          return this.toEpochSecond();\n        case ChronoField.OFFSET_SECONDS:\n          return this._offset.totalSeconds();\n      }\n      return this._dateTime.getLong(field);\n    }\n    requireNonNull(field, 'field');\n    return field.getFrom(this);\n  };\n  ZonedDateTime.prototype.offset = function offset() {\n    return this._offset;\n  };\n  ZonedDateTime.prototype.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {\n    var trans = this._zone.rules().transition(this._dateTime);\n    if (trans != null && trans.isOverlap()) {\n      var earlierOffset = trans.offsetBefore();\n      if (earlierOffset.equals(this._offset) === false) {\n        return new ZonedDateTime(this._dateTime, earlierOffset, this._zone);\n      }\n    }\n    return this;\n  };\n  ZonedDateTime.prototype.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {\n    var trans = this._zone.rules().transition(this.toLocalDateTime());\n    if (trans != null) {\n      var laterOffset = trans.offsetAfter();\n      if (laterOffset.equals(this._offset) === false) {\n        return new ZonedDateTime(this._dateTime, laterOffset, this._zone);\n      }\n    }\n    return this;\n  };\n  ZonedDateTime.prototype.zone = function zone() {\n    return this._zone;\n  };\n  ZonedDateTime.prototype.withZoneSameLocal = function withZoneSameLocal(zone) {\n    requireNonNull(zone, 'zone');\n    return this._zone.equals(zone) ? this : ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);\n  };\n  ZonedDateTime.prototype.withZoneSameInstant = function withZoneSameInstant(zone) {\n    requireNonNull(zone, 'zone');\n    return this._zone.equals(zone) ? this : ZonedDateTime._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);\n  };\n  ZonedDateTime.prototype.withFixedOffsetZone = function withFixedOffsetZone() {\n    return this._zone.equals(this._offset) ? this : new ZonedDateTime(this._dateTime, this._offset, this._offset);\n  };\n  ZonedDateTime.prototype.year = function year() {\n    return this._dateTime.year();\n  };\n  ZonedDateTime.prototype.monthValue = function monthValue() {\n    return this._dateTime.monthValue();\n  };\n  ZonedDateTime.prototype.month = function month() {\n    return this._dateTime.month();\n  };\n  ZonedDateTime.prototype.dayOfMonth = function dayOfMonth() {\n    return this._dateTime.dayOfMonth();\n  };\n  ZonedDateTime.prototype.dayOfYear = function dayOfYear() {\n    return this._dateTime.dayOfYear();\n  };\n  ZonedDateTime.prototype.dayOfWeek = function dayOfWeek() {\n    return this._dateTime.dayOfWeek();\n  };\n  ZonedDateTime.prototype.hour = function hour() {\n    return this._dateTime.hour();\n  };\n  ZonedDateTime.prototype.minute = function minute() {\n    return this._dateTime.minute();\n  };\n  ZonedDateTime.prototype.second = function second() {\n    return this._dateTime.second();\n  };\n  ZonedDateTime.prototype.nano = function nano() {\n    return this._dateTime.nano();\n  };\n  ZonedDateTime.prototype.with = function _with() {\n    if (arguments.length === 1) {\n      return this.withTemporalAdjuster.apply(this, arguments);\n    } else {\n      return this.with2.apply(this, arguments);\n    }\n  };\n  ZonedDateTime.prototype.withTemporalAdjuster = function withTemporalAdjuster(adjuster) {\n    if (adjuster instanceof LocalDate) {\n      return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));\n    } else if (adjuster instanceof LocalTime) {\n      return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));\n    } else if (adjuster instanceof LocalDateTime) {\n      return this._resolveLocal(adjuster);\n    } else if (adjuster instanceof Instant) {\n      var instant = adjuster;\n      return ZonedDateTime._create(instant.epochSecond(), instant.nano(), this._zone);\n    } else if (adjuster instanceof ZoneOffset) {\n      return this._resolveOffset(adjuster);\n    }\n    requireNonNull(adjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n  ZonedDateTime.prototype.with2 = function with2(field, newValue) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.INSTANT_SECONDS:\n          return ZonedDateTime._create(newValue, this.nano(), this._zone);\n        case ChronoField.OFFSET_SECONDS:\n          {\n            var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));\n            return this._resolveOffset(offset);\n          }\n      }\n      return this._resolveLocal(this._dateTime.with(field, newValue));\n    }\n    return field.adjustInto(this, newValue);\n  };\n  ZonedDateTime.prototype.withYear = function withYear(year) {\n    return this._resolveLocal(this._dateTime.withYear(year));\n  };\n  ZonedDateTime.prototype.withMonth = function withMonth(month) {\n    return this._resolveLocal(this._dateTime.withMonth(month));\n  };\n  ZonedDateTime.prototype.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));\n  };\n  ZonedDateTime.prototype.withDayOfYear = function withDayOfYear(dayOfYear) {\n    return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));\n  };\n  ZonedDateTime.prototype.withHour = function withHour(hour) {\n    return this._resolveLocal(this._dateTime.withHour(hour));\n  };\n  ZonedDateTime.prototype.withMinute = function withMinute(minute) {\n    return this._resolveLocal(this._dateTime.withMinute(minute));\n  };\n  ZonedDateTime.prototype.withSecond = function withSecond(second) {\n    return this._resolveLocal(this._dateTime.withSecond(second));\n  };\n  ZonedDateTime.prototype.withNano = function withNano(nanoOfSecond) {\n    return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));\n  };\n  ZonedDateTime.prototype.truncatedTo = function truncatedTo(unit) {\n    return this._resolveLocal(this._dateTime.truncatedTo(unit));\n  };\n  ZonedDateTime.prototype.plus = function plus() {\n    if (arguments.length === 1) {\n      return this.plusTemporalAmount.apply(this, arguments);\n    } else {\n      return this.plus2.apply(this, arguments);\n    }\n  };\n  ZonedDateTime.prototype.plusTemporalAmount = function plusTemporalAmount(amount) {\n    requireNonNull(amount);\n    return amount.addTo(this);\n  };\n  ZonedDateTime.prototype.plus2 = function plus2(amountToAdd, unit) {\n    if (unit instanceof ChronoUnit) {\n      if (unit.isDateBased()) {\n        return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));\n      } else {\n        return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));\n      }\n    }\n    requireNonNull(unit, 'unit');\n    return unit.addTo(this, amountToAdd);\n  };\n  ZonedDateTime.prototype.plusYears = function plusYears(years) {\n    return this._resolveLocal(this._dateTime.plusYears(years));\n  };\n  ZonedDateTime.prototype.plusMonths = function plusMonths(months) {\n    return this._resolveLocal(this._dateTime.plusMonths(months));\n  };\n  ZonedDateTime.prototype.plusWeeks = function plusWeeks(weeks) {\n    return this._resolveLocal(this._dateTime.plusWeeks(weeks));\n  };\n  ZonedDateTime.prototype.plusDays = function plusDays(days) {\n    return this._resolveLocal(this._dateTime.plusDays(days));\n  };\n  ZonedDateTime.prototype.plusHours = function plusHours(hours) {\n    return this._resolveInstant(this._dateTime.plusHours(hours));\n  };\n  ZonedDateTime.prototype.plusMinutes = function plusMinutes(minutes) {\n    return this._resolveInstant(this._dateTime.plusMinutes(minutes));\n  };\n  ZonedDateTime.prototype.plusSeconds = function plusSeconds(seconds) {\n    return this._resolveInstant(this._dateTime.plusSeconds(seconds));\n  };\n  ZonedDateTime.prototype.plusNanos = function plusNanos(nanos) {\n    return this._resolveInstant(this._dateTime.plusNanos(nanos));\n  };\n  ZonedDateTime.prototype.minus = function minus() {\n    if (arguments.length === 1) {\n      return this.minusTemporalAmount.apply(this, arguments);\n    } else {\n      return this.minus2.apply(this, arguments);\n    }\n  };\n  ZonedDateTime.prototype.minusTemporalAmount = function minusTemporalAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n  ZonedDateTime.prototype.minus2 = function minus2(amountToSubtract, unit) {\n    return this.plus2(-1 * amountToSubtract, unit);\n  };\n  ZonedDateTime.prototype.minusYears = function minusYears(years) {\n    return this.plusYears(-1 * years);\n  };\n  ZonedDateTime.prototype.minusMonths = function minusMonths(months) {\n    return this.plusMonths(-1 * months);\n  };\n  ZonedDateTime.prototype.minusWeeks = function minusWeeks(weeks) {\n    return this.plusWeeks(-1 * weeks);\n  };\n  ZonedDateTime.prototype.minusDays = function minusDays(days) {\n    return this.plusDays(-1 * days);\n  };\n  ZonedDateTime.prototype.minusHours = function minusHours(hours) {\n    return this.plusHours(-1 * hours);\n  };\n  ZonedDateTime.prototype.minusMinutes = function minusMinutes(minutes) {\n    return this.plusMinutes(-1 * minutes);\n  };\n  ZonedDateTime.prototype.minusSeconds = function minusSeconds(seconds) {\n    return this.plusSeconds(-1 * seconds);\n  };\n  ZonedDateTime.prototype.minusNanos = function minusNanos(nanos) {\n    return this.plusNanos(-1 * nanos);\n  };\n  ZonedDateTime.prototype.query = function query(_query) {\n    if (_query === TemporalQueries.localDate()) {\n      return this.toLocalDate();\n    }\n    requireNonNull(_query, 'query');\n    return _ChronoZonedDateTime.prototype.query.call(this, _query);\n  };\n  ZonedDateTime.prototype.until = function until(endExclusive, unit) {\n    var end = ZonedDateTime.from(endExclusive);\n    if (unit instanceof ChronoUnit) {\n      end = end.withZoneSameInstant(this._zone);\n      if (unit.isDateBased()) {\n        return this._dateTime.until(end._dateTime, unit);\n      } else {\n        var difference = this._offset.totalSeconds() - end._offset.totalSeconds();\n        var adjustedEnd = end._dateTime.plusSeconds(difference);\n        return this._dateTime.until(adjustedEnd, unit);\n      }\n    }\n    return unit.between(this, end);\n  };\n  ZonedDateTime.prototype.toLocalDateTime = function toLocalDateTime() {\n    return this._dateTime;\n  };\n  ZonedDateTime.prototype.toLocalDate = function toLocalDate() {\n    return this._dateTime.toLocalDate();\n  };\n  ZonedDateTime.prototype.toLocalTime = function toLocalTime() {\n    return this._dateTime.toLocalTime();\n  };\n  ZonedDateTime.prototype.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ZonedDateTime) {\n      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);\n    }\n    return false;\n  };\n  ZonedDateTime.prototype.hashCode = function hashCode() {\n    return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());\n  };\n  ZonedDateTime.prototype.toString = function toString() {\n    var str = this._dateTime.toString() + this._offset.toString();\n    if (this._offset !== this._zone) {\n      str += '[' + this._zone.toString() + ']';\n    }\n    return str;\n  };\n  ZonedDateTime.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  ZonedDateTime.prototype.format = function format(formatter) {\n    return _ChronoZonedDateTime.prototype.format.call(this, formatter);\n  };\n  return ZonedDateTime;\n}(ChronoZonedDateTime);\nfunction _init$f() {\n  ZonedDateTime.FROM = createTemporalQuery('ZonedDateTime.FROM', function (temporal) {\n    return ZonedDateTime.from(temporal);\n  });\n}\nfunction _classCallCheck$S(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$r(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$r(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar DAYS_PER_CYCLE = 146097;\nvar DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);\nvar LocalDate = function (_ChronoLocalDate) {\n  _inherits$r(LocalDate, _ChronoLocalDate);\n  LocalDate.now = function now(clockOrZone) {\n    var clock = void 0;\n    if (clockOrZone == null) {\n      clock = Clock.systemDefaultZone();\n    } else if (clockOrZone instanceof ZoneId) {\n      clock = Clock.system(clockOrZone);\n    } else {\n      clock = clockOrZone;\n    }\n    return LocalDate.ofInstant(clock.instant(), clock.zone());\n  };\n  LocalDate.ofInstant = function ofInstant(instant) {\n    var zone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZoneId.systemDefault();\n    requireNonNull(instant, 'instant');\n    var offset = zone.rules().offset(instant);\n    var epochSec = instant.epochSecond() + offset.totalSeconds();\n    var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);\n    return LocalDate.ofEpochDay(epochDay);\n  };\n  LocalDate.of = function of(year, month, dayOfMonth) {\n    return new LocalDate(year, month, dayOfMonth);\n  };\n  LocalDate.ofYearDay = function ofYearDay(year, dayOfYear) {\n    ChronoField.YEAR.checkValidValue(year);\n    var leap = IsoChronology.isLeapYear(year);\n    if (dayOfYear === 366 && leap === false) {\n      assert(false, 'Invalid date \\'DayOfYear 366\\' as \\'' + year + '\\' is not a leap year', DateTimeException);\n    }\n    var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));\n    var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n    if (dayOfYear > monthEnd) {\n      moy = moy.plus(1);\n    }\n    var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;\n    return new LocalDate(year, moy.value(), dom);\n  };\n  LocalDate.ofEpochDay = function ofEpochDay() {\n    var epochDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var adjust = void 0,\n      adjustCycles = void 0,\n      doyEst = void 0,\n      yearEst = void 0,\n      zeroDay = void 0;\n    zeroDay = epochDay + DAYS_0000_TO_1970;\n    zeroDay -= 60;\n    adjust = 0;\n    if (zeroDay < 0) {\n      adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;\n      adjust = adjustCycles * 400;\n      zeroDay += -adjustCycles * DAYS_PER_CYCLE;\n    }\n    yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);\n    doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n    if (doyEst < 0) {\n      yearEst--;\n      doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n    }\n    yearEst += adjust;\n    var marchDoy0 = doyEst;\n    var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);\n    var month = (marchMonth0 + 2) % 12 + 1;\n    var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;\n    yearEst += MathUtil.intDiv(marchMonth0, 10);\n    var year = yearEst;\n    return new LocalDate(year, month, dom);\n  };\n  LocalDate.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    var date = temporal.query(TemporalQueries.localDate());\n    if (date == null) {\n      throw new DateTimeException('Unable to obtain LocalDate from TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n    return date;\n  };\n  LocalDate.parse = function parse(text) {\n    var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DateTimeFormatter.ISO_LOCAL_DATE;\n    assert(formatter != null, 'formatter', NullPointerException);\n    return formatter.parse(text, LocalDate.FROM);\n  };\n  LocalDate._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {\n    switch (month) {\n      case 2:\n        day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);\n        break;\n      case 4:\n      case 6:\n      case 9:\n      case 11:\n        day = Math.min(day, 30);\n        break;\n    }\n    return LocalDate.of(year, month, day);\n  };\n  function LocalDate(year, month, dayOfMonth) {\n    _classCallCheck$S(this, LocalDate);\n    var _this = _possibleConstructorReturn$r(this, _ChronoLocalDate.call(this));\n    if (month instanceof Month) {\n      month = month.value();\n    }\n    _this._year = MathUtil.safeToInt(year);\n    _this._month = MathUtil.safeToInt(month);\n    _this._day = MathUtil.safeToInt(dayOfMonth);\n    LocalDate._validate(_this._year, _this._month, _this._day);\n    return _this;\n  }\n  LocalDate._validate = function _validate(year, month, dayOfMonth) {\n    var dom = void 0;\n    ChronoField.YEAR.checkValidValue(year);\n    ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n    if (dayOfMonth > 28) {\n      dom = 31;\n      switch (month) {\n        case 2:\n          dom = IsoChronology.isLeapYear(year) ? 29 : 28;\n          break;\n        case 4:\n        case 6:\n        case 9:\n        case 11:\n          dom = 30;\n      }\n      if (dayOfMonth > dom) {\n        if (dayOfMonth === 29) {\n          assert(false, 'Invalid date \\'February 29\\' as \\'' + year + '\\' is not a leap year', DateTimeException);\n        } else {\n          assert(false, 'Invalid date \\'' + year + '\\' \\'' + month + '\\' \\'' + dayOfMonth + '\\'', DateTimeException);\n        }\n      }\n    }\n  };\n  LocalDate.prototype.isSupported = function isSupported(field) {\n    return _ChronoLocalDate.prototype.isSupported.call(this, field);\n  };\n  LocalDate.prototype.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (field.isDateBased()) {\n        switch (field) {\n          case ChronoField.DAY_OF_MONTH:\n            return ValueRange.of(1, this.lengthOfMonth());\n          case ChronoField.DAY_OF_YEAR:\n            return ValueRange.of(1, this.lengthOfYear());\n          case ChronoField.ALIGNED_WEEK_OF_MONTH:\n            return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);\n          case ChronoField.YEAR_OF_ERA:\n            return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);\n        }\n        return field.range();\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.rangeRefinedBy(this);\n  };\n  LocalDate.prototype.get = function get(field) {\n    return this.getLong(field);\n  };\n  LocalDate.prototype.getLong = function getLong(field) {\n    assert(field != null, '', NullPointerException);\n    if (field instanceof ChronoField) {\n      return this._get0(field);\n    }\n    return field.getFrom(this);\n  };\n  LocalDate.prototype._get0 = function _get0(field) {\n    switch (field) {\n      case ChronoField.DAY_OF_WEEK:\n        return this.dayOfWeek().value();\n      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:\n        return MathUtil.intMod(this._day - 1, 7) + 1;\n      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:\n        return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;\n      case ChronoField.DAY_OF_MONTH:\n        return this._day;\n      case ChronoField.DAY_OF_YEAR:\n        return this.dayOfYear();\n      case ChronoField.EPOCH_DAY:\n        return this.toEpochDay();\n      case ChronoField.ALIGNED_WEEK_OF_MONTH:\n        return MathUtil.intDiv(this._day - 1, 7) + 1;\n      case ChronoField.ALIGNED_WEEK_OF_YEAR:\n        return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;\n      case ChronoField.MONTH_OF_YEAR:\n        return this._month;\n      case ChronoField.PROLEPTIC_MONTH:\n        return this._prolepticMonth();\n      case ChronoField.YEAR_OF_ERA:\n        return this._year >= 1 ? this._year : 1 - this._year;\n      case ChronoField.YEAR:\n        return this._year;\n      case ChronoField.ERA:\n        return this._year >= 1 ? 1 : 0;\n    }\n    throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n  };\n  LocalDate.prototype._prolepticMonth = function _prolepticMonth() {\n    return this._year * 12 + (this._month - 1);\n  };\n  LocalDate.prototype.chronology = function chronology() {\n    return IsoChronology.INSTANCE;\n  };\n  LocalDate.prototype.year = function year() {\n    return this._year;\n  };\n  LocalDate.prototype.monthValue = function monthValue() {\n    return this._month;\n  };\n  LocalDate.prototype.month = function month() {\n    return Month.of(this._month);\n  };\n  LocalDate.prototype.dayOfMonth = function dayOfMonth() {\n    return this._day;\n  };\n  LocalDate.prototype.dayOfYear = function dayOfYear() {\n    return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;\n  };\n  LocalDate.prototype.dayOfWeek = function dayOfWeek() {\n    var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);\n    return DayOfWeek.of(dow0 + 1);\n  };\n  LocalDate.prototype.isLeapYear = function isLeapYear() {\n    return IsoChronology.isLeapYear(this._year);\n  };\n  LocalDate.prototype.lengthOfMonth = function lengthOfMonth() {\n    switch (this._month) {\n      case 2:\n        return this.isLeapYear() ? 29 : 28;\n      case 4:\n      case 6:\n      case 9:\n      case 11:\n        return 30;\n      default:\n        return 31;\n    }\n  };\n  LocalDate.prototype.lengthOfYear = function lengthOfYear() {\n    return this.isLeapYear() ? 366 : 365;\n  };\n  LocalDate.prototype.with = function _with(fieldOrAdjuster, newValue) {\n    if (arguments.length < 2) {\n      return this.withTemporalAdjuster(fieldOrAdjuster);\n    } else {\n      return this.withFieldAndValue(fieldOrAdjuster, newValue);\n    }\n  };\n  LocalDate.prototype.withTemporalAdjuster = function withTemporalAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    if (adjuster instanceof LocalDate) {\n      return adjuster;\n    }\n    assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n    return adjuster.adjustInto(this);\n  };\n  LocalDate.prototype.withFieldAndValue = function withFieldAndValue(field, newValue) {\n    assert(field != null, 'field', NullPointerException);\n    if (field instanceof ChronoField) {\n      var f = field;\n      f.checkValidValue(newValue);\n      switch (f) {\n        case ChronoField.DAY_OF_WEEK:\n          return this.plusDays(newValue - this.dayOfWeek().value());\n        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:\n          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));\n        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:\n          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n        case ChronoField.DAY_OF_MONTH:\n          return this.withDayOfMonth(newValue);\n        case ChronoField.DAY_OF_YEAR:\n          return this.withDayOfYear(newValue);\n        case ChronoField.EPOCH_DAY:\n          return LocalDate.ofEpochDay(newValue);\n        case ChronoField.ALIGNED_WEEK_OF_MONTH:\n          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));\n        case ChronoField.ALIGNED_WEEK_OF_YEAR:\n          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));\n        case ChronoField.MONTH_OF_YEAR:\n          return this.withMonth(newValue);\n        case ChronoField.PROLEPTIC_MONTH:\n          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n        case ChronoField.YEAR_OF_ERA:\n          return this.withYear(this._year >= 1 ? newValue : 1 - newValue);\n        case ChronoField.YEAR:\n          return this.withYear(newValue);\n        case ChronoField.ERA:\n          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.adjustInto(this, newValue);\n  };\n  LocalDate.prototype.withYear = function withYear(year) {\n    if (this._year === year) {\n      return this;\n    }\n    ChronoField.YEAR.checkValidValue(year);\n    return LocalDate._resolvePreviousValid(year, this._month, this._day);\n  };\n  LocalDate.prototype.withMonth = function withMonth(month) {\n    var m = month instanceof Month ? month.value() : month;\n    if (this._month === m) {\n      return this;\n    }\n    ChronoField.MONTH_OF_YEAR.checkValidValue(m);\n    return LocalDate._resolvePreviousValid(this._year, m, this._day);\n  };\n  LocalDate.prototype.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    if (this._day === dayOfMonth) {\n      return this;\n    }\n    return LocalDate.of(this._year, this._month, dayOfMonth);\n  };\n  LocalDate.prototype.withDayOfYear = function withDayOfYear(dayOfYear) {\n    if (this.dayOfYear() === dayOfYear) {\n      return this;\n    }\n    return LocalDate.ofYearDay(this._year, dayOfYear);\n  };\n  LocalDate.prototype.plus = function plus(p1, p2) {\n    if (arguments.length < 2) {\n      return this.plus1(p1);\n    } else {\n      return this.plus2(p1, p2);\n    }\n  };\n  LocalDate.prototype.plus1 = function plus1(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n  LocalDate.prototype.plus2 = function plus2(amountToAdd, unit) {\n    requireNonNull(amountToAdd, 'amountToAdd');\n    requireNonNull(unit, 'unit');\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.DAYS:\n          return this.plusDays(amountToAdd);\n        case ChronoUnit.WEEKS:\n          return this.plusWeeks(amountToAdd);\n        case ChronoUnit.MONTHS:\n          return this.plusMonths(amountToAdd);\n        case ChronoUnit.YEARS:\n          return this.plusYears(amountToAdd);\n        case ChronoUnit.DECADES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n        case ChronoUnit.CENTURIES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n        case ChronoUnit.MILLENNIA:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n        case ChronoUnit.ERAS:\n          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n    return unit.addTo(this, amountToAdd);\n  };\n  LocalDate.prototype.plusYears = function plusYears(yearsToAdd) {\n    if (yearsToAdd === 0) {\n      return this;\n    }\n    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);\n    return LocalDate._resolvePreviousValid(newYear, this._month, this._day);\n  };\n  LocalDate.prototype.plusMonths = function plusMonths(monthsToAdd) {\n    if (monthsToAdd === 0) {\n      return this;\n    }\n    var monthCount = this._year * 12 + (this._month - 1);\n    var calcMonths = monthCount + monthsToAdd;\n    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n    return LocalDate._resolvePreviousValid(newYear, newMonth, this._day);\n  };\n  LocalDate.prototype.plusWeeks = function plusWeeks(weeksToAdd) {\n    return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));\n  };\n  LocalDate.prototype.plusDays = function plusDays(daysToAdd) {\n    if (daysToAdd === 0) {\n      return this;\n    }\n    var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);\n    return LocalDate.ofEpochDay(mjDay);\n  };\n  LocalDate.prototype.minus = function minus(p1, p2) {\n    if (arguments.length < 2) {\n      return this.minus1(p1);\n    } else {\n      return this.minus2(p1, p2);\n    }\n  };\n  LocalDate.prototype.minus1 = function minus1(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n  LocalDate.prototype.minus2 = function minus2(amountToSubtract, unit) {\n    requireNonNull(amountToSubtract, 'amountToSubtract');\n    requireNonNull(unit, 'unit');\n    return this.plus2(-1 * amountToSubtract, unit);\n  };\n  LocalDate.prototype.minusYears = function minusYears(yearsToSubtract) {\n    return this.plusYears(yearsToSubtract * -1);\n  };\n  LocalDate.prototype.minusMonths = function minusMonths(monthsToSubtract) {\n    return this.plusMonths(monthsToSubtract * -1);\n  };\n  LocalDate.prototype.minusWeeks = function minusWeeks(weeksToSubtract) {\n    return this.plusWeeks(weeksToSubtract * -1);\n  };\n  LocalDate.prototype.minusDays = function minusDays(daysToSubtract) {\n    return this.plusDays(daysToSubtract * -1);\n  };\n  LocalDate.prototype.query = function query(_query) {\n    requireNonNull(_query, 'query');\n    if (_query === TemporalQueries.localDate()) {\n      return this;\n    }\n    return _ChronoLocalDate.prototype.query.call(this, _query);\n  };\n  LocalDate.prototype.adjustInto = function adjustInto(temporal) {\n    return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);\n  };\n  LocalDate.prototype.until = function until(p1, p2) {\n    if (arguments.length < 2) {\n      return this.until1(p1);\n    } else {\n      return this.until2(p1, p2);\n    }\n  };\n  LocalDate.prototype.until2 = function until2(endExclusive, unit) {\n    var end = LocalDate.from(endExclusive);\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.DAYS:\n          return this.daysUntil(end);\n        case ChronoUnit.WEEKS:\n          return MathUtil.intDiv(this.daysUntil(end), 7);\n        case ChronoUnit.MONTHS:\n          return this._monthsUntil(end);\n        case ChronoUnit.YEARS:\n          return MathUtil.intDiv(this._monthsUntil(end), 12);\n        case ChronoUnit.DECADES:\n          return MathUtil.intDiv(this._monthsUntil(end), 120);\n        case ChronoUnit.CENTURIES:\n          return MathUtil.intDiv(this._monthsUntil(end), 1200);\n        case ChronoUnit.MILLENNIA:\n          return MathUtil.intDiv(this._monthsUntil(end), 12000);\n        case ChronoUnit.ERAS:\n          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n    return unit.between(this, end);\n  };\n  LocalDate.prototype.daysUntil = function daysUntil(end) {\n    return end.toEpochDay() - this.toEpochDay();\n  };\n  LocalDate.prototype._monthsUntil = function _monthsUntil(end) {\n    var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();\n    var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();\n    return MathUtil.intDiv(packed2 - packed1, 32);\n  };\n  LocalDate.prototype.until1 = function until1(endDate) {\n    var end = LocalDate.from(endDate);\n    var totalMonths = end._prolepticMonth() - this._prolepticMonth();\n    var days = end._day - this._day;\n    if (totalMonths > 0 && days < 0) {\n      totalMonths--;\n      var calcDate = this.plusMonths(totalMonths);\n      days = end.toEpochDay() - calcDate.toEpochDay();\n    } else if (totalMonths < 0 && days > 0) {\n      totalMonths++;\n      days -= end.lengthOfMonth();\n    }\n    var years = MathUtil.intDiv(totalMonths, 12);\n    var months = MathUtil.intMod(totalMonths, 12);\n    return Period.of(years, months, days);\n  };\n  LocalDate.prototype.atTime = function atTime() {\n    if (arguments.length === 1) {\n      return this.atTime1.apply(this, arguments);\n    } else {\n      return this.atTime4.apply(this, arguments);\n    }\n  };\n  LocalDate.prototype.atTime1 = function atTime1(time) {\n    return LocalDateTime.of(this, time);\n  };\n  LocalDate.prototype.atTime4 = function atTime4(hour, minute) {\n    var second = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var nanoOfSecond = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));\n  };\n  LocalDate.prototype.atStartOfDay = function atStartOfDay(zone) {\n    if (zone != null) {\n      return this.atStartOfDayWithZone(zone);\n    } else {\n      return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n    }\n  };\n  LocalDate.prototype.atStartOfDayWithZone = function atStartOfDayWithZone(zone) {\n    requireNonNull(zone, 'zone');\n    var ldt = this.atTime(LocalTime.MIDNIGHT);\n    if (zone instanceof ZoneOffset === false) {\n      var trans = zone.rules().transition(ldt);\n      if (trans != null && trans.isGap()) {\n        ldt = trans.dateTimeAfter();\n      }\n    }\n    return ZonedDateTime.of(ldt, zone);\n  };\n  LocalDate.prototype.toEpochDay = function toEpochDay() {\n    var y = this._year;\n    var m = this._month;\n    var total = 0;\n    total += 365 * y;\n    if (y >= 0) {\n      total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);\n    } else {\n      total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);\n    }\n    total += MathUtil.intDiv(367 * m - 362, 12);\n    total += this.dayOfMonth() - 1;\n    if (m > 2) {\n      total--;\n      if (!IsoChronology.isLeapYear(y)) {\n        total--;\n      }\n    }\n    return total - DAYS_0000_TO_1970;\n  };\n  LocalDate.prototype.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, LocalDate, 'other');\n    return this._compareTo0(other);\n  };\n  LocalDate.prototype._compareTo0 = function _compareTo0(otherDate) {\n    var cmp = this._year - otherDate._year;\n    if (cmp === 0) {\n      cmp = this._month - otherDate._month;\n      if (cmp === 0) {\n        cmp = this._day - otherDate._day;\n      }\n    }\n    return cmp;\n  };\n  LocalDate.prototype.isAfter = function isAfter(other) {\n    return this.compareTo(other) > 0;\n  };\n  LocalDate.prototype.isBefore = function isBefore(other) {\n    return this.compareTo(other) < 0;\n  };\n  LocalDate.prototype.isEqual = function isEqual(other) {\n    return this.compareTo(other) === 0;\n  };\n  LocalDate.prototype.equals = function equals(otherDate) {\n    if (this === otherDate) {\n      return true;\n    }\n    if (otherDate instanceof LocalDate) {\n      return this._compareTo0(otherDate) === 0;\n    }\n    return false;\n  };\n  LocalDate.prototype.hashCode = function hashCode() {\n    var yearValue = this._year;\n    var monthValue = this._month;\n    var dayValue = this._day;\n    return MathUtil.hash(yearValue & 0xFFFFF800 ^ (yearValue << 11) + (monthValue << 6) + dayValue);\n  };\n  LocalDate.prototype.toString = function toString() {\n    var dayString = void 0,\n      monthString = void 0,\n      yearString = void 0;\n    var yearValue = this._year;\n    var monthValue = this._month;\n    var dayValue = this._day;\n    var absYear = Math.abs(yearValue);\n    if (absYear < 1000) {\n      if (yearValue < 0) {\n        yearString = '-' + ('' + (yearValue - 10000)).slice(-4);\n      } else {\n        yearString = ('' + (yearValue + 10000)).slice(-4);\n      }\n    } else {\n      if (yearValue > 9999) {\n        yearString = '+' + yearValue;\n      } else {\n        yearString = '' + yearValue;\n      }\n    }\n    if (monthValue < 10) {\n      monthString = '-0' + monthValue;\n    } else {\n      monthString = '-' + monthValue;\n    }\n    if (dayValue < 10) {\n      dayString = '-0' + dayValue;\n    } else {\n      dayString = '-' + dayValue;\n    }\n    return yearString + monthString + dayString;\n  };\n  LocalDate.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  LocalDate.prototype.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return _ChronoLocalDate.prototype.format.call(this, formatter);\n  };\n  return LocalDate;\n}(ChronoLocalDate);\nfunction _init$g() {\n  LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);\n  LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);\n  LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);\n  LocalDate.FROM = createTemporalQuery('LocalDate.FROM', function (temporal) {\n    return LocalDate.from(temporal);\n  });\n}\nfunction _classCallCheck$T(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$s(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$s(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar ChronoLocalDateTime = function (_Temporal) {\n  _inherits$s(ChronoLocalDateTime, _Temporal);\n  function ChronoLocalDateTime() {\n    _classCallCheck$T(this, ChronoLocalDateTime);\n    return _possibleConstructorReturn$s(this, _Temporal.apply(this, arguments));\n  }\n  ChronoLocalDateTime.prototype.chronology = function chronology() {\n    return this.toLocalDate().chronology();\n  };\n  ChronoLocalDateTime.prototype.query = function query(_query) {\n    if (_query === TemporalQueries.chronology()) {\n      return this.chronology();\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.localDate()) {\n      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n    } else if (_query === TemporalQueries.localTime()) {\n      return this.toLocalTime();\n    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n    return _Temporal.prototype.query.call(this, _query);\n  };\n  ChronoLocalDateTime.prototype.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());\n  };\n  ChronoLocalDateTime.prototype.toInstant = function toInstant(offset) {\n    requireInstance(offset, ZoneOffset, 'zoneId');\n    return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());\n  };\n  ChronoLocalDateTime.prototype.toEpochSecond = function toEpochSecond(offset) {\n    requireNonNull(offset, 'offset');\n    var epochDay = this.toLocalDate().toEpochDay();\n    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n    secs -= offset.totalSeconds();\n    return MathUtil.safeToInt(secs);\n  };\n  return ChronoLocalDateTime;\n}(Temporal);\nfunction _classCallCheck$U(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$t(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$t(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar LocalDateTime = function (_ChronoLocalDateTime) {\n  _inherits$t(LocalDateTime, _ChronoLocalDateTime);\n  LocalDateTime.now = function now(clockOrZone) {\n    if (clockOrZone == null) {\n      return LocalDateTime._now(Clock.systemDefaultZone());\n    } else if (clockOrZone instanceof Clock) {\n      return LocalDateTime._now(clockOrZone);\n    } else {\n      return LocalDateTime._now(Clock.system(clockOrZone));\n    }\n  };\n  LocalDateTime._now = function _now(clock) {\n    requireNonNull(clock, 'clock');\n    return LocalDateTime.ofInstant(clock.instant(), clock.zone());\n  };\n  LocalDateTime._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {\n    var localSecond = MathUtil.floorDiv(epochMilli, 1000) + offset.totalSeconds();\n    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n    var nanoOfSecond = MathUtil.floorMod(epochMilli, 1000) * 1000000;\n    var date = LocalDate.ofEpochDay(localEpochDay);\n    var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n    return new LocalDateTime(date, time);\n  };\n  LocalDateTime.of = function of() {\n    if (arguments.length === 2 && (arguments[0] instanceof LocalDate || arguments[1] instanceof LocalTime)) {\n      return LocalDateTime.ofDateAndTime.apply(this, arguments);\n    } else {\n      return LocalDateTime.ofNumbers.apply(this, arguments);\n    }\n  };\n  LocalDateTime.ofNumbers = function ofNumbers() {\n    var year = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var month = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var dayOfMonth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var hour = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var minute = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var second = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var nanoOfSecond = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var date = LocalDate.of(year, month, dayOfMonth);\n    var time = LocalTime.of(hour, minute, second, nanoOfSecond);\n    return new LocalDateTime(date, time);\n  };\n  LocalDateTime.ofDateAndTime = function ofDateAndTime(date, time) {\n    requireNonNull(date, 'date');\n    requireNonNull(time, 'time');\n    return new LocalDateTime(date, time);\n  };\n  LocalDateTime.ofInstant = function ofInstant(instant) {\n    var zone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZoneId.systemDefault();\n    requireNonNull(instant, 'instant');\n    requireInstance(instant, Instant, 'instant');\n    requireNonNull(zone, 'zone');\n    var offset = zone.rules().offset(instant);\n    return LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);\n  };\n  LocalDateTime.ofEpochSecond = function ofEpochSecond() {\n    var epochSecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var nanoOfSecond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var offset = arguments[2];\n    if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {\n      offset = nanoOfSecond;\n      nanoOfSecond = 0;\n    }\n    requireNonNull(offset, 'offset');\n    var localSecond = epochSecond + offset.totalSeconds();\n    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n    var date = LocalDate.ofEpochDay(localEpochDay);\n    var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n    return new LocalDateTime(date, time);\n  };\n  LocalDateTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    if (temporal instanceof LocalDateTime) {\n      return temporal;\n    } else if (temporal instanceof ZonedDateTime) {\n      return temporal.toLocalDateTime();\n    }\n    try {\n      var date = LocalDate.from(temporal);\n      var time = LocalTime.from(temporal);\n      return new LocalDateTime(date, time);\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain LocalDateTime TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n  LocalDateTime.parse = function parse(text) {\n    var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DateTimeFormatter.ISO_LOCAL_DATE_TIME;\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, LocalDateTime.FROM);\n  };\n  function LocalDateTime(date, time) {\n    _classCallCheck$U(this, LocalDateTime);\n    var _this = _possibleConstructorReturn$t(this, _ChronoLocalDateTime.call(this));\n    requireInstance(date, LocalDate, 'date');\n    requireInstance(time, LocalTime, 'time');\n    _this._date = date;\n    _this._time = time;\n    return _this;\n  }\n  LocalDateTime.prototype._withDateTime = function _withDateTime(newDate, newTime) {\n    if (this._date === newDate && this._time === newTime) {\n      return this;\n    }\n    return new LocalDateTime(newDate, newTime);\n  };\n  LocalDateTime.prototype.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    }\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n  LocalDateTime.prototype.range = function range(field) {\n    if (field instanceof ChronoField) {\n      return field.isTimeBased() ? this._time.range(field) : this._date.range(field);\n    }\n    return field.rangeRefinedBy(this);\n  };\n  LocalDateTime.prototype.get = function get(field) {\n    if (field instanceof ChronoField) {\n      return field.isTimeBased() ? this._time.get(field) : this._date.get(field);\n    }\n    return _ChronoLocalDateTime.prototype.get.call(this, field);\n  };\n  LocalDateTime.prototype.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n    if (field instanceof ChronoField) {\n      return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);\n    }\n    return field.getFrom(this);\n  };\n  LocalDateTime.prototype.year = function year() {\n    return this._date.year();\n  };\n  LocalDateTime.prototype.monthValue = function monthValue() {\n    return this._date.monthValue();\n  };\n  LocalDateTime.prototype.month = function month() {\n    return this._date.month();\n  };\n  LocalDateTime.prototype.dayOfMonth = function dayOfMonth() {\n    return this._date.dayOfMonth();\n  };\n  LocalDateTime.prototype.dayOfYear = function dayOfYear() {\n    return this._date.dayOfYear();\n  };\n  LocalDateTime.prototype.dayOfWeek = function dayOfWeek() {\n    return this._date.dayOfWeek();\n  };\n  LocalDateTime.prototype.hour = function hour() {\n    return this._time.hour();\n  };\n  LocalDateTime.prototype.minute = function minute() {\n    return this._time.minute();\n  };\n  LocalDateTime.prototype.second = function second() {\n    return this._time.second();\n  };\n  LocalDateTime.prototype.nano = function nano() {\n    return this._time.nano();\n  };\n  LocalDateTime.prototype.with = function _with(adjusterOrField, newValue) {\n    if (arguments.length === 1) {\n      return this.withTemporalAdjuster(adjusterOrField);\n    } else {\n      return this.with2(adjusterOrField, newValue);\n    }\n  };\n  LocalDateTime.prototype.withTemporalAdjuster = function withTemporalAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    if (adjuster instanceof LocalDate) {\n      return this._withDateTime(adjuster, this._time);\n    } else if (adjuster instanceof LocalTime) {\n      return this._withDateTime(this._date, adjuster);\n    } else if (adjuster instanceof LocalDateTime) {\n      return adjuster;\n    }\n    assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n    return adjuster.adjustInto(this);\n  };\n  LocalDateTime.prototype.with2 = function with2(field, newValue) {\n    requireNonNull(field, 'field');\n    if (field instanceof ChronoField) {\n      if (field.isTimeBased()) {\n        return this._withDateTime(this._date, this._time.with(field, newValue));\n      } else {\n        return this._withDateTime(this._date.with(field, newValue), this._time);\n      }\n    }\n    return field.adjustInto(this, newValue);\n  };\n  LocalDateTime.prototype.withYear = function withYear(year) {\n    return this._withDateTime(this._date.withYear(year), this._time);\n  };\n  LocalDateTime.prototype.withMonth = function withMonth(month) {\n    return this._withDateTime(this._date.withMonth(month), this._time);\n  };\n  LocalDateTime.prototype.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);\n  };\n  LocalDateTime.prototype.withDayOfYear = function withDayOfYear(dayOfYear) {\n    return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);\n  };\n  LocalDateTime.prototype.withHour = function withHour(hour) {\n    var newTime = this._time.withHour(hour);\n    return this._withDateTime(this._date, newTime);\n  };\n  LocalDateTime.prototype.withMinute = function withMinute(minute) {\n    var newTime = this._time.withMinute(minute);\n    return this._withDateTime(this._date, newTime);\n  };\n  LocalDateTime.prototype.withSecond = function withSecond(second) {\n    var newTime = this._time.withSecond(second);\n    return this._withDateTime(this._date, newTime);\n  };\n  LocalDateTime.prototype.withNano = function withNano(nanoOfSecond) {\n    var newTime = this._time.withNano(nanoOfSecond);\n    return this._withDateTime(this._date, newTime);\n  };\n  LocalDateTime.prototype.truncatedTo = function truncatedTo(unit) {\n    return this._withDateTime(this._date, this._time.truncatedTo(unit));\n  };\n  LocalDateTime.prototype.plus = function plus(amount, unit) {\n    if (arguments.length === 1) {\n      return this.plusTemporalAmount(amount);\n    } else {\n      return this.plus2(amount, unit);\n    }\n  };\n  LocalDateTime.prototype.plusTemporalAmount = function plusTemporalAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n  LocalDateTime.prototype.plus2 = function plus2(amountToAdd, unit) {\n    requireNonNull(unit, 'unit');\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this.plusNanos(amountToAdd);\n        case ChronoUnit.MICROS:\n          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n        case ChronoUnit.MILLIS:\n          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n        case ChronoUnit.SECONDS:\n          return this.plusSeconds(amountToAdd);\n        case ChronoUnit.MINUTES:\n          return this.plusMinutes(amountToAdd);\n        case ChronoUnit.HOURS:\n          return this.plusHours(amountToAdd);\n        case ChronoUnit.HALF_DAYS:\n          return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);\n      }\n      return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);\n    }\n    return unit.addTo(this, amountToAdd);\n  };\n  LocalDateTime.prototype.plusYears = function plusYears(years) {\n    var newDate = this._date.plusYears(years);\n    return this._withDateTime(newDate, this._time);\n  };\n  LocalDateTime.prototype.plusMonths = function plusMonths(months) {\n    var newDate = this._date.plusMonths(months);\n    return this._withDateTime(newDate, this._time);\n  };\n  LocalDateTime.prototype.plusWeeks = function plusWeeks(weeks) {\n    var newDate = this._date.plusWeeks(weeks);\n    return this._withDateTime(newDate, this._time);\n  };\n  LocalDateTime.prototype.plusDays = function plusDays(days) {\n    var newDate = this._date.plusDays(days);\n    return this._withDateTime(newDate, this._time);\n  };\n  LocalDateTime.prototype.plusHours = function plusHours(hours) {\n    return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);\n  };\n  LocalDateTime.prototype.plusMinutes = function plusMinutes(minutes) {\n    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);\n  };\n  LocalDateTime.prototype.plusSeconds = function plusSeconds(seconds) {\n    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);\n  };\n  LocalDateTime.prototype.plusNanos = function plusNanos(nanos) {\n    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);\n  };\n  LocalDateTime.prototype.minus = function minus(amount, unit) {\n    if (arguments.length === 1) {\n      return this.minusTemporalAmount(amount);\n    } else {\n      return this.minus2(amount, unit);\n    }\n  };\n  LocalDateTime.prototype.minusTemporalAmount = function minusTemporalAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n  LocalDateTime.prototype.minus2 = function minus2(amountToSubtract, unit) {\n    requireNonNull(unit, 'unit');\n    return this.plus2(-1 * amountToSubtract, unit);\n  };\n  LocalDateTime.prototype.minusYears = function minusYears(years) {\n    return this.plusYears(-1 * years);\n  };\n  LocalDateTime.prototype.minusMonths = function minusMonths(months) {\n    return this.plusMonths(-1 * months);\n  };\n  LocalDateTime.prototype.minusWeeks = function minusWeeks(weeks) {\n    return this.plusWeeks(-1 * weeks);\n  };\n  LocalDateTime.prototype.minusDays = function minusDays(days) {\n    return this.plusDays(-1 * days);\n  };\n  LocalDateTime.prototype.minusHours = function minusHours(hours) {\n    return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);\n  };\n  LocalDateTime.prototype.minusMinutes = function minusMinutes(minutes) {\n    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);\n  };\n  LocalDateTime.prototype.minusSeconds = function minusSeconds(seconds) {\n    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);\n  };\n  LocalDateTime.prototype.minusNanos = function minusNanos(nanos) {\n    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);\n  };\n  LocalDateTime.prototype._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {\n    if ((hours | minutes | seconds | nanos) === 0) {\n      return this._withDateTime(newDate, this._time);\n    }\n    var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);\n    totDays *= sign;\n    var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;\n    var curNoD = this._time.toNanoOfDay();\n    totNanos = totNanos * sign + curNoD;\n    totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);\n    var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);\n    var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);\n    return this._withDateTime(newDate.plusDays(totDays), newTime);\n  };\n  LocalDateTime.prototype.query = function query(_query) {\n    requireNonNull(_query, 'query');\n    if (_query === TemporalQueries.localDate()) {\n      return this.toLocalDate();\n    }\n    return _ChronoLocalDateTime.prototype.query.call(this, _query);\n  };\n  LocalDateTime.prototype.adjustInto = function adjustInto(temporal) {\n    return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);\n  };\n  LocalDateTime.prototype.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    var end = LocalDateTime.from(endExclusive);\n    if (unit instanceof ChronoUnit) {\n      if (unit.isTimeBased()) {\n        var daysUntil = this._date.daysUntil(end._date);\n        var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();\n        if (daysUntil > 0 && timeUntil < 0) {\n          daysUntil--;\n          timeUntil += LocalTime.NANOS_PER_DAY;\n        } else if (daysUntil < 0 && timeUntil > 0) {\n          daysUntil++;\n          timeUntil -= LocalTime.NANOS_PER_DAY;\n        }\n        var amount = daysUntil;\n        switch (unit) {\n          case ChronoUnit.NANOS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);\n            return MathUtil.safeAdd(amount, timeUntil);\n          case ChronoUnit.MICROS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000));\n          case ChronoUnit.MILLIS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000000));\n          case ChronoUnit.SECONDS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));\n          case ChronoUnit.MINUTES:\n            amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));\n          case ChronoUnit.HOURS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));\n          case ChronoUnit.HALF_DAYS:\n            amount = MathUtil.safeMultiply(amount, 2);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));\n        }\n        throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n      }\n      var endDate = end._date;\n      var endTime = end._time;\n      if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {\n        endDate = endDate.minusDays(1);\n      } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {\n        endDate = endDate.plusDays(1);\n      }\n      return this._date.until(endDate, unit);\n    }\n    return unit.between(this, end);\n  };\n  LocalDateTime.prototype.atZone = function atZone(zone) {\n    return ZonedDateTime.of(this, zone);\n  };\n  LocalDateTime.prototype.toLocalDate = function toLocalDate() {\n    return this._date;\n  };\n  LocalDateTime.prototype.toLocalTime = function toLocalTime() {\n    return this._time;\n  };\n  LocalDateTime.prototype.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, LocalDateTime, 'other');\n    return this._compareTo0(other);\n  };\n  LocalDateTime.prototype._compareTo0 = function _compareTo0(other) {\n    var cmp = this._date.compareTo(other.toLocalDate());\n    if (cmp === 0) {\n      cmp = this._time.compareTo(other.toLocalTime());\n    }\n    return cmp;\n  };\n  LocalDateTime.prototype.isAfter = function isAfter(other) {\n    return this.compareTo(other) > 0;\n  };\n  LocalDateTime.prototype.isBefore = function isBefore(other) {\n    return this.compareTo(other) < 0;\n  };\n  LocalDateTime.prototype.isEqual = function isEqual(other) {\n    return this.compareTo(other) === 0;\n  };\n  LocalDateTime.prototype.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof LocalDateTime) {\n      return this._date.equals(other._date) && this._time.equals(other._time);\n    }\n    return false;\n  };\n  LocalDateTime.prototype.hashCode = function hashCode() {\n    return this._date.hashCode() ^ this._time.hashCode();\n  };\n  LocalDateTime.prototype.toString = function toString() {\n    return this._date.toString() + 'T' + this._time.toString();\n  };\n  LocalDateTime.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  LocalDateTime.prototype.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n  return LocalDateTime;\n}(ChronoLocalDateTime);\nfunction _init$h() {\n  LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n  LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n  LocalDateTime.FROM = createTemporalQuery('LocalDateTime.FROM', function (temporal) {\n    return LocalDateTime.from(temporal);\n  });\n}\nfunction _classCallCheck$V(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$u(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$u(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar LocalTime = function (_Temporal) {\n  _inherits$u(LocalTime, _Temporal);\n  LocalTime.now = function now(clockOrZone) {\n    if (clockOrZone == null) {\n      return LocalTime._now(Clock.systemDefaultZone());\n    } else if (clockOrZone instanceof Clock) {\n      return LocalTime._now(clockOrZone);\n    } else {\n      return LocalTime._now(Clock.system(clockOrZone));\n    }\n  };\n  LocalTime._now = function _now() {\n    var clock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Clock.systemDefaultZone();\n    requireNonNull(clock, 'clock');\n    return LocalTime.ofInstant(clock.instant(), clock.zone());\n  };\n  LocalTime.ofInstant = function ofInstant(instant) {\n    var zone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZoneId.systemDefault();\n    var offset = zone.rules().offset(instant);\n    var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime.SECONDS_PER_DAY);\n    secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime.SECONDS_PER_DAY);\n    if (secsOfDay < 0) {\n      secsOfDay += LocalTime.SECONDS_PER_DAY;\n    }\n    return LocalTime.ofSecondOfDay(secsOfDay, instant.nano());\n  };\n  LocalTime.of = function of(hour, minute, second, nanoOfSecond) {\n    return new LocalTime(hour, minute, second, nanoOfSecond);\n  };\n  LocalTime.ofSecondOfDay = function ofSecondOfDay() {\n    var secondOfDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var nanoOfSecond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);\n    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n    var hours = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_HOUR);\n    secondOfDay -= hours * LocalTime.SECONDS_PER_HOUR;\n    var minutes = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_MINUTE);\n    secondOfDay -= minutes * LocalTime.SECONDS_PER_MINUTE;\n    return new LocalTime(hours, minutes, secondOfDay, nanoOfSecond);\n  };\n  LocalTime.ofNanoOfDay = function ofNanoOfDay() {\n    var nanoOfDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);\n    var hours = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_HOUR);\n    nanoOfDay -= hours * LocalTime.NANOS_PER_HOUR;\n    var minutes = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_MINUTE);\n    nanoOfDay -= minutes * LocalTime.NANOS_PER_MINUTE;\n    var seconds = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_SECOND);\n    nanoOfDay -= seconds * LocalTime.NANOS_PER_SECOND;\n    return new LocalTime(hours, minutes, seconds, nanoOfDay);\n  };\n  LocalTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    var time = temporal.query(TemporalQueries.localTime());\n    if (time == null) {\n      throw new DateTimeException('Unable to obtain LocalTime TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n    return time;\n  };\n  LocalTime.parse = function parse(text) {\n    var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DateTimeFormatter.ISO_LOCAL_TIME;\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, LocalTime.FROM);\n  };\n  function LocalTime() {\n    var hour = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var minute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var second = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var nanoOfSecond = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    _classCallCheck$V(this, LocalTime);\n    var _this = _possibleConstructorReturn$u(this, _Temporal.call(this));\n    var _hour = MathUtil.safeToInt(hour);\n    var _minute = MathUtil.safeToInt(minute);\n    var _second = MathUtil.safeToInt(second);\n    var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);\n    LocalTime._validate(_hour, _minute, _second, _nanoOfSecond);\n    if ((_minute | _second | _nanoOfSecond) === 0) {\n      var _ret;\n      if (!LocalTime.HOURS[_hour]) {\n        _this._hour = _hour;\n        _this._minute = _minute;\n        _this._second = _second;\n        _this._nano = _nanoOfSecond;\n        LocalTime.HOURS[_hour] = _this;\n      }\n      return _ret = LocalTime.HOURS[_hour], _possibleConstructorReturn$u(_this, _ret);\n    }\n    _this._hour = _hour;\n    _this._minute = _minute;\n    _this._second = _second;\n    _this._nano = _nanoOfSecond;\n    return _this;\n  }\n  LocalTime._validate = function _validate(hour, minute, second, nanoOfSecond) {\n    ChronoField.HOUR_OF_DAY.checkValidValue(hour);\n    ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);\n    ChronoField.SECOND_OF_MINUTE.checkValidValue(second);\n    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n  };\n  LocalTime.prototype.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isTimeBased();\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isTimeBased();\n    }\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n  LocalTime.prototype.range = function range(field) {\n    requireNonNull(field);\n    return _Temporal.prototype.range.call(this, field);\n  };\n  LocalTime.prototype.get = function get(field) {\n    return this.getLong(field);\n  };\n  LocalTime.prototype.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n    if (field instanceof ChronoField) {\n      return this._get0(field);\n    }\n    return field.getFrom(this);\n  };\n  LocalTime.prototype._get0 = function _get0(field) {\n    switch (field) {\n      case ChronoField.NANO_OF_SECOND:\n        return this._nano;\n      case ChronoField.NANO_OF_DAY:\n        return this.toNanoOfDay();\n      case ChronoField.MICRO_OF_SECOND:\n        return MathUtil.intDiv(this._nano, 1000);\n      case ChronoField.MICRO_OF_DAY:\n        return MathUtil.intDiv(this.toNanoOfDay(), 1000);\n      case ChronoField.MILLI_OF_SECOND:\n        return MathUtil.intDiv(this._nano, 1000000);\n      case ChronoField.MILLI_OF_DAY:\n        return MathUtil.intDiv(this.toNanoOfDay(), 1000000);\n      case ChronoField.SECOND_OF_MINUTE:\n        return this._second;\n      case ChronoField.SECOND_OF_DAY:\n        return this.toSecondOfDay();\n      case ChronoField.MINUTE_OF_HOUR:\n        return this._minute;\n      case ChronoField.MINUTE_OF_DAY:\n        return this._hour * 60 + this._minute;\n      case ChronoField.HOUR_OF_AMPM:\n        return MathUtil.intMod(this._hour, 12);\n      case ChronoField.CLOCK_HOUR_OF_AMPM:\n        {\n          var ham = MathUtil.intMod(this._hour, 12);\n          return ham % 12 === 0 ? 12 : ham;\n        }\n      case ChronoField.HOUR_OF_DAY:\n        return this._hour;\n      case ChronoField.CLOCK_HOUR_OF_DAY:\n        return this._hour === 0 ? 24 : this._hour;\n      case ChronoField.AMPM_OF_DAY:\n        return MathUtil.intDiv(this._hour, 12);\n    }\n    throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n  };\n  LocalTime.prototype.hour = function hour() {\n    return this._hour;\n  };\n  LocalTime.prototype.minute = function minute() {\n    return this._minute;\n  };\n  LocalTime.prototype.second = function second() {\n    return this._second;\n  };\n  LocalTime.prototype.nano = function nano() {\n    return this._nano;\n  };\n  LocalTime.prototype.with = function _with(adjusterOrField, newValue) {\n    if (arguments.length < 2) {\n      return this.withTemporalAdjuster(adjusterOrField);\n    } else {\n      return this.with2(adjusterOrField, newValue);\n    }\n  };\n  LocalTime.prototype.withTemporalAdjuster = function withTemporalAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    if (adjuster instanceof LocalTime) {\n      return adjuster;\n    }\n    assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n    return adjuster.adjustInto(this);\n  };\n  LocalTime.prototype.with2 = function with2(field, newValue) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n    if (field instanceof ChronoField) {\n      field.checkValidValue(newValue);\n      switch (field) {\n        case ChronoField.NANO_OF_SECOND:\n          return this.withNano(newValue);\n        case ChronoField.NANO_OF_DAY:\n          return LocalTime.ofNanoOfDay(newValue);\n        case ChronoField.MICRO_OF_SECOND:\n          return this.withNano(newValue * 1000);\n        case ChronoField.MICRO_OF_DAY:\n          return LocalTime.ofNanoOfDay(newValue * 1000);\n        case ChronoField.MILLI_OF_SECOND:\n          return this.withNano(newValue * 1000000);\n        case ChronoField.MILLI_OF_DAY:\n          return LocalTime.ofNanoOfDay(newValue * 1000000);\n        case ChronoField.SECOND_OF_MINUTE:\n          return this.withSecond(newValue);\n        case ChronoField.SECOND_OF_DAY:\n          return this.plusSeconds(newValue - this.toSecondOfDay());\n        case ChronoField.MINUTE_OF_HOUR:\n          return this.withMinute(newValue);\n        case ChronoField.MINUTE_OF_DAY:\n          return this.plusMinutes(newValue - (this._hour * 60 + this._minute));\n        case ChronoField.HOUR_OF_AMPM:\n          return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));\n        case ChronoField.CLOCK_HOUR_OF_AMPM:\n          return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));\n        case ChronoField.HOUR_OF_DAY:\n          return this.withHour(newValue);\n        case ChronoField.CLOCK_HOUR_OF_DAY:\n          return this.withHour(newValue === 24 ? 0 : newValue);\n        case ChronoField.AMPM_OF_DAY:\n          return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.adjustInto(this, newValue);\n  };\n  LocalTime.prototype.withHour = function withHour() {\n    var hour = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (this._hour === hour) {\n      return this;\n    }\n    return new LocalTime(hour, this._minute, this._second, this._nano);\n  };\n  LocalTime.prototype.withMinute = function withMinute() {\n    var minute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (this._minute === minute) {\n      return this;\n    }\n    return new LocalTime(this._hour, minute, this._second, this._nano);\n  };\n  LocalTime.prototype.withSecond = function withSecond() {\n    var second = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (this._second === second) {\n      return this;\n    }\n    return new LocalTime(this._hour, this._minute, second, this._nano);\n  };\n  LocalTime.prototype.withNano = function withNano() {\n    var nanoOfSecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (this._nano === nanoOfSecond) {\n      return this;\n    }\n    return new LocalTime(this._hour, this._minute, this._second, nanoOfSecond);\n  };\n  LocalTime.prototype.truncatedTo = function truncatedTo(unit) {\n    requireNonNull(unit, 'unit');\n    if (unit === ChronoUnit.NANOS) {\n      return this;\n    }\n    var unitDur = unit.duration();\n    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n      throw new DateTimeException('Unit is too large to be used for truncation');\n    }\n    var dur = unitDur.toNanos();\n    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n      throw new DateTimeException('Unit must divide into a standard day without remainder');\n    }\n    var nod = this.toNanoOfDay();\n    return LocalTime.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);\n  };\n  LocalTime.prototype.plus = function plus(amount, unit) {\n    if (arguments.length < 2) {\n      return this.plus1(amount);\n    } else {\n      return this.plus2(amount, unit);\n    }\n  };\n  LocalTime.prototype.plus1 = function plus1(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n  LocalTime.prototype.plus2 = function plus2(amountToAdd, unit) {\n    requireNonNull(unit, 'unit');\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this.plusNanos(amountToAdd);\n        case ChronoUnit.MICROS:\n          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n        case ChronoUnit.MILLIS:\n          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n        case ChronoUnit.SECONDS:\n          return this.plusSeconds(amountToAdd);\n        case ChronoUnit.MINUTES:\n          return this.plusMinutes(amountToAdd);\n        case ChronoUnit.HOURS:\n          return this.plusHours(amountToAdd);\n        case ChronoUnit.HALF_DAYS:\n          return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n    return unit.addTo(this, amountToAdd);\n  };\n  LocalTime.prototype.plusHours = function plusHours(hoursToAdd) {\n    if (hoursToAdd === 0) {\n      return this;\n    }\n    var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime.HOURS_PER_DAY) + this._hour + LocalTime.HOURS_PER_DAY, LocalTime.HOURS_PER_DAY);\n    return new LocalTime(newHour, this._minute, this._second, this._nano);\n  };\n  LocalTime.prototype.plusMinutes = function plusMinutes(minutesToAdd) {\n    if (minutesToAdd === 0) {\n      return this;\n    }\n    var mofd = this._hour * LocalTime.MINUTES_PER_HOUR + this._minute;\n    var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime.MINUTES_PER_DAY) + mofd + LocalTime.MINUTES_PER_DAY, LocalTime.MINUTES_PER_DAY);\n    if (mofd === newMofd) {\n      return this;\n    }\n    var newHour = MathUtil.intDiv(newMofd, LocalTime.MINUTES_PER_HOUR);\n    var newMinute = MathUtil.intMod(newMofd, LocalTime.MINUTES_PER_HOUR);\n    return new LocalTime(newHour, newMinute, this._second, this._nano);\n  };\n  LocalTime.prototype.plusSeconds = function plusSeconds(secondsToAdd) {\n    if (secondsToAdd === 0) {\n      return this;\n    }\n    var sofd = this._hour * LocalTime.SECONDS_PER_HOUR + this._minute * LocalTime.SECONDS_PER_MINUTE + this._second;\n    var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime.SECONDS_PER_DAY) + sofd + LocalTime.SECONDS_PER_DAY, LocalTime.SECONDS_PER_DAY);\n    if (sofd === newSofd) {\n      return this;\n    }\n    var newHour = MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_HOUR);\n    var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n    var newSecond = MathUtil.intMod(newSofd, LocalTime.SECONDS_PER_MINUTE);\n    return new LocalTime(newHour, newMinute, newSecond, this._nano);\n  };\n  LocalTime.prototype.plusNanos = function plusNanos(nanosToAdd) {\n    if (nanosToAdd === 0) {\n      return this;\n    }\n    var nofd = this.toNanoOfDay();\n    var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_DAY) + nofd + LocalTime.NANOS_PER_DAY, LocalTime.NANOS_PER_DAY);\n    if (nofd === newNofd) {\n      return this;\n    }\n    var newHour = MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_HOUR);\n    var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n    var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_SECOND), LocalTime.SECONDS_PER_MINUTE);\n    var newNano = MathUtil.intMod(newNofd, LocalTime.NANOS_PER_SECOND);\n    return new LocalTime(newHour, newMinute, newSecond, newNano);\n  };\n  LocalTime.prototype.minus = function minus(amount, unit) {\n    if (arguments.length < 2) {\n      return this.minus1(amount);\n    } else {\n      return this.minus2(amount, unit);\n    }\n  };\n  LocalTime.prototype.minus1 = function minus1(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n  LocalTime.prototype.minus2 = function minus2(amountToSubtract, unit) {\n    requireNonNull(unit, 'unit');\n    return this.plus2(-1 * amountToSubtract, unit);\n  };\n  LocalTime.prototype.minusHours = function minusHours(hoursToSubtract) {\n    return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime.HOURS_PER_DAY));\n  };\n  LocalTime.prototype.minusMinutes = function minusMinutes(minutesToSubtract) {\n    return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime.MINUTES_PER_DAY));\n  };\n  LocalTime.prototype.minusSeconds = function minusSeconds(secondsToSubtract) {\n    return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime.SECONDS_PER_DAY));\n  };\n  LocalTime.prototype.minusNanos = function minusNanos(nanosToSubtract) {\n    return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime.NANOS_PER_DAY));\n  };\n  LocalTime.prototype.query = function query(_query) {\n    requireNonNull(_query, 'query');\n    if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.localTime()) {\n      return this;\n    }\n    if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {\n      return null;\n    }\n    return _query.queryFrom(this);\n  };\n  LocalTime.prototype.adjustInto = function adjustInto(temporal) {\n    return temporal.with(LocalTime.NANO_OF_DAY, this.toNanoOfDay());\n  };\n  LocalTime.prototype.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    var end = LocalTime.from(endExclusive);\n    if (unit instanceof ChronoUnit) {\n      var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return nanosUntil;\n        case ChronoUnit.MICROS:\n          return MathUtil.intDiv(nanosUntil, 1000);\n        case ChronoUnit.MILLIS:\n          return MathUtil.intDiv(nanosUntil, 1000000);\n        case ChronoUnit.SECONDS:\n          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);\n        case ChronoUnit.MINUTES:\n          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);\n        case ChronoUnit.HOURS:\n          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);\n        case ChronoUnit.HALF_DAYS:\n          return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n    return unit.between(this, end);\n  };\n  LocalTime.prototype.atDate = function atDate(date) {\n    return LocalDateTime.of(date, this);\n  };\n  LocalTime.prototype.toSecondOfDay = function toSecondOfDay() {\n    var total = this._hour * LocalTime.SECONDS_PER_HOUR;\n    total += this._minute * LocalTime.SECONDS_PER_MINUTE;\n    total += this._second;\n    return total;\n  };\n  LocalTime.prototype.toNanoOfDay = function toNanoOfDay() {\n    var total = this._hour * LocalTime.NANOS_PER_HOUR;\n    total += this._minute * LocalTime.NANOS_PER_MINUTE;\n    total += this._second * LocalTime.NANOS_PER_SECOND;\n    total += this._nano;\n    return total;\n  };\n  LocalTime.prototype.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, LocalTime, 'other');\n    var cmp = MathUtil.compareNumbers(this._hour, other._hour);\n    if (cmp === 0) {\n      cmp = MathUtil.compareNumbers(this._minute, other._minute);\n      if (cmp === 0) {\n        cmp = MathUtil.compareNumbers(this._second, other._second);\n        if (cmp === 0) {\n          cmp = MathUtil.compareNumbers(this._nano, other._nano);\n        }\n      }\n    }\n    return cmp;\n  };\n  LocalTime.prototype.isAfter = function isAfter(other) {\n    return this.compareTo(other) > 0;\n  };\n  LocalTime.prototype.isBefore = function isBefore(other) {\n    return this.compareTo(other) < 0;\n  };\n  LocalTime.prototype.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof LocalTime) {\n      return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;\n    }\n    return false;\n  };\n  LocalTime.prototype.hashCode = function hashCode() {\n    var nod = this.toNanoOfDay();\n    return MathUtil.hash(nod);\n  };\n  LocalTime.prototype.toString = function toString() {\n    var buf = '';\n    var hourValue = this._hour;\n    var minuteValue = this._minute;\n    var secondValue = this._second;\n    var nanoValue = this._nano;\n    buf += hourValue < 10 ? '0' : '';\n    buf += hourValue;\n    buf += minuteValue < 10 ? ':0' : ':';\n    buf += minuteValue;\n    if (secondValue > 0 || nanoValue > 0) {\n      buf += secondValue < 10 ? ':0' : ':';\n      buf += secondValue;\n      if (nanoValue > 0) {\n        buf += '.';\n        if (MathUtil.intMod(nanoValue, 1000000) === 0) {\n          buf += ('' + (MathUtil.intDiv(nanoValue, 1000000) + 1000)).substring(1);\n        } else if (MathUtil.intMod(nanoValue, 1000) === 0) {\n          buf += ('' + (MathUtil.intDiv(nanoValue, 1000) + 1000000)).substring(1);\n        } else {\n          buf += ('' + (nanoValue + 1000000000)).substring(1);\n        }\n      }\n    }\n    return buf;\n  };\n  LocalTime.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  LocalTime.prototype.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n  return LocalTime;\n}(Temporal);\nfunction _init$i() {\n  LocalTime.HOURS = [];\n  for (var hour = 0; hour < 24; hour++) {\n    LocalTime.of(hour, 0, 0, 0);\n  }\n  LocalTime.MIN = LocalTime.HOURS[0];\n  LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);\n  LocalTime.MIDNIGHT = LocalTime.HOURS[0];\n  LocalTime.NOON = LocalTime.HOURS[12];\n  LocalTime.FROM = createTemporalQuery('LocalTime.FROM', function (temporal) {\n    return LocalTime.from(temporal);\n  });\n}\nLocalTime.HOURS_PER_DAY = 24;\nLocalTime.MINUTES_PER_HOUR = 60;\nLocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;\nLocalTime.SECONDS_PER_MINUTE = 60;\nLocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\nLocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;\nLocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000;\nLocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000000;\nLocalTime.NANOS_PER_SECOND = 1000000000;\nLocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;\nLocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\nLocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nfunction _classCallCheck$W(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$v(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$v(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar NANOS_PER_MILLI = 1000000;\nvar Instant = function (_Temporal) {\n  _inherits$v(Instant, _Temporal);\n  Instant.now = function now() {\n    var clock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Clock.systemUTC();\n    return clock.instant();\n  };\n  Instant.ofEpochSecond = function ofEpochSecond(epochSecond) {\n    var nanoAdjustment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n    return Instant._create(secs, nos);\n  };\n  Instant.ofEpochMilli = function ofEpochMilli(epochMilli) {\n    var secs = MathUtil.floorDiv(epochMilli, 1000);\n    var mos = MathUtil.floorMod(epochMilli, 1000);\n    return Instant._create(secs, mos * 1000000);\n  };\n  Instant.from = function from(temporal) {\n    try {\n      var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);\n      var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n      return Instant.ofEpochSecond(instantSecs, nanoOfSecond);\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain Instant from TemporalAccessor: ' + temporal + ', type ' + (typeof temporal === 'undefined' ? 'undefined' : _typeof(temporal)), ex);\n    }\n  };\n  Instant.parse = function parse(text) {\n    return DateTimeFormatter.ISO_INSTANT.parse(text, Instant.FROM);\n  };\n  Instant._create = function _create(seconds, nanoOfSecond) {\n    if (seconds === 0 && nanoOfSecond === 0) {\n      return Instant.EPOCH;\n    }\n    return new Instant(seconds, nanoOfSecond);\n  };\n  Instant._validate = function _validate(seconds, nanoOfSecond) {\n    if (seconds < Instant.MIN_SECONDS || seconds > Instant.MAX_SECONDS) {\n      throw new DateTimeException('Instant exceeds minimum or maximum instant');\n    }\n    if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {\n      throw new DateTimeException('Instant exceeds minimum or maximum instant');\n    }\n  };\n  function Instant(seconds, nanoOfSecond) {\n    _classCallCheck$W(this, Instant);\n    var _this = _possibleConstructorReturn$v(this, _Temporal.call(this));\n    Instant._validate(seconds, nanoOfSecond);\n    _this._seconds = MathUtil.safeToInt(seconds);\n    _this._nanos = MathUtil.safeToInt(nanoOfSecond);\n    return _this;\n  }\n  Instant.prototype.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;\n    }\n    if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;\n    }\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n  Instant.prototype.range = function range(field) {\n    return _Temporal.prototype.range.call(this, field);\n  };\n  Instant.prototype.get = function get(field) {\n    return this.getLong(field);\n  };\n  Instant.prototype.getLong = function getLong(field) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.NANO_OF_SECOND:\n          return this._nanos;\n        case ChronoField.MICRO_OF_SECOND:\n          return MathUtil.intDiv(this._nanos, 1000);\n        case ChronoField.MILLI_OF_SECOND:\n          return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n        case ChronoField.INSTANT_SECONDS:\n          return this._seconds;\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.getFrom(this);\n  };\n  Instant.prototype.epochSecond = function epochSecond() {\n    return this._seconds;\n  };\n  Instant.prototype.nano = function nano() {\n    return this._nanos;\n  };\n  Instant.prototype.with = function _with(adjusterOrField, newValue) {\n    if (arguments.length === 1) {\n      return this.withTemporalAdjuster(adjusterOrField);\n    } else {\n      return this.with2(adjusterOrField, newValue);\n    }\n  };\n  Instant.prototype.withTemporalAdjuster = function withTemporalAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n  Instant.prototype.with2 = function with2(field, newValue) {\n    requireNonNull(field, 'field');\n    if (field instanceof ChronoField) {\n      field.checkValidValue(newValue);\n      switch (field) {\n        case ChronoField.MILLI_OF_SECOND:\n          {\n            var nval = newValue * NANOS_PER_MILLI;\n            return nval !== this._nanos ? Instant._create(this._seconds, nval) : this;\n          }\n        case ChronoField.MICRO_OF_SECOND:\n          {\n            var _nval = newValue * 1000;\n            return _nval !== this._nanos ? Instant._create(this._seconds, _nval) : this;\n          }\n        case ChronoField.NANO_OF_SECOND:\n          return newValue !== this._nanos ? Instant._create(this._seconds, newValue) : this;\n        case ChronoField.INSTANT_SECONDS:\n          return newValue !== this._seconds ? Instant._create(newValue, this._nanos) : this;\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.adjustInto(this, newValue);\n  };\n  Instant.prototype.truncatedTo = function truncatedTo(unit) {\n    requireNonNull(unit, 'unit');\n    if (unit === ChronoUnit.NANOS) {\n      return this;\n    }\n    var unitDur = unit.duration();\n    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n      throw new DateTimeException('Unit is too large to be used for truncation');\n    }\n    var dur = unitDur.toNanos();\n    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n      throw new DateTimeException('Unit must divide into a standard day without remainder');\n    }\n    var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;\n    var result = MathUtil.intDiv(nod, dur) * dur;\n    return this.plusNanos(result - nod);\n  };\n  Instant.prototype.plus = function plus(amount, unit) {\n    if (arguments.length === 1) {\n      return this.plus1(amount);\n    } else {\n      return this.plus2(amount, unit);\n    }\n  };\n  Instant.prototype.plus1 = function plus1(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n  Instant.prototype.plus2 = function plus2(amountToAdd, unit) {\n    requireNonNull(amountToAdd, 'amountToAdd');\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit);\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this.plusNanos(amountToAdd);\n        case ChronoUnit.MICROS:\n          return this._plus(MathUtil.intDiv(amountToAdd, 1000000), MathUtil.intMod(amountToAdd, 1000000) * 1000);\n        case ChronoUnit.MILLIS:\n          return this.plusMillis(amountToAdd);\n        case ChronoUnit.SECONDS:\n          return this.plusSeconds(amountToAdd);\n        case ChronoUnit.MINUTES:\n          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));\n        case ChronoUnit.HOURS:\n          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));\n        case ChronoUnit.HALF_DAYS:\n          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));\n        case ChronoUnit.DAYS:\n          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n    return unit.addTo(this, amountToAdd);\n  };\n  Instant.prototype.plusSeconds = function plusSeconds(secondsToAdd) {\n    return this._plus(secondsToAdd, 0);\n  };\n  Instant.prototype.plusMillis = function plusMillis(millisToAdd) {\n    return this._plus(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * NANOS_PER_MILLI);\n  };\n  Instant.prototype.plusNanos = function plusNanos(nanosToAdd) {\n    return this._plus(0, nanosToAdd);\n  };\n  Instant.prototype._plus = function _plus(secondsToAdd, nanosToAdd) {\n    if ((secondsToAdd | nanosToAdd) === 0) {\n      return this;\n    }\n    var epochSec = this._seconds + secondsToAdd;\n    epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n    var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;\n    return Instant.ofEpochSecond(epochSec, nanoAdjustment);\n  };\n  Instant.prototype.minus = function minus(amount, unit) {\n    if (arguments.length === 1) {\n      return this.minus1(amount);\n    } else {\n      return this.minus2(amount, unit);\n    }\n  };\n  Instant.prototype.minus1 = function minus1(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n  Instant.prototype.minus2 = function minus2(amountToSubtract, unit) {\n    return this.plus2(-1 * amountToSubtract, unit);\n  };\n  Instant.prototype.minusSeconds = function minusSeconds(secondsToSubtract) {\n    return this.plusSeconds(secondsToSubtract * -1);\n  };\n  Instant.prototype.minusMillis = function minusMillis(millisToSubtract) {\n    return this.plusMillis(-1 * millisToSubtract);\n  };\n  Instant.prototype.minusNanos = function minusNanos(nanosToSubtract) {\n    return this.plusNanos(-1 * nanosToSubtract);\n  };\n  Instant.prototype.query = function query(_query) {\n    requireNonNull(_query, 'query');\n    if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    }\n    if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n    return _query.queryFrom(this);\n  };\n  Instant.prototype.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);\n  };\n  Instant.prototype.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    var end = Instant.from(endExclusive);\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this._nanosUntil(end);\n        case ChronoUnit.MICROS:\n          return MathUtil.intDiv(this._nanosUntil(end), 1000);\n        case ChronoUnit.MILLIS:\n          return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());\n        case ChronoUnit.SECONDS:\n          return this._secondsUntil(end);\n        case ChronoUnit.MINUTES:\n          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);\n        case ChronoUnit.HOURS:\n          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);\n        case ChronoUnit.HALF_DAYS:\n          return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);\n        case ChronoUnit.DAYS:\n          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n    return unit.between(this, end);\n  };\n  Instant.prototype._nanosUntil = function _nanosUntil(end) {\n    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n    var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);\n    return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());\n  };\n  Instant.prototype._secondsUntil = function _secondsUntil(end) {\n    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n    var nanosDiff = end.nano() - this.nano();\n    if (secsDiff > 0 && nanosDiff < 0) {\n      secsDiff--;\n    } else if (secsDiff < 0 && nanosDiff > 0) {\n      secsDiff++;\n    }\n    return secsDiff;\n  };\n  Instant.prototype.atZone = function atZone(zone) {\n    return ZonedDateTime.ofInstant(this, zone);\n  };\n  Instant.prototype.toEpochMilli = function toEpochMilli() {\n    var millis = MathUtil.safeMultiply(this._seconds, 1000);\n    return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n  };\n  Instant.prototype.compareTo = function compareTo(otherInstant) {\n    requireNonNull(otherInstant, 'otherInstant');\n    requireInstance(otherInstant, Instant, 'otherInstant');\n    var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);\n    if (cmp !== 0) {\n      return cmp;\n    }\n    return this._nanos - otherInstant._nanos;\n  };\n  Instant.prototype.isAfter = function isAfter(otherInstant) {\n    return this.compareTo(otherInstant) > 0;\n  };\n  Instant.prototype.isBefore = function isBefore(otherInstant) {\n    return this.compareTo(otherInstant) < 0;\n  };\n  Instant.prototype.equals = function equals(otherInstant) {\n    if (this === otherInstant) {\n      return true;\n    }\n    if (otherInstant instanceof Instant) {\n      return this.epochSecond() === otherInstant.epochSecond() && this.nano() === otherInstant.nano();\n    }\n    return false;\n  };\n  Instant.prototype.hashCode = function hashCode() {\n    return MathUtil.hashCode(this._seconds, this._nanos);\n  };\n  Instant.prototype.toString = function toString() {\n    return DateTimeFormatter.ISO_INSTANT.format(this);\n  };\n  Instant.prototype.toJSON = function toJSON() {\n    return this.toString();\n  };\n  return Instant;\n}(Temporal);\nfunction _init$j() {\n  Instant.MIN_SECONDS = -31619119219200;\n  Instant.MAX_SECONDS = 31494816403199;\n  Instant.EPOCH = new Instant(0, 0);\n  Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);\n  Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);\n  Instant.FROM = createTemporalQuery('Instant.FROM', function (temporal) {\n    return Instant.from(temporal);\n  });\n}\nfunction _possibleConstructorReturn$w(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$w(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction _classCallCheck$X(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar Clock = function () {\n  function Clock() {\n    _classCallCheck$X(this, Clock);\n  }\n  Clock.systemUTC = function systemUTC() {\n    return new SystemClock(ZoneOffset.UTC);\n  };\n  Clock.systemDefaultZone = function systemDefaultZone() {\n    return new SystemClock(ZoneId.systemDefault());\n  };\n  Clock.system = function system(zone) {\n    return new SystemClock(zone);\n  };\n  Clock.fixed = function fixed(fixedInstant, zoneId) {\n    return new FixedClock(fixedInstant, zoneId);\n  };\n  Clock.offset = function offset(baseClock, duration) {\n    return new OffsetClock(baseClock, duration);\n  };\n  Clock.prototype.millis = function millis() {\n    abstractMethodFail('Clock.millis');\n  };\n  Clock.prototype.instant = function instant() {\n    abstractMethodFail('Clock.instant');\n  };\n  Clock.prototype.zone = function zone() {\n    abstractMethodFail('Clock.zone');\n  };\n  Clock.prototype.withZone = function withZone() {\n    abstractMethodFail('Clock.withZone');\n  };\n  return Clock;\n}();\nvar SystemClock = function (_Clock) {\n  _inherits$w(SystemClock, _Clock);\n  function SystemClock(zone) {\n    _classCallCheck$X(this, SystemClock);\n    requireNonNull(zone, 'zone');\n    var _this = _possibleConstructorReturn$w(this, _Clock.call(this));\n    _this._zone = zone;\n    return _this;\n  }\n  SystemClock.prototype.zone = function zone() {\n    return this._zone;\n  };\n  SystemClock.prototype.millis = function millis() {\n    return new Date().getTime();\n  };\n  SystemClock.prototype.instant = function instant() {\n    return Instant.ofEpochMilli(this.millis());\n  };\n  SystemClock.prototype.equals = function equals(obj) {\n    if (obj instanceof SystemClock) {\n      return this._zone.equals(obj._zone);\n    }\n    return false;\n  };\n  SystemClock.prototype.withZone = function withZone(zone) {\n    if (zone.equals(this._zone)) {\n      return this;\n    }\n    return new SystemClock(zone);\n  };\n  SystemClock.prototype.toString = function toString() {\n    return 'SystemClock[' + this._zone.toString() + ']';\n  };\n  return SystemClock;\n}(Clock);\nvar FixedClock = function (_Clock2) {\n  _inherits$w(FixedClock, _Clock2);\n  function FixedClock(fixedInstant, zoneId) {\n    _classCallCheck$X(this, FixedClock);\n    var _this2 = _possibleConstructorReturn$w(this, _Clock2.call(this));\n    _this2._instant = fixedInstant;\n    _this2._zoneId = zoneId;\n    return _this2;\n  }\n  FixedClock.prototype.instant = function instant() {\n    return this._instant;\n  };\n  FixedClock.prototype.millis = function millis() {\n    return this._instant.toEpochMilli();\n  };\n  FixedClock.prototype.zone = function zone() {\n    return this._zoneId;\n  };\n  FixedClock.prototype.toString = function toString() {\n    return 'FixedClock[]';\n  };\n  FixedClock.prototype.equals = function equals(obj) {\n    if (obj instanceof FixedClock) {\n      return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);\n    }\n    return false;\n  };\n  FixedClock.prototype.withZone = function withZone(zone) {\n    if (zone.equals(this._zoneId)) {\n      return this;\n    }\n    return new FixedClock(this._instant, zone);\n  };\n  return FixedClock;\n}(Clock);\nvar OffsetClock = function (_Clock3) {\n  _inherits$w(OffsetClock, _Clock3);\n  function OffsetClock(baseClock, offset) {\n    _classCallCheck$X(this, OffsetClock);\n    var _this3 = _possibleConstructorReturn$w(this, _Clock3.call(this));\n    _this3._baseClock = baseClock;\n    _this3._offset = offset;\n    return _this3;\n  }\n  OffsetClock.prototype.zone = function zone() {\n    return this._baseClock.zone();\n  };\n  OffsetClock.prototype.withZone = function withZone(zone) {\n    if (zone.equals(this._baseClock.zone())) {\n      return this;\n    }\n    return new OffsetClock(this._baseClock.withZone(zone), this._offset);\n  };\n  OffsetClock.prototype.millis = function millis() {\n    return this._baseClock.millis() + this._offset.toMillis();\n  };\n  OffsetClock.prototype.instant = function instant() {\n    return this._baseClock.instant().plus(this._offset);\n  };\n  OffsetClock.prototype.equals = function equals(obj) {\n    if (obj instanceof OffsetClock) {\n      return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);\n    }\n    return false;\n  };\n  OffsetClock.prototype.toString = function toString() {\n    return 'OffsetClock[' + this._baseClock + ',' + this._offset + ']';\n  };\n  return OffsetClock;\n}(Clock);\nfunction _classCallCheck$Y(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar ZoneOffsetTransition = function () {\n  ZoneOffsetTransition.of = function of(transition, offsetBefore, offsetAfter) {\n    return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);\n  };\n  function ZoneOffsetTransition(transition, offsetBefore, offsetAfter) {\n    _classCallCheck$Y(this, ZoneOffsetTransition);\n    requireNonNull(transition, 'transition');\n    requireNonNull(offsetBefore, 'offsetBefore');\n    requireNonNull(offsetAfter, 'offsetAfter');\n    if (offsetBefore.equals(offsetAfter)) {\n      throw new IllegalArgumentException('Offsets must not be equal');\n    }\n    if (transition.nano() !== 0) {\n      throw new IllegalArgumentException('Nano-of-second must be zero');\n    }\n    if (transition instanceof LocalDateTime) {\n      this._transition = transition;\n    } else {\n      this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);\n    }\n    this._offsetBefore = offsetBefore;\n    this._offsetAfter = offsetAfter;\n  }\n  ZoneOffsetTransition.prototype.instant = function instant() {\n    return this._transition.toInstant(this._offsetBefore);\n  };\n  ZoneOffsetTransition.prototype.toEpochSecond = function toEpochSecond() {\n    return this._transition.toEpochSecond(this._offsetBefore);\n  };\n  ZoneOffsetTransition.prototype.dateTimeBefore = function dateTimeBefore() {\n    return this._transition;\n  };\n  ZoneOffsetTransition.prototype.dateTimeAfter = function dateTimeAfter() {\n    return this._transition.plusSeconds(this.durationSeconds());\n  };\n  ZoneOffsetTransition.prototype.offsetBefore = function offsetBefore() {\n    return this._offsetBefore;\n  };\n  ZoneOffsetTransition.prototype.offsetAfter = function offsetAfter() {\n    return this._offsetAfter;\n  };\n  ZoneOffsetTransition.prototype.duration = function duration() {\n    return Duration.ofSeconds(this.durationSeconds());\n  };\n  ZoneOffsetTransition.prototype.durationSeconds = function durationSeconds() {\n    return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();\n  };\n  ZoneOffsetTransition.prototype.isGap = function isGap() {\n    return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();\n  };\n  ZoneOffsetTransition.prototype.isOverlap = function isOverlap() {\n    return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();\n  };\n  ZoneOffsetTransition.prototype.isValidOffset = function isValidOffset(offset) {\n    return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);\n  };\n  ZoneOffsetTransition.prototype.validOffsets = function validOffsets() {\n    if (this.isGap()) {\n      return [];\n    } else {\n      return [this._offsetBefore, this._offsetAfter];\n    }\n  };\n  ZoneOffsetTransition.prototype.compareTo = function compareTo(transition) {\n    return this.instant().compareTo(transition.instant());\n  };\n  ZoneOffsetTransition.prototype.equals = function equals(other) {\n    if (other === this) {\n      return true;\n    }\n    if (other instanceof ZoneOffsetTransition) {\n      var d = other;\n      return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());\n    }\n    return false;\n  };\n  ZoneOffsetTransition.prototype.hashCode = function hashCode() {\n    return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;\n  };\n  ZoneOffsetTransition.prototype.toString = function toString() {\n    return 'Transition[' + (this.isGap() ? 'Gap' : 'Overlap') + ' at ' + this._transition.toString() + this._offsetBefore.toString() + ' to ' + this._offsetAfter + ']';\n  };\n  return ZoneOffsetTransition;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nfunction _init$k() {\n  TemporalQueries.ZONE_ID = createTemporalQuery('ZONE_ID', function (temporal) {\n    return temporal.query(TemporalQueries.ZONE_ID);\n  });\n  TemporalQueries.CHRONO = createTemporalQuery('CHRONO', function (temporal) {\n    return temporal.query(TemporalQueries.CHRONO);\n  });\n  TemporalQueries.PRECISION = createTemporalQuery('PRECISION', function (temporal) {\n    return temporal.query(TemporalQueries.PRECISION);\n  });\n  TemporalQueries.OFFSET = createTemporalQuery('OFFSET', function (temporal) {\n    if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {\n      return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));\n    }\n    return null;\n  });\n  TemporalQueries.ZONE = createTemporalQuery('ZONE', function (temporal) {\n    var zone = temporal.query(TemporalQueries.ZONE_ID);\n    return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);\n  });\n  TemporalQueries.LOCAL_DATE = createTemporalQuery('LOCAL_DATE', function (temporal) {\n    if (temporal.isSupported(ChronoField.EPOCH_DAY)) {\n      return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));\n    }\n    return null;\n  });\n  TemporalQueries.LOCAL_TIME = createTemporalQuery('LOCAL_TIME', function (temporal) {\n    if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {\n      return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));\n    }\n    return null;\n  });\n}\nfunction _classCallCheck$Z(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$x(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$x(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar SystemDefaultZoneRules = function (_ZoneRules) {\n  _inherits$x(SystemDefaultZoneRules, _ZoneRules);\n  function SystemDefaultZoneRules() {\n    _classCallCheck$Z(this, SystemDefaultZoneRules);\n    return _possibleConstructorReturn$x(this, _ZoneRules.apply(this, arguments));\n  }\n  SystemDefaultZoneRules.prototype.isFixedOffset = function isFixedOffset() {\n    return false;\n  };\n  SystemDefaultZoneRules.prototype.offsetOfInstant = function offsetOfInstant(instant) {\n    var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();\n    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n  };\n  SystemDefaultZoneRules.prototype.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {\n    var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();\n    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n  };\n  SystemDefaultZoneRules.prototype.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {\n    var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1000;\n    var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();\n    var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 60000;\n    var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();\n    return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);\n  };\n  SystemDefaultZoneRules.prototype.validOffsets = function validOffsets(localDateTime) {\n    return [this.offsetOfLocalDateTime(localDateTime)];\n  };\n  SystemDefaultZoneRules.prototype.transition = function transition() {\n    return null;\n  };\n  SystemDefaultZoneRules.prototype.standardOffset = function standardOffset(instant) {\n    return this.offsetOfInstant(instant);\n  };\n  SystemDefaultZoneRules.prototype.daylightSavings = function daylightSavings() {\n    this._throwNotSupported();\n  };\n  SystemDefaultZoneRules.prototype.isDaylightSavings = function isDaylightSavings() {\n    this._throwNotSupported();\n  };\n  SystemDefaultZoneRules.prototype.isValidOffset = function isValidOffset(dateTime, offset) {\n    return this.offsetOfLocalDateTime(dateTime).equals(offset);\n  };\n  SystemDefaultZoneRules.prototype.nextTransition = function nextTransition() {\n    this._throwNotSupported();\n  };\n  SystemDefaultZoneRules.prototype.previousTransition = function previousTransition() {\n    this._throwNotSupported();\n  };\n  SystemDefaultZoneRules.prototype.transitions = function transitions() {\n    this._throwNotSupported();\n  };\n  SystemDefaultZoneRules.prototype.transitionRules = function transitionRules() {\n    this._throwNotSupported();\n  };\n  SystemDefaultZoneRules.prototype._throwNotSupported = function _throwNotSupported() {\n    throw new DateTimeException('not supported operation');\n  };\n  SystemDefaultZoneRules.prototype.equals = function equals(other) {\n    if (this === other || other instanceof SystemDefaultZoneRules) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  SystemDefaultZoneRules.prototype.toString = function toString() {\n    return 'SYSTEM';\n  };\n  return SystemDefaultZoneRules;\n}(ZoneRules);\nfunction _classCallCheck$_(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$y(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$y(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar SystemDefaultZoneId = function (_ZoneId) {\n  _inherits$y(SystemDefaultZoneId, _ZoneId);\n  function SystemDefaultZoneId() {\n    _classCallCheck$_(this, SystemDefaultZoneId);\n    var _this = _possibleConstructorReturn$y(this, _ZoneId.call(this));\n    _this._rules = new SystemDefaultZoneRules();\n    return _this;\n  }\n  SystemDefaultZoneId.prototype.rules = function rules() {\n    return this._rules;\n  };\n  SystemDefaultZoneId.prototype.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n    return false;\n  };\n  SystemDefaultZoneId.prototype.id = function id() {\n    return 'SYSTEM';\n  };\n  return SystemDefaultZoneId;\n}(ZoneId);\nfunction _classCallCheck$10(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar ZoneIdFactory = function () {\n  function ZoneIdFactory() {\n    _classCallCheck$10(this, ZoneIdFactory);\n  }\n  ZoneIdFactory.systemDefault = function systemDefault() {\n    return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n  };\n  ZoneIdFactory.getAvailableZoneIds = function getAvailableZoneIds() {\n    return ZoneRulesProvider.getAvailableZoneIds();\n  };\n  ZoneIdFactory.of = function of(zoneId) {\n    requireNonNull(zoneId, 'zoneId');\n    if (zoneId === 'Z') {\n      return ZoneOffset.UTC;\n    }\n    if (zoneId.length === 1) {\n      throw new DateTimeException('Invalid zone: ' + zoneId);\n    }\n    if (StringUtil.startsWith(zoneId, '+') || StringUtil.startsWith(zoneId, '-')) {\n      return ZoneOffset.of(zoneId);\n    }\n    if (zoneId === 'UTC' || zoneId === 'GMT' || zoneId === 'GMT0' || zoneId === 'UT') {\n      return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());\n    }\n    if (StringUtil.startsWith(zoneId, 'UTC+') || StringUtil.startsWith(zoneId, 'GMT+') || StringUtil.startsWith(zoneId, 'UTC-') || StringUtil.startsWith(zoneId, 'GMT-')) {\n      var offset = ZoneOffset.of(zoneId.substring(3));\n      if (offset.totalSeconds() === 0) {\n        return new ZoneRegion(zoneId.substring(0, 3), offset.rules());\n      }\n      return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());\n    }\n    if (StringUtil.startsWith(zoneId, 'UT+') || StringUtil.startsWith(zoneId, 'UT-')) {\n      var _offset = ZoneOffset.of(zoneId.substring(2));\n      if (_offset.totalSeconds() === 0) {\n        return new ZoneRegion('UT', _offset.rules());\n      }\n      return new ZoneRegion('UT' + _offset.id(), _offset.rules());\n    }\n    if (zoneId === 'SYSTEM') {\n      return ZoneId.systemDefault();\n    }\n    return ZoneRegion.ofId(zoneId);\n  };\n  ZoneIdFactory.ofOffset = function ofOffset(prefix, offset) {\n    requireNonNull(prefix, 'prefix');\n    requireNonNull(offset, 'offset');\n    if (prefix.length === 0) {\n      return offset;\n    }\n    if (prefix === 'GMT' || prefix === 'UTC' || prefix === 'UT') {\n      if (offset.totalSeconds() === 0) {\n        return new ZoneRegion(prefix, offset.rules());\n      }\n      return new ZoneRegion(prefix + offset.id(), offset.rules());\n    }\n    throw new IllegalArgumentException('Invalid prefix, must be GMT, UTC or UT: ' + prefix);\n  };\n  ZoneIdFactory.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    var obj = temporal.query(TemporalQueries.zone());\n    if (obj == null) {\n      throw new DateTimeException('Unable to obtain ZoneId from TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n    return obj;\n  };\n  return ZoneIdFactory;\n}();\nvar SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;\nfunction _init$l() {\n  SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();\n  ZoneId.systemDefault = ZoneIdFactory.systemDefault;\n  ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;\n  ZoneId.of = ZoneIdFactory.of;\n  ZoneId.ofOffset = ZoneIdFactory.ofOffset;\n  ZoneId.from = ZoneIdFactory.from;\n  ZoneOffset.from = ZoneIdFactory.from;\n  ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n  ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar isInit = false;\nfunction init() {\n  if (isInit) {\n    return;\n  }\n  isInit = true;\n  _init$1();\n  _init();\n  _init$2();\n  _init$3();\n  _init$i();\n  _init$8();\n  _init$k();\n  _init$4();\n  _init$j();\n  _init$g();\n  _init$h();\n  _init$d();\n  _init$5();\n  _init$c();\n  _init$b();\n  _init$6();\n  _init$7();\n  _init$f();\n  _init$l();\n  _init$e();\n  _init$a();\n  _init$9();\n}\ninit();\nfunction _classCallCheck$11(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar ToNativeJsConverter = function () {\n  function ToNativeJsConverter(temporal, zone) {\n    _classCallCheck$11(this, ToNativeJsConverter);\n    var zonedDateTime = void 0;\n    if (temporal instanceof LocalDate) {\n      zone = zone == null ? ZoneId.systemDefault() : zone;\n      zonedDateTime = temporal.atStartOfDay(zone);\n    } else if (temporal instanceof LocalDateTime) {\n      zone = zone == null ? ZoneId.systemDefault() : zone;\n      zonedDateTime = temporal.atZone(zone);\n    } else if (temporal instanceof ZonedDateTime) {\n      if (zone == null) {\n        zonedDateTime = temporal;\n      } else {\n        zonedDateTime = temporal.withZoneSameInstant(zone);\n      }\n    } else {\n      throw new IllegalArgumentException('unsupported instance for convert operation:' + temporal);\n    }\n    this.instant = zonedDateTime.toInstant();\n  }\n  ToNativeJsConverter.prototype.toDate = function toDate() {\n    return new Date(this.instant.toEpochMilli());\n  };\n  ToNativeJsConverter.prototype.toEpochMilli = function toEpochMilli() {\n    return this.instant.toEpochMilli();\n  };\n  return ToNativeJsConverter;\n}();\nfunction convert(temporal, zone) {\n  return new ToNativeJsConverter(temporal, zone);\n}\nfunction _classCallCheck$12(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn$z(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits$z(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nvar NativeJsTemporal = function (_TemporalAccessor) {\n  _inherits$z(NativeJsTemporal, _TemporalAccessor);\n  function NativeJsTemporal(date) {\n    var zone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZoneId.systemDefault();\n    _classCallCheck$12(this, NativeJsTemporal);\n    var _this = _possibleConstructorReturn$z(this, _TemporalAccessor.call(this));\n    _this._zone = zone;\n    if (date instanceof Date) {\n      _this._epochMilli = date.getTime();\n      return _possibleConstructorReturn$z(_this);\n    } else if (typeof date.toDate === 'function' && date.toDate() instanceof Date) {\n      _this._epochMilli = date.toDate().getTime();\n      return _possibleConstructorReturn$z(_this);\n    }\n    assert(false, 'date must be either a javascript date or a moment');\n    return _this;\n  }\n  NativeJsTemporal.prototype.query = function query(_query) {\n    requireNonNull(_query, 'query');\n    if (_query === TemporalQueries.localDate()) {\n      return LocalDate.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n    } else if (_query === TemporalQueries.localTime()) {\n      return LocalTime.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n    } else if (_query === TemporalQueries.zone()) {\n      return this._zone;\n    }\n    return _TemporalAccessor.prototype.query.call(this, _query);\n  };\n  NativeJsTemporal.prototype.get = function get(field) {\n    return this.getLong(field);\n  };\n  NativeJsTemporal.prototype.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.NANO_OF_SECOND:\n          return MathUtil.floorMod(this._epochMilli, 1000) * 1000000;\n        case ChronoField.INSTANT_SECONDS:\n          return MathUtil.floorDiv(this._epochMilli, 1000);\n      }\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n    return field.getFrom(this);\n  };\n  NativeJsTemporal.prototype.isSupported = function isSupported(field) {\n    return field === ChronoField.INSTANT_SECONDS || field === ChronoField.NANO_OF_SECOND;\n  };\n  return NativeJsTemporal;\n}(TemporalAccessor);\nfunction nativeJs(date, zone) {\n  return new NativeJsTemporal(date, zone);\n}\nfunction bindUse(jsJoda) {\n  var used = [];\n  return function use(fn) {\n    if (!~used.indexOf(fn)) {\n      fn(jsJoda);\n      used.push(fn);\n    }\n    return jsJoda;\n  };\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar _ = {\n  assert: assert$1,\n  DateTimeBuilder: DateTimeBuilder,\n  DateTimeParseContext: DateTimeParseContext,\n  DateTimePrintContext: DateTimePrintContext,\n  MathUtil: MathUtil,\n  StringUtil: StringUtil,\n  StringBuilder: StringBuilder\n};\nvar jsJodaExports = {\n  _: _,\n  convert: convert,\n  nativeJs: nativeJs,\n  ArithmeticException: ArithmeticException,\n  DateTimeException: DateTimeException,\n  DateTimeParseException: DateTimeParseException,\n  IllegalArgumentException: IllegalArgumentException,\n  IllegalStateException: IllegalStateException,\n  UnsupportedTemporalTypeException: UnsupportedTemporalTypeException,\n  NullPointerException: NullPointerException,\n  Clock: Clock,\n  DayOfWeek: DayOfWeek,\n  Duration: Duration,\n  Instant: Instant,\n  LocalDate: LocalDate,\n  LocalTime: LocalTime,\n  LocalDateTime: LocalDateTime,\n  Month: Month,\n  MonthDay: MonthDay,\n  Period: Period,\n  Year: Year,\n  YearConstants: YearConstants,\n  YearMonth: YearMonth,\n  ZonedDateTime: ZonedDateTime,\n  ZoneOffset: ZoneOffset,\n  ZoneId: ZoneId,\n  ZoneRegion: ZoneRegion,\n  ZoneOffsetTransition: ZoneOffsetTransition,\n  ZoneRules: ZoneRules,\n  ZoneRulesProvider: ZoneRulesProvider,\n  ChronoLocalDate: ChronoLocalDate,\n  ChronoLocalDateTime: ChronoLocalDateTime,\n  ChronoZonedDateTime: ChronoZonedDateTime,\n  IsoChronology: IsoChronology,\n  ChronoField: ChronoField,\n  ChronoUnit: ChronoUnit,\n  IsoFields: IsoFields,\n  Temporal: Temporal,\n  TemporalAccessor: TemporalAccessor,\n  TemporalAdjuster: TemporalAdjuster,\n  TemporalAdjusters: TemporalAdjusters,\n  TemporalAmount: TemporalAmount,\n  TemporalField: TemporalField,\n  TemporalQueries: TemporalQueries,\n  TemporalQuery: TemporalQuery,\n  TemporalUnit: TemporalUnit,\n  ValueRange: ValueRange,\n  DateTimeFormatter: DateTimeFormatter,\n  DateTimeFormatterBuilder: DateTimeFormatterBuilder,\n  DecimalStyle: DecimalStyle,\n  ResolverStyle: ResolverStyle,\n  SignStyle: SignStyle,\n  TextStyle: TextStyle\n};\nvar use = bindUse(jsJodaExports);\njsJodaExports.use = use;\nexport { _, use, convert, nativeJs, ArithmeticException, DateTimeException, DateTimeParseException, IllegalArgumentException, IllegalStateException, UnsupportedTemporalTypeException, NullPointerException, Clock, DayOfWeek, Duration, Instant, LocalDate, LocalTime, LocalDateTime, Month, MonthDay, Period, Year, YearConstants, YearMonth, ZonedDateTime, ZoneOffset, ZoneId, ZoneRegion, ZoneOffsetTransition, ZoneRules, ZoneRulesProvider, ChronoLocalDate, ChronoLocalDateTime, ChronoZonedDateTime, IsoChronology, ChronoField, ChronoUnit, IsoFields, Temporal, TemporalAccessor, TemporalAdjuster, TemporalAdjusters, TemporalAmount, TemporalField, TemporalQueries, TemporalQuery, TemporalUnit, ValueRange, DateTimeFormatter, DateTimeFormatterBuilder, DecimalStyle, ResolverStyle, SignStyle, TextStyle };","map":null,"metadata":{},"sourceType":"module"}